<?xml version="1.0"  encoding="UTF-8" ?>
  <page>
    <title>XML</title>
    <id>34138</id>
    <revision>
      <id>182105147</id>
      <timestamp>2008-01-04T14:51:19Z</timestamp>
      <contributor>
        <username>Jauerback</username>
        <id>4088067</id>
      </contributor>
      <minor />
      <comment>Reverted edits by [[Special:Contributions/121.247.13.45|121.247.13.45]] ([[User talk:121.247.13.45|talk]]) to last version by Peterl</comment>
      <text xml:space="preserve"><summary><p>&lt;!-- 
Warning to AutoWikiBrowser users do not attempt to Unicodify this page many of the &amp;# notations are in context and should not be converted to their glyph representations</p>

<p>Don't change &quot;Extensible&quot; to &quot;eXtensible&quot;! See http://www.xml.com/axml/notes/TheCorrectTitle.html from the Annotated XML Specification.</p>

<p>Elements not tags! For instance, &lt;!ELEMENT&gt; vs &lt;!TAG&gt;.
 --&gt;
<template head="Infobox file format"><field name="name"> Extensible Markup Language
</field><field name="icon"> 
</field><field name="logo">
</field><field name="screenshot"> <img src="XML.svg">200px</img>
</field><field name="extension"> .xml
</field><field name="mime"> application/xml, text/xml (deprecated)
</field><field name="type code"> 
</field><field name="uniform type"> public.xml
</field><field name="magic"> 
</field><field name="owner"> <link label="World Wide Web Consortium">World Wide Web Consortium</link>
</field><field name="genre"> <link label="Markup language">Markup language</link>
</field><field name="container for"> 
</field><field name="contained by"> 
</field><field name="extended from"> <link label="Standard Generalized Markup Language">SGML</link>
</field><field name="extended to"> <link label="XHTML">XHTML</link>, <link label="RSS">RSS</link>, <link label="Atom (standard)">Atom</link>, ...
</field><field name="standard"> <external href="http://www.w3.org/TR/2006/REC-xml-20060816/">1.0 (Fourth Edition)</external> <external href="http://www.w3.org/TR/2006/REC-xml11-20060816/">1.1 (Second Edition)</external>
</field></template>
The <b>Extensible Markup Language</b> (<b>XML</b>) is a general-purpose <link label="Markup language">markup language</link>.<ref>More precisely, XML is a general-purpose <i>specification</i> for creating custom markup languages.</ref> It is classified as an <link label="Extensible language">extensible language</link> because it allows its users to define their own elements. Its primary purpose is to facilitate the sharing of structured data across different information systems, particularly via the <link label="Internet">Internet</link>.&lt;ref name=XmlOriginsGoals&gt;<template head="cite web"><field name="title">Extensible Markup Language (XML) 1.0 (Fourth Edition) - Origin and Goals </field><field name="url">http://www.w3.org/TR/2006/REC-xml-20060816/#sec-origin-goals </field><field name="first">Tim </field><field name="last">Bray</field><field name="coauthors">Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau  </field><field name="year">September 2006 </field><field name="publisher">World Wide Web Consortium </field><field name="accessmonthday">October 29 </field><field name="accessyear">2006 </field></template>&lt;/ref&gt; It is used both to encode documents and <link label="Serialization">serialize</link> data. In the latter context, it is comparable with other text-based serialization languages such as <link label="JSON">JSON</link> and <link label="YAML">YAML</link>.<ref>JSON and YAML are among other alternative text-based formats commonly described as lighter-weight and less verbose in comparison to XML. See <link label="#Critique of XML">Critique of XML</link> in this article.</ref></p>

<p>It started as a simplified subset of the <link label="Standard Generalized Markup Language">Standard Generalized Markup Language</link> (SGML), and is designed to be relatively human-legible. By adding semantic constraints, application languages can be implemented in XML. These include <link label="XHTML">XHTML</link>,<ref>XHTML is an attempt to simplify and improve the consistency of <link label="HTML">HTML</link>, which was based on SGML.</ref> <link label="RSS (file format)">RSS</link>, <link label="MathML">MathML</link>, <link label="GraphML">GraphML</link>, <link label="Scalable Vector Graphics">Scalable Vector Graphics</link>, <link label="MusicXML">MusicXML</link>, and thousands of others. Moreover, XML is sometimes used as the <link label="Specification language">specification language</link> for such application languages.</p>

<p>XML is <link label="W3C recommendation">recommended</link> by the <link label="World Wide Web Consortium">World Wide Web Consortium</link>. It is a fee-free <link label="Open standard">open standard</link>.
The W3C recommendation specifies both the <link label="Lexical grammar">lexical grammar</link>, and the requirements for <link label="Parsing">parsing</link>. </p>
</summary><section depth="1"><title>Well-formed and valid XML documents</title>

<p>There are two levels of correctness of an XML document:
* <b>Well-formed</b>. A well-formed document conforms to all of XML's syntax rules. For example, if a start-tag appears without a corresponding end-tag, it is not <i>well-formed</i>. A document that is not well-formed is not considered to be XML; a <i>conforming parser</i> is not allowed to process it.
* <b>Valid</b>. A valid document additionally conforms to some semantic rules. These rules are either user-defined, or included as an <link label="XML schema">XML schema</link> or <link label="Document Type Definition">DTD</link>. For example, if a document contains an undefined element, then it is not <i>valid</i>; a <i>validating parser</i> is not allowed to process it.</p>
</section><section depth="1"><title>Well-formed documents: XML syntax</title>

<p>As long as only well-formedness is required, XML is a generic framework for storing any amount of text or any data whose structure can be represented as a tree.
The only indispensable syntactical requirement is that the document has exactly one <b>root element</b> (alternatively called the <b>document element</b>). This means that the text must be enclosed between a root start-tag and a corresponding end-tag.
The following is a &quot;well-formed&quot; XML document:
&lt;source lang=&quot;xml&quot;&gt;
&lt;book&gt;This is a book.... &lt;/book&gt;
&lt;/source&gt;</p>

<p>The root element can be preceded by an optional <b>XML declaration</b>. This element states what version of XML is in use (normally 1.0); it may also contain information about <link label="Character encoding">character encoding</link> and external dependencies.
&lt;source lang=&quot;xml&quot;&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;/source&gt;</p>

<p>The specification <i>requires</i> that processors of XML support the pan-<link label="Unicode">Unicode</link> <link label="Character encoding">character encoding</link>s <link label="UTF-8">UTF-8</link> and <link label="UTF-16/UCS-2">UTF-16</link> (<link label="UTF-32/UCS-4">UTF-32</link> is not mandatory). The use of more limited encodings, such as those based on <link label="ISO/IEC 8859">ISO/IEC 8859</link>, is acknowledged and is widely used and supported.</p>

<p><b>Comments</b> can be placed anywhere in the tree, including in the text if the content of the element is text or #PCDATA.</p>

<p>XML comments start with <b>&amp;lt;!--</b> and end with <b>--&amp;gt;</b>.  Two dashes (--) may not appear anywhere in the text of the comment.</p>

<p>&lt;source lang=&quot;xml&quot;&gt;
&lt;!-- This is a comment. --&gt;
&lt;/source&gt;</p>

<p>In any meaningful application, additional markup is used to structure the contents of the XML document. The text enclosed by the root tags may contain an arbitrary number of XML elements.
The basic syntax for one <b>element</b> is:
&lt;source lang=&quot;xml&quot;&gt;
&lt;name attribute=&quot;value&quot;&gt;content&lt;/name&gt;
&lt;/source&gt;
The two instances of »name« are referred to as the <b>start-tag</b> and <b>end-tag</b>, respectively.
Here, »content« is some text which may again contain XML elements. So, a generic XML document contains a
<link label="Tree (data structure)">tree-based data structure</link>.
Here is an example of a structured XML document:
&lt;source lang=&quot;xml&quot;&gt;
 &lt;recipe name=&quot;bread&quot; prep_time=&quot;5 mins&quot; cook_time=&quot;3 hours&quot;&gt;
   &lt;title&gt;Basic bread&lt;/title&gt;
   &lt;ingredient amount=&quot;3&quot; unit=&quot;cups&quot;&gt;Flour&lt;/ingredient&gt;
   &lt;ingredient amount=&quot;0.25&quot; unit=&quot;ounce&quot;&gt;Yeast&lt;/ingredient&gt;
   &lt;ingredient amount=&quot;1.5&quot; unit=&quot;cups&quot; state=&quot;warm&quot;&gt;Water&lt;/ingredient&gt;
   &lt;ingredient amount=&quot;1&quot; unit=&quot;teaspoon&quot;&gt;Salt&lt;/ingredient&gt;
   &lt;instructions&gt;
     &lt;step&gt;Mix all ingredients together.&lt;/step&gt;
     &lt;step&gt;Knead thoroughly.&lt;/step&gt;
     &lt;step&gt;Cover with a cloth, and leave for one hour in warm room.&lt;/step&gt;
     &lt;step&gt;Knead again.&lt;/step&gt;
     &lt;step&gt;Place in a bread baking tin.&lt;/step&gt;
     &lt;step&gt;Cover with a cloth, and leave for one hour in warm room.&lt;/step&gt;
     &lt;step&gt;Bake in the oven at 350°F for 30 minutes.&lt;/step&gt;
   &lt;/instructions&gt;
 &lt;/recipe&gt;
&lt;/source&gt;</p>

<p>Attribute values must always be quoted, using single or double quotes; and each attribute name should appear only once in any element.
XML requires that elements be properly nested &amp;mdash; elements may never overlap.  For example, the code below is not well-formed XML, because the <i><link label="EM">em</link></i> and <i><link label="Strong">strong</link></i> elements overlap:
&lt;source lang=&quot;xml&quot;&gt;
&lt;!-- WRONG! NOT WELL-FORMED XML! --&gt;
&lt;p&gt;Normal &lt;em&gt;emphasized &lt;strong&gt;strong emphasized&lt;/em&gt; strong&lt;/strong&gt;&lt;/p&gt;</p>

<p>&lt;!-- Correct: Well-formed XML. --&gt;
&lt;p&gt;Normal &lt;em&gt;emphasized &lt;strong&gt;strong emphasized&lt;/strong&gt;&lt;/em&gt; &lt;strong&gt;strong&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Alternatively &lt;em&gt;emphasized&lt;/em&gt; &lt;strong&gt;&lt;em&gt;strong emphasized&lt;/em&gt; strong&lt;/strong&gt;&lt;/p&gt;</p>

<p>&lt;/source&gt;
XML provides special syntax for representing an element with empty content.  Instead of writing a start-tag followed immediately by an end-tag, a document may contain an empty-element tag.  An empty-element tag resembles a start-tag but contains a slash just before the closing angle bracket.  The following three examples are equivalent in XML:
&lt;source lang=&quot;xml&quot;&gt;
&lt;foo&gt;&lt;/foo&gt;
&lt;foo /&gt;
&lt;foo/&gt;
&lt;/source&gt;
An empty-element may contain attributes:
&lt;source lang=&quot;xml&quot;&gt;
&lt;info author=&quot;John&quot; genre=&quot;science-fiction&quot; date=&quot;2009-Jan-01&quot; /&gt;
&lt;/source&gt;</p>
<section depth="2"><title>Entity references</title>

<p>An <link label="SGML entity">entity</link> in XML is a named body of data, usually text. Entities are often used to represent single characters that cannot easily be entered on the keyboard; they are also used to represent pieces of standard (&quot;boilerplate&quot;) text that occur in many documents, especially if there is a need to allow such text to be changed in one place only.</p>

<p>Special characters can be represented either using  <link label="SGML entity">entity</link> references, or by means of <link label="Numeric character reference">numeric character reference</link>s. An example of a numeric character reference is &quot;&lt;code&gt;&amp;amp;#x20AC;&lt;/code&gt;&quot;, which refers to the <link label="Euro symbol">Euro symbol</link> by means of its <link label="Unicode">Unicode</link>
codepoint in <link label="Hexadecimal">hexadecimal</link>. </p>

<p>An entity reference is a <link label="Placeholder">placeholder</link> that represents that entity. It consists of the entity's name preceded by an <link label="Ampersand">ampersand</link> (&quot;&lt;code&gt;&amp;amp;&lt;/code&gt;&quot;) and followed by a <link label="Semicolon">semicolon</link> (&quot;&lt;code&gt;;&lt;/code&gt;&quot;). XML has five <link label="Predeclared">predeclared</link> entities:
{|
|&lt;code&gt;&amp;amp;amp;&lt;/code&gt; || &amp;amp; || ampersand
|-
|&lt;code&gt;&amp;amp;lt;&lt;code&gt;   || &amp;lt;  || less than
|-
|&lt;code&gt;&amp;amp;gt;&lt;code&gt;   || &amp;gt;  || greater than
|-
|&lt;code&gt;&amp;amp;apos;&lt;code&gt; || '     || apostrophe
|-
|&lt;code&gt;&amp;amp;quot;&lt;code&gt; || &quot;     || quotation mark
|}</p>

<p>Here is an example using a predeclared XML entity to represent the ampersand in the name &quot;AT&amp;amp;T&quot;:
&lt;source lang=&quot;xml&quot;&gt;
&lt;company_name&gt;AT&amp;amp;T&lt;/company_name&gt;
&lt;/source&gt;
Additional entities (beyond the predefined ones) can be declared in the document's <link label="XML#DTD">Document Type Definition (DTD)</link>.  A basic example of doing so in a minimal internal DTD follows. Declared entities can describe single characters or pieces of text, and can reference each other.
&lt;source lang=&quot;xml&quot;&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE example [
    &lt;!ENTITY copy &quot;&amp;#xA9;&quot;&gt;
    &lt;!ENTITY copyright-notice &quot;Copyright &amp;copy; 2006, XYZ Enterprises&quot;&gt;
]&gt;
&lt;example&gt;
    &amp;copyright-notice;
&lt;/example&gt;
&lt;/source&gt;</p>

<p>When viewed in a suitable browser, the XML document above appears as:</p>

 <p>&lt;example&gt; Copyright © 2006, XYZ Enterprises &lt;/example&gt;</p>
<section depth="3"><title>Numeric character references</title>
<p>Numeric character references look like entity references, but instead of a name, they contain the &quot;&lt;code&gt;<link label="Number sign">#</link>&lt;/code&gt;&quot; character followed by a number.  The number (in decimal or &quot;&lt;code&gt;x&lt;/code&gt;&quot;-prefixed <link label="Hexadecimal">hexadecimal</link>) represents a Unicode code point. Unlike entity references, they are neither predeclared nor do they need to be declared in the document's DTD. They have typically been used to represent characters that are not easily encodable, such as an <link label="Arabic language">Arabic</link> character in a document produced on a European computer.  The ampersand in the &quot;AT&amp;amp;T&quot; example could also be <link label="Escape character">escaped</link> like this (decimal 38 and hexadecimal 26 both represent the Unicode code point for the &quot;&amp;amp;&quot; character):
&lt;source lang=&quot;xml&quot;&gt;
&lt;company_name&gt;AT&amp;#38;T&lt;/company_name&gt;
&lt;company_name&gt;AT&amp;#x26;T&lt;/company_name&gt;
&lt;/source&gt;</p>

<p>See also <link label="Numeric character reference">numeric character reference</link>s.</p>
</section></section><section depth="2"><title>Well-formed documents</title>

<p>A well-formed document must conform to the following rules, among others: </p>

<p>* Non-empty elements are <link label="Delimiter">delimited</link> by both a start-tag and an end-tag.
* Empty elements may be marked with an empty-element (self-closing) tag, such as &lt;code&gt;&amp;lt;IAmEmpty /&gt;&lt;/code&gt;. This is equal to &lt;code&gt;&amp;lt;IAmEmpty&amp;gt;&amp;lt;/IAmEmpty&amp;gt;&lt;/code&gt;.
* All attribute values are quoted with either single (') or double (&quot;) quotes. Single quotes close a single quote and double quotes close a double quote.
* Tags may be nested but must not overlap. Each non-root element must be completely contained in another element.
* The document complies with its declared character encoding. The encoding may be declared or implied externally, such as in &quot;Content-Type&quot; headers when a document is transported via <link label="Hypertext Transfer Protocol">HTTP</link>, or internally, using explicit markup at the very beginning of the document. When no such declaration exists, a Unicode encoding is assumed, as defined by a Unicode <link label="Byte-order mark">Byte Order Mark</link> before the document's first character. If the mark does not exist, UTF-8 encoding is assumed.</p>

<p>Element names are case-sensitive. For example, the following is a well-formed matching pair:
:&lt;code&gt;&amp;lt;Step&gt;&lt;/code&gt; ... &lt;code&gt;&amp;lt;/Step&gt;&lt;/code&gt;
whereas this is not
:&lt;code&gt;&amp;lt;Step&gt;&lt;/code&gt; ... &lt;code&gt;&amp;lt;/step&gt;&lt;/code&gt;</p>

<p>The careful choice of names for XML elements will convey the meaning of the data in the <link label="Markup language">markup</link>. This increases human readability while retaining the rigor needed for software parsing.</p>

<p>Choosing meaningful names implies the <link label="Semantics">semantics</link> of elements and attributes to a human reader without reference to external documentation. However, this can lead to verbosity, which complicates <link label="Authoring">authoring</link> and increases <link label="File size">file size</link>.</p>
</section><section depth="2"><title>Automatic verification</title>

<p>It is relatively simple to verify that a document is well-formed or validated XML, because the rules of well-formedness and validation of XML are designed for portability of tools. The idea is that any tool designed to work with XML files will be able to work with XML files written in any XML language (or XML application). One example of using an independent tool follows:
* load it into an XML-capable browser, such as <link label="Mozilla Firefox">Firefox</link> or <link label="Internet Explorer">Internet Explorer</link>
* use a tool like xmlwf (usually bundled with <link label="Expat (XML)">expat</link>)
* parse the document, for instance in Ruby:
 irb&gt; require &quot;rexml/document&quot;
 irb&gt; include REXML
 irb&gt; doc = Document.new(File.new(&quot;test.xml&quot;)).root</p>
</section></section><section depth="1"><title>Valid documents: XML semantics</title>

<p>By leaving the names, allowable hierarchy, and meanings of the elements and attributes open and definable by a customizable <i><link label="XML schema">schema</link> or <link label="Document Type Definition">DTD</link></i>, XML provides a syntactic foundation for the creation of purpose specific, XML-based markup languages. The general syntax of such languages is rigid &amp;mdash; documents must adhere to the general rules of XML, ensuring that all XML-aware software can at least read and understand the relative arrangement of information within them. The schema merely supplements the syntax rules with a set of constraints. Schemas typically restrict element and attribute names and their allowable containment hierarchies, such as only allowing an element named 'birthday' to contain 1 element named 'month' and 1 element named 'day', each of which has to contain only character data. The constraints in a schema may also include <link label="Data type">data type</link> assignments that affect how information is processed; for example, the 'month' element's character data may be defined as being a month according to a particular schema language's conventions, perhaps meaning that it must not only be formatted a certain way, but also must not be processed as if it were some other type of data.</p>

<p>An XML document that complies with a particular schema/DTD, in addition to being well-formed, is said to be <b>valid</b>.</p>

<p>An XML schema is a description of a type of XML document, typically expressed in terms of <link label="Constraints">constraints</link> on the structure and content of documents of that type, above and beyond the basic constraints imposed by XML itself. A number of standard and proprietary XML schema languages have emerged for the purpose of formally expressing such schemas, and some of these languages are XML-based, themselves.</p>

<p>Before the advent of generalised data description languages such as SGML and XML, software designers had to define special <link label="File format">file format</link>s or small languages to share data between programs. This required writing detailed <link label="Specifications">specifications</link> and special-purpose parsers and <link label="Writer">writer</link>s.</p>

<p>XML's regular structure and strict parsing rules allow software designers to leave parsing to standard tools, and since XML provides a general, <link label="Data model">data model</link>-oriented framework for the development of application-specific languages, software designers need only concentrate on the development of rules for their data, at relatively high levels of abstraction.</p>

<p>Well-tested tools exist to <link label="Validate">validate</link> an XML document &quot;against&quot; a schema: the tool automatically <link label="Verify">verifies</link> whether the document conforms to constraints expressed in the schema. Some of these validation tools are included in XML parsers, and some are packaged separately.</p>

<p>Other usages of schemas exist: XML editors, for instance, can use schemas to support the editing process (by suggesting valid elements and attributes names, etc).</p>
<section depth="3"><title>DTD</title>
<template head="main"><link label="Document Type Definition">Document Type Definition</link></template>
<p>The oldest schema format for XML is the <link label="Document Type Definition">Document Type Definition</link> (DTD), inherited from SGML. While DTD support is ubiquitous due to its inclusion in the XML 1.0 standard, it is seen as limited for the following reasons:</p>

<p>* It has no support for newer <link label="Feature">feature</link>s of XML, most importantly <link label="XML Namespace">namespaces</link>.
* It lacks expressiveness. Certain formal aspects of an XML document cannot be captured in a DTD.
* It uses a custom non-XML syntax, inherited from <link label="SGML">SGML</link>, to describe the schema.</p>

<p>DTD is still used in many applications because it is considered the easiest to read and write.</p>
</section><section depth="3"><title>XML Schema</title>
<template head="main"><link label="XML Schema (W3C)">XML Schema (W3C)</link></template>
<p>A newer <link label="XML schema">XML schema</link> language, described by the W3C as the successor of DTDs, is <link label="XML Schema (W3C)">XML Schema</link>, or more informally referred to by the <link label="Acronym and initialism">initialism</link> for XML Schema instances, XSD (XML Schema Definition). XSDs are far more powerful than DTDs in describing XML languages. They use a rich <link label="Datatype">datatyping</link> system, allow for more detailed constraints on an XML document's logical structure, and must be processed in a more <link label="Robust">robust</link> validation framework. XSDs also use an XML-based format which makes it possible to use ordinary XML tools to help process them, although XSD implementations require much more than just the ability to read XML.</p>

<p>Criticisms of XSD include the following:
*The specification is very large, which makes it difficult to understand and implement.
*The XML-based syntax leads to verbosity in schema description, which makes XSDs harder to read and write.
*Schema validation can be an expensive addition to XML parsing, especially for high volume systems.
*The modeling capabilities are very limited, with no ability to allow attributes to influence <link label="Content model">content model</link>s. 
*The <link label="Type derivation model">type derivation model</link> is very limited, in particular that derivation by extension is rarely useful.
*Database-related <link label="Data transfer">data transfer</link> has been supported with arcane ideas such as nillability but the requirements of industrial publishing are under-supported.
*The key/<link label="Keyref">keyref</link>/<link label="Uniqueness">uniqueness</link> mechanisms are not type aware
*The <link label="PSVI">PSVI</link> concept (Post Schema Validation Infoset) does not have a standard XML representation or <link label="Application Programming Interface">Application Programming Interface</link>, thus it works against <link label="Vendor independence">vendor independence</link> unless revalidation is performed.</p>
</section><section depth="3"><title>RELAX NG</title>
<template head="main"><link label="RELAX NG">RELAX NG</link></template>
<p>Another popular schema language for XML is <link label="RELAX NG">RELAX NG</link>. Initially specified by <link label="OASIS (organization)">OASIS</link>, RELAX NG is now also an ISO international standard (as part of <link label="DSDL">DSDL</link>). It has two formats: an XML based syntax and a non-XML compact syntax. The compact syntax aims to increase readability and writability but, since there is a well-defined way to translate the compact syntax to the XML syntax and back again by means of <link label="James Clark (XML expert)">James Clark</link>'s <external href="http://www.thaiopensource.com/relaxng/trang.html">Trang conversion tool</external>, the advantage of using standard XML tools is not lost. RELAX NG has a simpler definition and validation framework than XML Schema, making it easier to use and implement. It also has the ability to use <link label="Datatype">datatype</link> framework  <link label="Plug-in">plug-in</link>s; a RELAX NG schema author, for example, can require values in an XML document to conform to definitions in XML Schema Datatypes.</p>
</section><section depth="3"><title>ISO DSDL and Other Schema Languages</title>
<p>The ISO <link label="DSDL">DSDL</link> (Document Schema Description Languages) standard brings together a comprehensive set of small schema languages, each targeted at specific problems. DSDL includes <link label="RELAX NG">RELAX NG</link> full and compact syntax, <link label="Schematron">Schematron</link> assertion language, and languages for defining datatypes, character repertoire constraints, renaming and entity expansion, and namespace-based <link label="Routing">routing</link> of document fragments to different validators. DSDL schema languages do not have the vendor support of XML Schemas yet, and are to some extent a grassroots reaction of industrial publishers to the lack of utility of XML Schemas for <link label="Publishing">publishing</link>. </p>

<p>Some schema languages not only describe the structure of a particular XML format but also offer limited facilities to influence processing of individual XML files that conform to this format. DTDs and XSDs both have this ability; they can for instance provide attribute defaults. RELAX NG and Schematron intentionally do not provide these; for example the <link label="Infoset">infoset</link> augmentation facility.</p>
</section><section depth="2"><title>International use</title>
<p>XML supports the direct use of almost any Unicode character (other than the ones that have special symbolic meaning in XML, itself, such as the open corner bracket, &quot;&lt;&quot;) in element names, attributes, comments, character data, and processing instructions. Therefore, the following is a well-formed XML document, even though it includes both <link label="Chinese character">Chinese</link> and <link label="Cyrillic alphabet">Cyrillic</link> characters:
&lt;source lang=&quot;xml&quot;&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;俄語&gt;Данные&lt;/俄語&gt;
&lt;/source&gt;</p>
</section></section><section depth="1"><title>Displaying XML on the web</title>
<p>XML documents do not carry information about how to display the data. Without using <link label="Cascading Style Sheets">CSS</link> or <link label="Extensible Stylesheet Language">XSL</link>, a generic XML document is rendered as raw XML text by most <link label="Web browser">web browser</link>s. Some display it with 'handles' (e.g. + and - signs in the margin) that allow parts of the structure to be expanded or collapsed with mouse-clicks. </p>

<p>In order to style the rendering in a browser with CSS, the XML document must include a reference to the <link label="Stylesheet">stylesheet</link>:
&lt;source lang=&quot;xml&quot;&gt;
&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;myStyleSheet.css&quot;?&gt;
&lt;/source&gt;</p>

<p>Note that this is different from specifying such a stylesheet in HTML, which uses the &lt;code&gt;&amp;lt;link&gt;&lt;/code&gt; element.</p>

<p><link label="Extensible Stylesheet Language">Extensible Stylesheet Language</link> (XSL) can be used to alter the format of XML data, either into HTML or other formats that are suitable for a browser to display. </p>

<p>To specify <link label="Client-side">client-side</link> <link label="XSL Transformations">XSL Transformation</link> (XSLT), the following processing instruction is required in the XML:
&lt;source lang=&quot;xml&quot;&gt;
&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;myTransform.xslt&quot;?&gt;
&lt;/source&gt;</p>

<p>Client-side XSLT is supported by many <link label="Web browser">web browser</link>s, but not <link label="Opera (web browser)">Opera</link> before version 9.0. An alternative, rather than being dependent on the <link label="End-user">end-user</link>'s browser capabilities, is to use XSL to convert XML into a displayable format <i>on the <link label="Server (computing)">server</link></i>. The end-user is not aware of what has gone on 'behind the scenes'; all they see is well-formatted, displayable data.</p>

<p>See the XSLT article <link label="XSL Transformations#Examples">for an example of server-side XSLT in action</link>.</p>
</section><section depth="1"><title>XML extensions</title>
<p>* <b><link label="XPath">XPath</link></b> makes it possible to refer to individual parts of an XML document. This provides random access to XML data for other technologies, including XSLT, XSL-FO, XQuery etc. XPath expressions can refer to all or part of the text, data and values in XML elements, attributes, processing instructions, comments etc. They can also access the names of elements and attributes. XPaths can be used in both valid and well-formed XML, with and without defined namespaces.
*<b><link label="XInclude">XInclude</link></b> defines the ability for XML files to include all or part of an external file. When processing is complete, the final XML infoset has no XInclude elements, but instead has copied the documents or parts thereof into the final infoset. It uses XPath to refer to a portion of the document for partial inclusions.
*<b><link label="XQuery">XQuery</link></b> is to XML what <link label="SQL">SQL</link> and <link label="PL/SQL">PL/SQL</link> are to <link label="Relational databases">relational databases</link>:  ways to access, manipulate and return XML.
*<b><link label="XML Namespace">XML Namespace</link>s</b> enable the same document to contain XML elements and attributes taken from different vocabularies, without any <link label="Naming collision">naming collision</link>s occurring.
*<b><link label="XML Signature">XML Signature</link></b> defines the syntax and processing rules for creating <link label="Digital signatures">digital signatures</link> on XML content.
*<b><link label="XML Encryption">XML Encryption</link></b> defines the syntax and processing rules for <link label="Encryption">encrypting</link> XML content.
* <b><link label="XPointer">XPointer</link></b> is a system for addressing components of XML-based internet media.</p>

<p>XML files may be served with a variety of <link label="MIME">Media types</link>.  RFC 3023 defines the types &quot;application/xml&quot; and &quot;text/xml&quot;, which say only that the data is in XML, and nothing about its semantics.  The use of &quot;text/xml&quot; has been criticized as a potential source of encoding problems but is now in the process of being deprecated.<ref>http://lists.xml.org/archives/xml-dev/200407/msg00208.html</ref> RFC 3023 also recommends that XML-based languages be given media types beginning in &quot;application/&quot; and ending in &quot;+xml&quot;; for example &quot;application/atom+xml&quot; for <link label="Atom (standard)">Atom</link>. This page discusses further <link label="XML and MIME">XML and MIME</link>.</p>
</section><section depth="1"><title>Processing XML files</title>

<p>Three traditional techniques for processing XML files are:
* Using a programming language and the <link label="Simple API for XML">SAX</link> <link label="Application programming interface">API</link>.
* Using a programming language and the <link label="DOM (XML API)">DOM</link> <link label="Application programming interface">API</link>.
* Using a transformation engine and a filter</p>

<p>More recent and emerging techniques for processing XML files are:
* Push Parsing
* Data binding</p>

<p>&lt;!--- 
<link label="Simple API for XML">SAX</link> and <link label="DOM (XML API)">DOM</link> are <link label="Object oriented programming">object oriented programming</link> <link label="Application programming interface">API</link>s widely used to process XML data. The first XML parsers exposed the contents of XML documents to applications as <link label="SAX">SAX</link> <link label="Event-driven programming">event</link>s or <link label="DOM">DOM</link> <link label="Object (computer science)">object</link>s.
--&gt;</p><section depth="2"><title>Simple API for XML (SAX)</title>
<p><link label="Simple API for XML">SAX</link> is a <link label="Lexical analysis">lexical</link>, <link label="Event-driven programming">event-driven</link> interface in which a document is read serially and its contents are reported as &quot;<link label="Callback">callback</link>s&quot; to various <link label="Method (computer science)">method</link>s on a <link label="Event handler">handler object</link> of the user's design. SAX is fast and efficient to implement, but difficult to use for extracting information at random from the XML, since it tends to burden the application author with keeping track of what part of the document is being processed. It is better suited to situations in which certain types of information are always handled the same way, no matter where they occur in the document.</p>
</section><section depth="2"><title>DOM</title>
<p><link label="Document Object Model">DOM</link> is an <link label="Interface">interface</link>-oriented <link label="Application Programming Interface">Application Programming Interface</link> that allows for navigation of the entire document as if it were a tree of &quot;<link label="Node (computer science)">Node</link>&quot; <link label="Object (computer science)">object</link>s representing the document's contents. A DOM document can be created by a parser, or can be generated manually by users (with limitations). Data types in DOM Nodes are abstract; implementations provide their own <link label="Programming">programming</link> language-specific <link label="Binding">binding</link>s. DOM implementations tend to be <link label="Memory">memory</link> intensive, as they generally require the entire document to be loaded into memory and constructed as a tree of objects before access is allowed.
DOM is supported in Java by several packages that usually come with the standard libraries.  As the DOM specification is regulated by the <link label="World Wide Web Consortium">World Wide Web Consortium</link>, the main interfaces (Node, Document, etc.) are in the package org.w3c.dom.*, as well as some of the events and interfaces for other capabilities like serialization (output).  The package com.sun.org.apache.xml.internal.serialize.* provides the serialization (output capacities) by impementing the appropriate interfaces, while the javax.xml.parsers.* package parses data to create DOM XML documents for manipulation.  <external href="http://java.sun.com/javase/6/docs/api">http://java.sun.com/javase/6/docs/api</external></p>
</section><section depth="2"><title>Transformation engines and filters</title>
<p>A <link label="Filter (software)">filter</link> in the <link label="Extensible Stylesheet Language">Extensible Stylesheet Language</link> (XSL) family can transform an XML file for <link label="Display">display</link>ing or <link label="Computer printer">print</link>ing.</p>

<p>* <b><link label="XSL-FO">XSL-FO</link></b> is a declarative, XML-based <link label="Page layout">page layout</link> language. An XSL-FO <link label="Processor">processor</link> can be used to convert an XSL-FO document into another non-XML format, such as <link label="PDF">PDF</link>.
* <b><link label="XSLT">XSLT</link></b> is a declarative, XML-based document transformation language. An XSLT processor can use an XSLT <i>stylesheet</i> as a guide for the conversion of the data tree represented by one XML document into another tree that can then be <link label="Serialize">serialize</link>d as XML, HTML, plain text, or any other format supported by the processor.
* <b><link label="XQuery">XQuery</link></b> is a W3C language for <link label="Query">query</link>ing, constructing and transforming XML data.
* <b><link label="XPath">XPath</link></b> is a DOM-like node tree <link label="Data model">data model</link> and <link label="Path expression">path expression</link> language for selecting data within XML documents. XSL-FO, XSLT and XQuery all make use of XPath. XPath also includes a useful <link label="Function library">function library</link>. </p>
</section><section depth="2"><title>Pull Parsing</title>
<p><link label="Pull parsing">Pull parsing</link> <ref><external href="http://www.xml.com/pub/a/2005/07/06/tr.html">Push, Pull, Next!</external> by Bob DuCharme, at XML.com</ref> treats the document as a series of items which are read in sequence using the Iterator design pattern. This allows for writing of <link label="Recursive descent parser">recursive-descent parsers</link> in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods.  Examples of pull parsers include <link label="StAX">StAX</link> in the <link label="Java (programming language)">Java</link> programming language, SimpleXML in PHP and System.Xml.XmlReader in .NET. </p>

<p>A pull parser creates an iterator that sequentially visits the various elements, attributes, and data in an XML document. Code which uses this 'iterator' can test the current item (to tell, for example, whether it is a start or end element, or text), and inspect its attributes (local name, namespace, values of XML attributes, value of text, etc.), and can also move the iterator to the 'next' item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements which are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code.</p>
</section><section depth="2"><title>Data binding</title>
<p>Another form of XML Processing API is <link label="XML data binding">data binding</link>, where XML data is made available as a custom, strongly typed programming language data structure, in contrast to the interface-oriented DOM. Example data binding systems include the <link label="Java (programming language)">Java</link> <link label="Architecture">Architecture</link> for XML Binding (<link label="JAXB">JAXB</link>)<ref>http://java.sun.com/xml/jaxb/</ref>.</p>
</section><section depth="2"><title>Non-extractive XML Processing API</title>  
<p>Non-extractive XML Processing API is a new and emerging category of parsers that aim to overcome the fundamental limitations of DOM and SAX. The most representative is <link label="VTD-XML">VTD-XML</link>, which abolishes the object-oriented modeling of XML hierarchy and instead uses 64-bit Virtual Token Descriptors (encoding offsets, lengths, depths, and types) of XML tokens. VTD-XML's approach enables a number of interesting features/enhancements, such as high performance, low memory usage <ref>http://www.javaworld.com/javaworld/jw-03-2006/jw-0327-simplify.html</ref>, ASIC implementation <ref>http://www.ximpleware.com/wp_SUN.pdf</ref>, incremental update <ref>http://www.javaworld.com/javaworld/jw-07-2006/jw-0724-vtdxml.html</ref>, and native XML indexing <ref><external href="http://vtd-xml.sf.net/persistence.html">VTD+XML format spec</external></ref> <ref><external href="http://xml.sys-con.com/read/453082.htm">Index XML documents with VTD-XML</external></ref>.</p>
</section><section depth="2"><title>Specific XML applications and editors</title>
<p>The <link label="Native and foreign format">native file format</link> of <link label="OpenOffice.org">OpenOffice.org</link>, <link label="AbiWord">AbiWord</link>, and <link label="Apple Computer">Apple</link>'s <link label="IWork">iWork</link> applications is XML. Some parts of <link label="Microsoft Office">Microsoft Office</link> 2007 are also able to edit XML files with a user-supplied schema (but not a DTD), and Microsoft has released a file format compatibility kit for Office 2003 that allows previous versions of Office to save in the new XML based format. There are dozens of other <link label="XML editor">XML editor</link>s available.</p>
</section></section><section depth="1"><title>History</title>
<p>The versatility of <link label="SGML">SGML</link> for dynamic information display was understood by early digital media publishers in the late 1980s prior to the rise of the Internet.&lt;ref name=OED&gt; <template head="cite web"><field name="title">A conversation with Tim Bray: Searching for ways to tame the world’s vast stores of information </field><field name="url">http://www.acmqueue.com/modules.php?name=Content&amp;pa=showpage&amp;pid=282 </field><field name="first">Tim </field><field name="last">Bray </field><field name="year">February 2005 </field><field name="publisher">Association for Computing Machinery's &quot;Queue site&quot; </field><field name="accessmonthday">April 16 </field><field name="accessyear">2006 </field></template>&lt;/ref&gt;&lt;ref name=multimedia&gt; <template head="cite book"><field name="title">Interactive multimedia </field><field name="chapter">Publishers, multimedia, and interactivity </field><field name="publisher"> Cobb Group </field><field name="id">ISBN 1-55615-124-1 </field><field name="year">1988</field></template>&lt;/ref&gt; By the mid-1990s some practitioners of SGML had gained experience with the then-new <link label="World Wide Web">World Wide Web</link>, and believed that SGML offered solutions to some of the problems the Web was likely to face as it grew.  <link label="Dan Connolly">Dan Connolly</link> added SGML to the list of W3C's activities when he joined the staff in 1995; work began in mid-1996 when <link label="Jon Bosak">Jon Bosak</link> developed a charter and recruited collaborators. Bosak was well connected in the small community of people who had experience both in SGML and the Web.  He received support in his efforts from <link label="Microsoft">Microsoft</link>.</p>

<p>XML was compiled by a <link label="Working group">working group</link> of eleven members,<ref>The working group was originally called the &quot;Editorial Review Board.&quot; The original members and seven who were added before the first edition was complete, are listed at the end of the first edition of the XML Recommendation, at http://www.w3.org/TR/1998/REC-xml-19980210.</ref> supported by an (approximately) 150-member Interest Group.  Technical debate took place on the Interest Group mailing list and issues were resolved by consensus or, when that failed, majority vote of the Working Group. A record of design decisions and their rationales was compiled by <link label="Michael Sperberg-McQueen">Michael Sperberg-McQueen</link> on December 4th 1997.<ref><external href="http://www.w3.org/XML/9712-reports.html">Reports From the W3C SGML ERB to the SGML WG And from the W3C XML ERB to the XML SIG</external></ref> <link label="James Clark (XML expert)">James Clark</link> served as Technical Lead of the Working Group, notably contributing the empty-element &quot;&lt;empty/&gt;&quot; syntax and the name &quot;XML&quot;. Other names that had been put forward for consideration included &quot;MAGMA&quot; (Minimal Architecture for Generalized Markup Applications), &quot;SLIM&quot; (Structured Language for Internet Markup) and &quot;MGML&quot; (Minimal Generalized Markup Language). The co-editors of the specification were originally <link label="Tim Bray">Tim Bray</link> and <link label="Michael Sperberg-McQueen">Michael Sperberg-McQueen</link>.  Halfway through the project Bray accepted a consulting engagement with <link label="Netscape Communications Corporation">Netscape</link>, provoking vociferous protests from Microsoft.  Bray was temporarily asked to resign the editorship. This led to intense dispute in the Working Group, eventually solved by the appointment of Microsoft's <link label="Jean Paoli">Jean Paoli</link> as a third co-editor.</p>

<p>The XML Working Group never met face-to-face; the design was accomplished using a combination of email and weekly teleconferences.  The major design decisions were reached in twenty weeks of intense work between July and November of 1996, when the first Working Draft of an XML specification was published.<ref>http://www.w3.org/TR/WD-xml-961114.html</ref>  Further design work continued through <link label="1997">1997</link>, and XML 1.0 became a <link label="W3C">W3C</link> Recommendation on <link label="February 10">February 10</link>, <link label="1998">1998</link>.</p>

<p>XML 1.0 achieved the Working Group's goals of Internet usability, general-purpose usability, SGML compatibility, facilitation of easy development of processing software, minimization of optional features, legibility, formality, conciseness, and ease of authoring.
Like its antecedent SGML, XML allows for some redundant syntactic constructs and includes repetition of element identifiers. In these respects, terseness was not considered essential in its structure.</p>
<section depth="2"><title>Sources</title>
<p>XML is a profile of an ISO standard <link label="SGML">SGML</link>, and most of XML comes from SGML unchanged. From SGML comes the separation of logical and physical structures (elements and entities), the availability of grammar-based validation (DTDs), the separation of data and metadata (elements and attributes), mixed content, the separation of processing from representation (processing instructions), and the default angle-bracket syntax. Removed were the SGML Declaration (XML has a fixed delimiter set and adopts <link label="Unicode">Unicode</link> as the document <link label="Character encoding">character set</link>). </p>

<p>Other sources of technology for XML were the <link label="Text Encoding Initiative">Text Encoding Initiative</link> (TEI), which defined a profile of SGML for use as a 'transfer syntax'; <link label="HTML">HTML</link>, in which elements were synchronous with their resource, the separation of document character set from resource encoding, the xml:lang attribute, and the <link label="HTTP">HTTP</link> notion that metadata accompanied the resource rather than being needed at the declaration of a link; and the Extended Reference Concrete Syntax (ERCS), from which XML 1.0's naming rules were taken, and which had introduced hexadecimal numeric character references and the concept of references to make available all Unicode characters. </p>

<p>Ideas that developed during discussion which were novel in XML, were the algorithm for encoding detection and the encoding header, the processing instruction target, the xml:space attribute, and the new close delimiter for empty-element tags.</p>
</section><section depth="2"><title>Versions</title>

<p>There are two current versions of XML. The first, <i>XML 1.0</i>, was initially defined in <link label="1998">1998</link>. It has undergone minor revisions since then, without being given a new version number, and is currently in its fourth edition, as published on <link label="August 16">August 16</link>, <link label="2006">2006</link>. It is widely implemented and still recommended for general use. The second, <i>XML 1.1</i>, was initially published on <link label="February 4">February 4</link>, <link label="2004">2004</link>, the same day as  XML 1.0 Third Edition, and is currently in its second edition, as published on <link label="August 16">August 16</link>, <link label="2006">2006</link>. It contains features &amp;mdash; some contentious &amp;mdash; that are intended to make XML easier to use in certain cases<ref><template head="cite web"><field name="url">http://www.w3.org/TR/xml11/#sec-xml11 </field><field name="title">Extensible Markup Language (XML) 1.1 (Second Edition) - Rationale and list of changes for XML 1.1 </field><field name="accessdate">2006-12-21 </field><field name="publisher">W3C</field></template></ref> - mainly enabling the use of line-ending characters used on <link label="EBCDIC">EBCDIC</link> platforms, and the use of scripts and characters absent from Unicode 2.0. XML 1.1 is not very widely implemented and is recommended for use only by those who need its unique features. <ref><template head="cite book"><field name="last"> Harold
  </field><field name="first"> Elliotte Rusty
  </field><field name="title"> Effective XML
  </field><field name="publisher"> Addison-Wesley
  </field><field name="date"> 2004
  </field><field name="pages"> 10-19
  </field><field name="url"> http://www.cafeconleche.org/books/effectivexml/
  </field><field name="isbn"> 0321150406</field></template></ref></p>

<p>XML 1.0 and XML 1.1 differ in the requirements of characters used for element and attribute names: XML 1.0 only allows characters which are defined in Unicode 2.0, which includes most world scripts, but excludes those which were added in later Unicode versions. Among the excluded scripts are <link label="Mongolian language">Mongolian</link>, <link label="Cambodian language">Cambodian</link>, <link label="Amharic">Amharic</link>, <link label="Burmese language">Burmese</link>, and others.</p>

<p>Almost any Unicode character can be used in the character data and attribute values of an XML 1.1 document, even if the character is not defined, aside from having a code point, in the current version of Unicode. The approach in XML 1.1 is that only certain characters are forbidden, and everything else is allowed, whereas in XML 1.0, only certain characters are explicitly allowed, thus XML 1.0 cannot accommodate the addition of characters in future versions of Unicode.</p>

<p>In character data and attribute values, XML 1.1 allows the use of more <link label="Control character">control character</link>s than XML 1.0, but, for &quot;robustness&quot;, most of the control characters introduced in XML 1.1 must be expressed as numeric character references. Among the supported control characters in XML 1.1 are two line break codes that must be treated as whitespace. Whitespace characters are the only control codes that can be written directly.</p>

<p>There are also discussions on an XML 2.0, although it remains to be seen <template head="vague"></template> if such will ever come about. <external href="http://www.textuality.com/xml/xmlSW.html">XML-SW</external> (SW for <link label="Skunk works">skunk works</link>), written by one of the original developers of XML, contains some proposals for what an XML 2.0 might look like: elimination of DTDs from syntax, integration of <link label="Namespace (computer science)#XML">namespace</link>s, <link label="XML Base">XML Base</link> and <link label="XML Information Set">XML Information Set</link> (<i>infoset</i>) into the base standard.</p>

<p>The World Wide Web Consortium also has an XML Binary Characterization Working Group doing preliminary research into use cases and properties for a binary encoding of the XML infoset.  The working group is not chartered to produce any official standards.  Since XML is by definition text-based, ITU-T and ISO are using the name <i><link label="Fast Infoset">Fast Infoset</link><external href="http://asn1.elibel.tm.fr/xml/finf.htm">http://asn1.elibel.tm.fr/xml/finf.htm</external></i> for their own binary infoset to avoid confusion (see ITU-T Rec. X.891 | ISO/IEC 24824-1).</p>
</section><section depth="2"><title>Patent claims</title>
<p>In October 2005 the small company <link label="Scientigo">Scientigo</link> publicly asserted that two of its patents, <template head="US patent"><field>5842213</field></template> and <template head="US patent"><field>6393426</field></template>, apply to the use of XML. The patents cover the &quot;modeling, storage and transfer [of data] in a particular <i>non-hierarchical</i>, non-integrated neutral form&quot;, according to their applications, which were filed in 1997 and 1999. Scientigo CEO <link label="Doyal Bryant">Doyal Bryant</link> expressed a desire to &quot;monetize&quot; the patents but stated that the company was &quot;not interested in having us against the world.&quot; He said that Scientigo was discussing the patents with several large corporations.<ref>http://news.com.com/Small+company+makes+big+claims+on+XML+patents/2100-1014_3-5905949.html</ref></p>

<p>XML users and independent experts responded to Scientigo's claims with widespread skepticism and criticism. Some derided the company as a <link label="Patent troll">patent troll</link>. <link label="Tim Bray">Tim Bray</link> described any claims that the patents covered XML as &quot;ridiculous on the face of it&quot;.<ref>http://blogs.zdnet.com/BTL/?p=2052</ref></p>

<p>Because there exists a large amount of <link label="Prior art">prior art</link> relating to XML, including <link label="SGML">SGML</link>, some legal experts believed it would be difficult for Scientigo to enforce its patents through litigation.<template head="Fact"><field name="date">February 2007</field></template></p>
</section></section><section depth="1"><title>Critique of XML</title><p>&lt;!--
########################
A NOTE TO CONTRIBUTORS: 
########################
Debates are described, represented, and characterized, but not engaged in. Let the facts speak for themselves. Concise and referenced additions to this section are welcomed, but contributions inconsistent with <link label="WP:NPOV">WP:NPOV</link> and <link label="WP:ATT">WP:ATT</link> are subject to immediate removal. Thanks.
--&gt;
Commentators have offered various critiques of XML, suggesting circumstances where XML provides both advantages and potential disadvantages.&lt;ref name=&quot;CriticSeeAlso&quot;&gt;(See e.g., 
<external href="http://www.w3.org/TR/NOTE-xml-ql/">XML-QL Proposal discussing XML benefits</external>,
<external href="http://www.25hoursaday.com/weblog/PermaLink.aspx?guid=dada27bf-2af0-400d-94c9-5575546f5664">When to use XML</external>,
<external href="http://c2.com/cgi/wiki?XmlSucks">&quot;XML Sucks&quot; on c2.com</external>, <external href="http://www.xml.com/pub/a/2001/05/02/champion.html">Daring to Do Less with XML</external>)&lt;/ref&gt;</p>

<template head="cquote"><field>XML is really just data dressed up as a hooker.</field><field></field><field></field><field><link label="Dave Thomas (programmer)">Dave Thomas</link><ref>Neal Ford, Language Oriented Programming, The Server Side's Java Symposium, 2007</ref></field></template>
<section depth="2"><title>Advantages of XML</title>
<p>* It is text-based.
* It supports <link label="Unicode">Unicode</link>, allowing almost any information in any written human language to be communicated.
* It can represent common <link label="Computer science">computer science</link> <link label="Data structure">data structure</link>s: <link label="Record (computer science)">record</link>s, <link label="List (computing)">list</link>s and <link label="Tree data structure">tree</link>s.
* Its <link label="Self-documenting">self-documenting</link> format describes <link label="Structure">structure</link> and <link label="Field name">field name</link>s as well as specific values.
* The strict <link label="Syntax">syntax</link> and <link label="Parsing">parsing</link> requirements make the necessary <link label="Parser">parsing algorithms</link> extremely simple, efficient, and consistent.
* XML is heavily used as a format for <link label="Document storage">document storage</link> and processing, both online and offline. 
* It is based on <link label="International standards">international standards</link>.
* It can be updated incrementally.
* It allows validation using schema languages such as <link label="XSD">XSD</link> and <link label="Schematron">Schematron</link>, which makes effective unit-testing, firewalls, acceptance testing, contractual specification and software construction easier.
* The <link label="Hierarchy">hierarchical</link> structure is suitable for most (but not all) types of documents.
* It manifests as <link label="Plain text">plain text</link> files, which are less restrictive than other proprietary document formats.
* It is platform-independent, thus relatively immune to changes in technology.
* Forward and backward compatibility are relatively easy to maintain despite changes in DTD or Schema.
* Its predecessor, SGML, has been in use since <link label="1986">1986</link>, so there is extensive experience and software available.
* An element fragment of a well-formed XML document is also a well-formed XML document.</p>
</section><section depth="2"><title>Disadvantages of XML</title>
<p>* XML syntax is redundant or large relative to binary representations of similar data.&lt;ref name=&quot;Elliotte001&quot;&gt;
<template head="cite book"><field name="last"> Harold
</field><field name="first"> Elliotte Rusty
</field><field name="title"> Processing XML with Java(tm): a guide to SAX, DOM, JDOM, JAXP, and TrAX
</field><field name="publisher"> Addison-Wesley
</field><field name="year"> 2002
</field><field name="id"> 0201771861
</field><field name="ref"> Reference-Rusty-2002-a
</field></template>XML documents are too verbose compared with binary equivalents.&lt;/ref&gt;
* The redundancy may affect application efficiency through higher storage, transmission and processing costs.&lt;ref name=&quot;Elliotte000&quot;&gt;
<template head="cite book"><field name="last"> Harold
</field><field name="first"> Elliotte Rusty
</field><field name="title"> XML in a Nutshell: A Desktop Quick Reference
</field><field name="publisher"> O'Reilly
</field><field name="year"> 2002
</field><field name="id"> 0596002920
</field><field name="ref"> Reference-Rusty-2002-b
</field></template> XML documents are very verbose and searching is inefficient for
high-performance largescale database applications.&lt;/ref&gt;&lt;ref name=&quot;However000&quot;&gt;However, the <link label="Binary XML">Binary XML</link> effort strives to alleviate these problems by using a binary representation for the XML document. For example, the <link label="Java (programming language)">Java</link> reference implementation of the <link label="Fast Infoset">Fast Infoset</link> standard parsing speed is better by a factor 10  compared to <link label="Java (programming language)">Java</link> <link label="Xerces">Xerces</link>, and by a factor 4 compared to the <external href="http://piccolo.sourceforge.net/">Piccolo driver</external>, one of the fastest Java-based XML parser [https://fi.dev.java.net/reports/parsing/report.html].&lt;/ref&gt;
* XML syntax is verbose, especially for human readers, relative to other alternative 'text-based' data transmission formats.&lt;ref name=&quot;Bierman000&quot;&gt;
<template head="cite book"><field name="last"> Bierman
</field><field name="first"> Gavin 
</field><field name="title"> Database Programming Languages: 10th international symposium, DBPL 2005 Trondheim, Norway
</field><field name="publisher"> Springer
</field><field name="year"> 2005
</field><field name="id"> 3540309519
</field></template>XML syntax is too verbose for human readers in for certain applications. 
Proposes a dual syntax for human readability.&lt;/ref&gt;&lt;ref name=&quot;VerbRebut000&quot;&gt;Although many purportedly 
&quot;less verbose&quot; text formats actually cite XML as 
both inspiration and prior art. 
See e.g., http://yaml.org/spec/current.html,
http://innig.net/software/sweetxml/index.html,
http://www.json.org/xml.html.&lt;/ref&gt;
* The <link label="Hierarchical model">hierarchical model</link> for representation is limited in comparison to an <link label="Object oriented">object oriented</link> <link label="Graph (mathematics)">graph</link>.&lt;ref name=&quot;TreeLimit000&quot;&gt;A hierachical model only gives a fixed, monolithic view of the <link label="Tree structure">tree structure</link>. For example, either actors under movies, or movies under actors, but not both.&lt;/ref&gt;&lt;ref name=&quot;Lim000&quot;&gt;
<template head="cite book"><field name="last"> Lim
</field><field name="first"> Ee-Peng 
</field><field name="title"> Digital Libraries: People, Knowledge, and Technology
</field><field name="publisher"> Springer
</field><field name="year"> 2002
</field><field name="id"> 3540002618
</field></template>Discusses some of the limitation with fixed hierarchy. Proceedings of the 5th International Conference on Asian Digital Libraries, ICADL 2002, held in Singapore in December 2002. &lt;/ref&gt;
* Expressing overlapping (non-hierarchical) node relationships requires extra effort.&lt;ref name=&quot;Searle000&quot;&gt;<template head="cite book"><field name="last"> Searle
</field><field name="first"> Leroy F.
</field><field name="title"> Voice, text, hypertext: emerging practices in textual studies
</field><field name="publisher"> University of Washington Press
</field><field name="year"> 2004
</field><field name="id"> 0295983051
</field></template> Proposes an alternative system for encoding overlapping elements. &lt;/ref&gt;
* XML namespaces are problematic to use and namespace support can be difficult to correctly implement in an XML parser.&lt;ref name=&quot;Names000&quot;&gt;(See e.g., http://www-128.ibm.com/developerworks/library/x-abolns.html )&lt;/ref&gt;
* XML is commonly depicted as &quot;<link label="Self-documenting">self-documenting</link>&quot; but this depiction ignores critical ambiguities.&lt;ref name=&quot;selfdesc000&quot;&gt;<template head="cite web"><field name="title"> The Myth of Self-Describing XML
</field><field name="url"> http://www.oceaninformatics.biz/publications/e2.pdf
</field><field name="accessdate"> 2007-05-12
</field></template>&lt;/ref&gt;<ref>(See e.g., <link label="Use–mention distinction">Use–mention distinction</link>, <link label="Naming collision">Naming collision</link>, <link label="Polysemy">Polysemy</link>)</ref>
* The distinction between content and attributes in XML seems unnatural to some and makes designing XML data structures harder.&lt;ref name=&quot;XMLSuck8&quot;&gt;<template head="cite web"><field name="title"> Does XML Suck?
</field><field name="url"> http://xmlsucks.org/but_you_have_to_use_it_anyway/does-xml-suck.html
</field><field name="accessdate"> 2007-12-15
</field></template>(See &quot;8. Complexity: Attributes and Content&quot;)&lt;/ref&gt;
* Linking between XML documents requires the use of <link label="XLink">XLink</link>, which is complex compared to <link label="Hyperlinks">hyperlinks</link>&lt;ref name=&quot;XMLSuck15&quot;&gt;<template head="cite web"><field name="title"> Does XML Suck?
</field><field name="url"> http://xmlsucks.org/but_you_have_to_use_it_anyway/does-xml-suck.html
</field><field name="accessdate"> 2007-12-15
</field></template>(See &quot;15. Linking Between XML Documents&quot;)&lt;/ref&gt;
* It's hard to find an XML parser that is complete, correct, and efficient.&lt;ref name=&quot;XMLSuck9&quot;&gt;<template head="cite web"><field name="title"> Does XML Suck?
</field><field name="url"> http://xmlsucks.org/but_you_have_to_use_it_anyway/does-xml-suck.html
</field><field name="accessdate"> 2007-12-15
</field></template>(See &quot;9. Complexity: Parsing&quot;)&lt;/ref&gt;</p>
</section></section><section depth="1"><title>See also</title>
<template head="Multicol"></template>
<p>*<link label="Ajax (programming)">Ajax</link>
*<link label="APML">APML</link>
*<link label="ASN.1">ASN.1</link>
*<link label="AsXML">asXML</link>
*<link label="CDATA#CDATA sections in XML">CDATA section</link>, the mechanism for including non-markup text in XML
*<link label="Comparison of layout engines (XML)">Comparison of layout engines (XML)</link>
*<link label="DITA">DITA</link>
*<link label="DocBook">DocBook</link>
*<link label="EbXML">ebXML</link>
*<link label="Binary XML">Binary XML</link>
*<link label="Extensible Binary Meta Language">Extensible Binary Meta Language</link>
*<link label="Extensible Metadata Platform">Extensible Metadata Platform</link> (XMP), used in graphics applications
*<link label="General purpose markup language">General purpose markup language</link>
*<link label="JSON">JSON</link>
*<link label="OGDL">OGDL</link>
*<link label="List of XML markup languages">List of XML markup languages</link>
*<link label="S-expression">S-expression</link>
*<link label="SAML">SAML</link>
*<link label="Serialization">Serialization</link>
*<link label="Single source publishing">Single source publishing</link>
*<link label="Structured data interchange">Structured data interchange</link>
*<link label="SOAP">SOAP</link>
*<link label="Universal Business Language">Universal Business Language</link>
*<link label="XBRL">XBRL</link>
*<link label="WBXML">WBXML</link>
*<link label="XML Data Binding">XML Data Binding</link>
*<link label="XML/EDIFACT">XML/EDIFACT</link>
*<link label="XML editor">XML editor</link>
*<link label="XML Information Set">XML Information Set</link>
*XML processing <link label="Application programming interface">API</link>s: 
**<link label="Document Object Model">DOM</link>, 
**<link label="Simple API for XML">SAX</link>, 
**<link label="StAX">StAX</link>, 
**<link label="E4X">E4X</link>
**<link label="VTD-XML">VTD-XML</link>
**<link label="Sedna (database)">Sedna</link>
<template head="Multicol-break"></template>
*<link label="XML query language">XML query language</link>
*<link label="XML schema">XML schema</link> languages: 
**<link label="Document Type Definition">DTD</link>, 
**<link label="RELAX NG">RELAX NG</link>, 
**<link label="Schematron">Schematron</link>,
**<link label="Document Schema Definition Languages">DSDL</link>
**<link label="XFA">XML Forms Architecture</link>
*<link label="XML Certification Program">XML Certification Program</link>
*<link label="XRI">XRI</link>, <link label="XDI">XDI</link>
*<link label="YAML">YAML</link>
&lt;!-- --&gt;
* W3C XML standards:
** <link label="XForms">XForms</link>
** <link label="XHTML">XHTML</link>
** <link label="XLink">XLink</link>
** <link label="XML Base">XML Base</link>
** <link label="XML Encryption">XML Encryption</link>
** <link label="XML Information Set">XML-infoset</link>
** <link label="Document Object Model">DOM</link> (the XML processing <i>reference model</i>).
** <link label="XQuery">XQuery</link>
** <link label="XML Schema">XML Schema</link>
** <link label="XML Signature">XML Signature</link>
** <link label="XPath">XPath</link>
** <link label="XPointer">XPointer</link>
** XML Protocol: <link label="XMLP">XMLP</link> and <link label="SOAP">SOAP</link>.
** <link label="WSDL">WSDL</link>, <link label="Web service">Web service</link>
** <link label="Extensible Stylesheet Language">XSL and XSLT</link>
** <link label="LGML">LGML</link> Linguistics Markup Language 
<template head="Multicol-end"></template></p>
</section><section depth="1"><title>Notes and references</title>
<template head="Reflist"></template>
<p>What Is XML and Why Should I Care? - very good summary on the topic<external href="http://www.topxml.com/xml/articles/whatisxml/">http://www.topxml.com/xml/articles/whatisxml/</external></p>
</section><section depth="1"><title>External links</title>
<template head="Wikibooks"></template>
<section depth="2"><title>Specifications</title>
<p>*<external href="http://www.w3.org/XML/">W3C XML homepage</external>
*<external href="http://www.w3.org/TR/REC-xml">The XML 1.0 specification</external>
*<external href="http://www.w3.org/TR/xml11">The XML 1.1 specification</external></p>
</section><section depth="2"><title>Parsers</title>
<p>*<link label="Expat (XML)">Expat</link> free stream-oriented XML 1.0 parser library, written in C.
*<link label="Libxml2">Libxml2</link> free XML C parser and toolkit.
*<external href="http://www.allegrosoft.com/romxml.html">RomXML</external> Embedded XML commercial toolkit written in ANSI-C.
*<external href="http://www.philo.de/xml/">XDOM</external> open-source XML parser (and DOM and XPath implementation) in Delphi/Kylix.
*<template head="dmoz"><field>Computers/Data_Formats/Markup_Languages/XML</field><field>XML resources</field></template></p>
</section><section depth="2"><title>Conversion Tools</title>
<p>*<external href="http://www.altova.com">Altova</external>
*<external href="http://www.stylusstudio.com">Stylusstudio</external>
*<external href="http://www.navicat.com">Navicat</external>
*<external href="http://architag.com/xray/">XRay XML Editor</external></p>
</section><section depth="2"><title>Sources</title> 

<p>*<external href="http://www.sgmlsource.com/history/AnnexA.htm">Introduction to Generalized Markup</external> by <link label="Charles Goldfarb">Charles Goldfarb</link>
*Annex A of ISO 8879:1986 (SGML)
*<external href="http://www.mind-to-mind.com/library/papers/multilingual/multilingual-www.html">The Multilingual WWW</external> by Gavin Nicol
*<external href="http://xml.ascc.net/en/utf-8/ercsretro.html">Retrospective on Extended Reference Concrete Syntax</external> by <link label="Rick Jelliffe">Rick Jelliffe</link>
*<external href="http://www.xml.com/pub/a/w3j/s3.bosak.html">XML, Java and the Future of the Web</external> by <link label="Jon Bosak">Jon Bosak</link></p>
</section><section depth="2"><title>Retrospectives</title>

<p>*<external href="http://www-128.ibm.com/developerworks/library/x-think38.html">Thinking XML: The XML decade</external> by Uche Ogbuji
*<external href="http://drmacros-xml-rants.blogspot.com/2006/11/xml-ten-year-aniversary.html">XML: Ten year anniversary</external> by Elliot Kimber
*<external href="http://2006.xmlconference.org/proceedings/162/presentation.html">Closing Keynote, XML 2006</external> by <link label="Jon Bosak">Jon Bosak</link>
*<external href="http://www.oreillynet.com/xml/blog/2003/02/five_years_later_xml.html">Five years later, XML...</external> by Simon St. Laurent</p>
</section><section depth="2"><title>Papers</title>

<p>*<template head="cite journal"><field name="id"> <template head="SSRN"><field>900616</field></template> </field><field name="author">Lawrence A. Cunningham</field><field name="title">Language, Deals and Standards: The Future of XML Contracts</field><field name="journal">Washington University Law Review</field><field name="year">2005 </field></template></p>

<template head="W3C Standards"></template>

<p>







</p>

<p><link label="Af:XML">af:XML</link>
<link label="Ar:لغة الترميز القابلة للامتداد">ar:لغة الترميز القابلة للامتداد</link>
<link label="Bn:এক্সটেনসিভ মার্কআপ ল্যাংগুয়েজ">bn:এক্সটেনসিভ মার্কআপ ল্যাংগুয়েজ</link>
<link label="Bs:XML">bs:XML</link>
<link label="Bg:XML">bg:XML</link>
<link label="Ca:Extensible Markup Language">ca:Extensible Markup Language</link>
<link label="Cs:Extensible Markup Language">cs:Extensible Markup Language</link>
<link label="Da:Extensible Markup Language">da:Extensible Markup Language</link>
<link label="De:Extensible Markup Language">de:Extensible Markup Language</link>
<link label="Et:XML">et:XML</link>
<link label="Es:XML">es:XML</link>
<link label="Eo:XML">eo:XML</link>
<link label="Eu:XML">eu:XML</link>
<link label="Fa:اکس‌ام‌ال">fa:اکس‌ام‌ال</link>
<link label="Fr:Extensible Markup Language">fr:Extensible Markup Language</link>
<link label="Gl:XML">gl:XML</link>
<link label="Ko:XML">ko:XML</link>
<link label="Hi:क्षमल">hi:क्षमल</link>
<link label="Hr:XML">hr:XML</link>
<link label="Id:Extensible markup language">id:Extensible markup language</link>
<link label="Ia:XML">ia:XML</link>
<link label="Is:XML">is:XML</link>
<link label="It:XML">it:XML</link>
<link label="He:XML">he:XML</link>
<link label="Lv:Valoda XML">lv:Valoda XML</link>
<link label="Lt:XML">lt:XML</link>
<link label="Hu:XML">hu:XML</link>
<link label="Nl:Extensible Markup Language">nl:Extensible Markup Language</link>
<link label="Ja:Extensible Markup Language">ja:Extensible Markup Language</link>
<link label="No:XML">no:XML</link>
<link label="Nn:XML">nn:XML</link>
<link label="Pl:XML">pl:XML</link>
<link label="Pt:XML">pt:XML</link>
<link label="Ro:XML">ro:XML</link>
<link label="Ru:XML">ru:XML</link>
<link label="Sq:XML">sq:XML</link>
<link label="Simple:XML">simple:XML</link>
<link label="Sk:XML">sk:XML</link>
<link label="Sl:XML">sl:XML</link>
<link label="Sr:XML">sr:XML</link>
<link label="Fi:XML">fi:XML</link>
<link label="Sv:XML">sv:XML</link>
<link label="Th:เอกซ์เอ็มแอล">th:เอกซ์เอ็มแอล</link>
<link label="Vi:XML">vi:XML</link>
<link label="Tg:XML">tg:XML</link>
<link label="Tr:Genişletilebilir işaretleme dili">tr:Genişletilebilir işaretleme dili</link>
<link label="Uk:XML">uk:XML</link>
<link label="Bat-smg:XML">bat-smg:XML</link>
<link label="Zh:可扩展置标语言">zh:可扩展置标语言</link></p></section></section></text><catlinks><catlink href="Category:XML"/><catlink href="Category:Markup languages"/><catlink href="Category:W3C standards"/><catlink href="Category:Technical communication"/><catlink href="Category:Bibliography file formats"/><catlink href="Category:Computer file formats"/><catlink href="Category:Open formats"/><catlink href="Category:Data modeling languages"/><catlink href="Category:Data serialization formats"/></catlinks>
    </revision>
  </page>
