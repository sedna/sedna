
; File:  gen_calc_altern.scm
; Copyright (C) 2004 The Institute for System Programming of the Russian Academy of Sciences (ISP RAS)

#>
// only for MSDEV 6.0
#if (_MSC_VER == 1200) && (WINVER < 0x0500)
long _ftol( double ); //defined by VC6 C libs
long _ftol2( double dblSource ) { return _ftol(dblSource ); } 
#endif
<#


(define port (current-output-port))
(define output-to-file #t)

(define (out s)
  (display s port))

(define (nl) (newline port))


(define arithmetic-types (list (string->symbol "xs_integer")
                               (string->symbol "xs_decimal")
                               (string->symbol "xs_float")
                               (string->symbol "xs_double")
                               (string->symbol "xdt_untypedAtomic")))

(define (make-pair lst1 lst2 word)
  (append (map (lambda (x) (list word x (car lst2))) lst1)
          (if (null? (cdr lst2))
              '()
              (make-pair lst1 (cdr lst2) word))))

(define pair-types `((op_boolean xs_boolean xs_boolean)
                     (fn_compare xs_string xs_string)
                     ,@(make-pair arithmetic-types arithmetic-types 'op_numeric)))

(define comp-modes  '((EQ equal)
                      (NE not_equal)
                      (LT less_than)
                      (LE less_equal)
                      (GT greater_than)
                      (GE greater_equal)))

(define arithm-modes '((Add add)
                       (Substract subtract)
                       (Multiply multiply)
                       (Divide divide)
                       (IntegerDivide integer_divide)
                       (Mod mod)))

(define (generate-comp-ops modes types)
  (let loop1 ((outer modes))
    (if (not (null? outer))
        (begin 
          (let loop2 ((inner types))
            (if (not (null? inner))
                (begin
                  (generate-comp-op (car outer) (car inner))
                  (loop2 (cdr inner)))))
          (loop1 (cdr outer))))))

(define (generate-arithm-ops modes types)
  (let loop1 ((outer modes))
    (if (not (null? outer))
        (begin 
          (let loop2 ((inner types))
            (if (not (null? inner))
                (begin
                  (generate-arithm-op (car outer) (car inner))
                  (loop2 (cdr inner)))))
          (loop1 (cdr outer))))))

(define (generate-comp-op mode type)
  (out "    if (op == \"BinaryVal")
  (out (symbol->string (car mode)))
  (out "_")
  (out (symbol->string (cadr type)))
  (out "_")
  (out (symbol->string (caddr type)))
  (out "\")")(nl)
  (out "    {")(nl)
  (out "        check_consistence_of_binary_calc_op(lst);")(nl)
  (out "        return new BinaryOp(make_calc_op(arr, lst->at(1).internal.list),")(nl)
  (out "                            make_calc_op(arr, lst->at(2).internal.list),")(nl)
  (out "                            ")
  (out (symbol->string (car type)))
  (out "_")
  (out (symbol->string (cadr mode)))
  (if (not (or (eq? (cadr type) 'xs_boolean) (eq? (cadr type) 'xs_string)))
      (begin (out "_")
             (out (symbol->string (cadr type)))))
  (if (not (or (eq? (caddr type) 'xs_boolean) (eq? (caddr type) 'xs_string)))
      (begin (out "_")
             (out (symbol->string (caddr type)))))
  (out ");")(nl)
  (out "    }")(nl))


(define (generate-arithm-op mode type)
  (out "    if (op == \"BinaryOp")
  (out (symbol->string (car mode)))
  (out "_")
  (out (symbol->string (cadr type)))
  (out "_")
  (out (symbol->string (caddr type)))
  (out "\")")(nl)
  (out "    {")(nl)
  (out "        check_consistence_of_binary_calc_op(lst);")(nl)
  (out "        return new BinaryOp(make_calc_op(arr, lst->at(1).internal.list),")(nl)
  (out "                            make_calc_op(arr, lst->at(2).internal.list),")(nl)
  (out "                            ")
  (out "op_numeric")
  (out "_")
  (out (symbol->string (cadr mode)))
  (out "_")
  (out (symbol->string (cadr type)))
  (out "_")
  (out (symbol->string (caddr type)))
  (out ");")(nl)
  (out "    }")(nl))

(define common-ops '((BinaryValEQ value_comp_eq_e)
                     (BinaryValNE value_comp_ne_e)
                     (BinaryValLT value_comp_lt_e)
                     (BinaryValLE value_comp_le_e)
                     (BinaryValGT value_comp_gt_e)
                     (BinaryValGE value_comp_ge_e)
                     (BinaryOpAdd op_numeric_add_e)
                     (BinaryOpSubtract op_numeric_subtract_e)
                     (BinaryOpMultiply op_numeric_multiply_e)
                     (BinaryOpDivide op_numeric_divide_e)
                     (BinaryOpIntegerDivide op_numeric_integer_divide_e)
                     (BinaryOpMod op_numeric_mod_e)))

(define (generate-common-ops common-ops)
  (let loop ((ops common-ops))
    (if (not (null? ops))
        (let ((op (car ops)))
          (out "    if (op == \"")
          (out (symbol->string (car op)))
          (out "\")")(nl)
          (out "    {")(nl)
          (out "        check_consistence_of_binary_calc_op(lst);")(nl)
          (out "        return new BinaryOp(make_calc_op(arr, lst->at(1).internal.list),")(nl)
          (out "                            make_calc_op(arr, lst->at(2).internal.list),")(nl)
          (out "                            ")
          (out (symbol->string (cadr op)))
          (out ");")(nl)
          (out "    }")(nl)
          (loop (cdr ops)))
        )))

(define unary-ops '((UnaryOpPlus op_numeric_unary_plus_e)
                    (UnaryOpMinus op_numeric_unary_minus_e)
                    (UnaryOpMinus_xs_integer op_numeric_unary_plus_xs_integer)
                    (UnaryOpMinus_xs_decimal op_numeric_unary_plus_xs_decimal)
                    (UnaryOpMinus_xs_float op_numeric_unary_plus_xs_float)
                    (UnaryOpMinus_xs_double op_numeric_unary_plus_xs_double)
                    (UnaryOpMinus_xdt_untypedAtomic op_numeric_unary_plus_xdt_untypedAtomic)
                    (UnaryOpMinus_xs_integer op_numeric_unary_minus_xs_integer)
                    (UnaryOpMinus_xs_decimal op_numeric_unary_minus_xs_decimal)
                    (UnaryOpMinus_xs_float op_numeric_unary_minus_xs_float)
                    (UnaryOpMinus_xs_double op_numeric_unary_minus_xs_double)
                    (UnaryOpMinus_xdt_untypedAtomic op_numeric_unary_minus_xdt_untypedAtomic)))

(define (generate-unary-ops unary-ops)
  (let loop ((ops unary-ops))
    (if (not (null? ops))
        (let ((op (car ops)))
          (out "    if (op == \"")
          (out (symbol->string (car op)))
          (out "\")")(nl)
          (out "    {")(nl)
          (out "        check_consistence_of_unary_calc_op(lst);")(nl)
          (out "        return new UnaryOp(make_calc_op(arr, lst->at(1).internal.list),")(nl)
          (out "                           ")
          (out (symbol->string (cadr op)))
          (out ");")(nl)
          (out "    }")(nl)
          (loop (cdr ops)))
        )))



;; GENERATE SOURCE FILE
;;
(if output-to-file (set! port (open-output-file "calc_altern.cpp")))
(nl)
(out "// This file was generated. Don't edit it!!!")(nl)
(nl)
(out "#include \"boolean_operations.h\"")(nl)
(out "#include \"numeric_operations.h\"")(nl)
(out "#include \"comparison_operations.h\"")(nl)
(out "#include \"string_operations.h\"")(nl)
(out "#include \"PPCalculate.h\"")(nl)
(out "#include \"scheme_tree.h\"")(nl)
(nl)
(out "using namespace std;")(nl)
(nl)
(out "CalcOp *make_calc_op(arr_of_PPOpIn *arr, scheme_list *lst);")(nl)
(nl)
(out "void check_consistence_of_unary_calc_op(scheme_list *lst)")(nl)
(out "{")(nl)
(out "    if (   lst->size() != 2")(nl)
(out "        || lst->at(1).type != SCM_LIST)")(nl)
(out "    throw USER_EXCEPTION2(SE1004, \"105\");")(nl)
(out "}")(nl)
(nl)
(out "void check_consistence_of_binary_calc_op(scheme_list *lst)")(nl)
(out "{")(nl)
(out "    if (   lst->size() != 3")(nl)
(out "        || lst->at(1).type != SCM_LIST")(nl)
(out "        || lst->at(2).type != SCM_LIST)")(nl)
(out "        throw USER_EXCEPTION2(SE1004, \"105\");")(nl)
(out "}")(nl)
(nl)
(out "CalcOp *clarify_calc_op(arr_of_PPOpIn *arr, const string &op, scheme_list *lst)")(nl)
(out "{")(nl)
(generate-comp-ops comp-modes pair-types)(nl)
(generate-arithm-ops arithm-modes (cddr pair-types))(nl)
(generate-common-ops common-ops)(nl)
(generate-unary-ops unary-ops)(nl)
(out "    throw USER_EXCEPTION2(SE1004, \"106\");")(nl)
(out "}")(nl)
(if output-to-file (close-output-port port))
