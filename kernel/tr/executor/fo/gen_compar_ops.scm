
; File:  gen_compar_ops.scm
; Copyright (C) 2004 The Institute for System Programming of the Russian Academy of Sciences (ISP RAS)

#>
// only for MSDEV 6.0
#if (_MSC_VER == 1200) && (WINVER < 0x0500)
long _ftol( double ); //defined by VC6 C libs
long _ftol2( double dblSource ) { return _ftol(dblSource ); } 
#endif
<#


(define port (current-output-port))
(define output-to-file #t)

(define (out s)
  (display s port))

(define (nl) (newline port))

(define table
  '((value_comp_eq
     (xs_integer        (xs_integer xs_decimal xs_float xs_double) op_numeric_equal_)
     (xs_decimal        (xs_integer xs_decimal xs_float xs_double) op_numeric_equal_)
     (xs_float          (xs_integer xs_decimal xs_float xs_double) op_numeric_equal_)
     (xs_double         (xs_integer xs_decimal xs_float xs_double) op_numeric_equal_)
     (xs_string         (xs_string xs_untypedAtomic) fn_compare_equal)
     (xs_untypedAtomic (xs_string xs_untypedAtomic) fn_compare_equal)
     (xs_yearMonthDuration (xs_yearMonthDuration) xs_dateTime_equal)
     (xs_dayTimeDuration (xs_dayTimeDuration) xs_dateTime_equal)
     (xs_dateTime       (xs_dateTime)   xs_dateTime_equal)
     (xs_date           (xs_date)   xs_dateTime_equal)
     (xs_time           (xs_time)   xs_dateTime_equal)
     (xs_duration       (xs_duration)   xs_dateTime_equal)
     (xs_gYearMonth     (xs_gYearMonth)   xs_dateTime_equal)
     (xs_gYear          (xs_gYear)   xs_dateTime_equal)
     (xs_gMonthDay      (xs_gMonthDay)   xs_dateTime_equal)
     (xs_gDay           (xs_gDay)   xs_dateTime_equal)
     (xs_gMonth         (xs_gMonth)   xs_dateTime_equal)
     (xs_boolean        (xs_boolean)op_boolean_equal))
    
    (value_comp_ne
     (xs_integer        (xs_integer xs_decimal xs_float xs_double) op_numeric_not_equal_)
     (xs_decimal        (xs_integer xs_decimal xs_float xs_double) op_numeric_not_equal_)
     (xs_float          (xs_integer xs_decimal xs_float xs_double) op_numeric_not_equal_)
     (xs_double         (xs_integer xs_decimal xs_float xs_double) op_numeric_not_equal_)
     (xs_string         (xs_string xs_untypedAtomic) fn_compare_not_equal)
     (xs_untypedAtomic (xs_string xs_untypedAtomic) fn_compare_not_equal)
     (xs_yearMonthDuration (xs_yearMonthDuration) xs_dateTime_not_equal)
     (xs_dayTimeDuration (xs_dayTimeDuration) xs_dateTime_not_equal)
     (xs_dateTime       (xs_dateTime)   xs_dateTime_not_equal)
     (xs_date           (xs_date)   xs_dateTime_not_equal)
     (xs_time           (xs_time)   xs_dateTime_not_equal)
     (xs_duration       (xs_duration)   xs_dateTime_not_equal)
     (xs_gYearMonth     (xs_gYearMonth)   xs_dateTime_not_equal)
     (xs_gYear          (xs_gYear)   xs_dateTime_not_equal)
     (xs_gMonthDay      (xs_gMonthDay)   xs_dateTime_not_equal)
     (xs_gDay           (xs_gDay)   xs_dateTime_not_equal)
     (xs_gMonth         (xs_gMonth)   xs_dateTime_not_equal)
     (xs_boolean        (xs_boolean)op_boolean_not_equal))
    
    (value_comp_lt
     (xs_integer        (xs_integer xs_decimal xs_float xs_double) op_numeric_less_than_)
     (xs_decimal        (xs_integer xs_decimal xs_float xs_double) op_numeric_less_than_)
     (xs_float          (xs_integer xs_decimal xs_float xs_double) op_numeric_less_than_)
     (xs_double         (xs_integer xs_decimal xs_float xs_double) op_numeric_less_than_)
     (xs_string         (xs_string xs_untypedAtomic) fn_compare_less_than)
     (xs_untypedAtomic (xs_string xs_untypedAtomic) fn_compare_less_than)
     (xs_yearMonthDuration (xs_yearMonthDuration) xs_dateTime_less_than)
     (xs_dayTimeDuration (xs_dayTimeDuration) xs_dateTime_less_than)
     (xs_dateTime       (xs_dateTime)   xs_dateTime_less_than)
     (xs_date           (xs_date)   xs_dateTime_less_than)
     (xs_time           (xs_time)   xs_dateTime_less_than)
     (xs_boolean        (xs_boolean)op_boolean_less_than))
    
    (value_comp_le
     (xs_integer        (xs_integer xs_decimal xs_float xs_double) op_numeric_less_equal_)
     (xs_decimal        (xs_integer xs_decimal xs_float xs_double) op_numeric_less_equal_)
     (xs_float          (xs_integer xs_decimal xs_float xs_double) op_numeric_less_equal_)
     (xs_double         (xs_integer xs_decimal xs_float xs_double) op_numeric_less_equal_)
     (xs_string         (xs_string xs_untypedAtomic) fn_compare_less_equal)
     (xs_untypedAtomic (xs_string xs_untypedAtomic) fn_compare_less_equal)
     (xs_yearMonthDuration (xs_yearMonthDuration) xs_dateTime_less_equal)
     (xs_dayTimeDuration (xs_dayTimeDuration) xs_dateTime_less_equal)
     (xs_dateTime       (xs_dateTime)   xs_dateTime_less_equal)
     (xs_date           (xs_date)   xs_dateTime_less_equal)
     (xs_time           (xs_time)   xs_dateTime_less_equal)
     (xs_boolean        (xs_boolean)op_boolean_less_equal))
    
    (value_comp_gt
     (xs_integer        (xs_integer xs_decimal xs_float xs_double) op_numeric_greater_than_)
     (xs_decimal        (xs_integer xs_decimal xs_float xs_double) op_numeric_greater_than_)
     (xs_float          (xs_integer xs_decimal xs_float xs_double) op_numeric_greater_than_)
     (xs_double         (xs_integer xs_decimal xs_float xs_double) op_numeric_greater_than_)
     (xs_string         (xs_string xs_untypedAtomic) fn_compare_greater_than)
     (xs_untypedAtomic (xs_string xs_untypedAtomic) fn_compare_greater_than)
     (xs_yearMonthDuration (xs_yearMonthDuration) xs_dateTime_greater_than)
     (xs_dayTimeDuration (xs_dayTimeDuration) xs_dateTime_greater_than)
     (xs_dateTime       (xs_dateTime)   xs_dateTime_greater_than)
     (xs_date           (xs_date)   xs_dateTime_greater_than)
     (xs_time           (xs_time)   xs_dateTime_greater_than)
     (xs_boolean        (xs_boolean)op_boolean_greater_than))
    
    (value_comp_ge
     (xs_integer        (xs_integer xs_decimal xs_float xs_double) op_numeric_greater_equal_)
     (xs_decimal        (xs_integer xs_decimal xs_float xs_double) op_numeric_greater_equal_)
     (xs_float          (xs_integer xs_decimal xs_float xs_double) op_numeric_greater_equal_)
     (xs_double         (xs_integer xs_decimal xs_float xs_double) op_numeric_greater_equal_)
     (xs_string         (xs_string xs_untypedAtomic) fn_compare_greater_equal)
     (xs_untypedAtomic (xs_string xs_untypedAtomic) fn_compare_greater_equal)
     (xs_yearMonthDuration (xs_yearMonthDuration) xs_dateTime_greater_equal)
     (xs_dayTimeDuration (xs_dayTimeDuration) xs_dateTime_greater_equal)
     (xs_dateTime       (xs_dateTime)   xs_dateTime_greater_equal)
     (xs_date           (xs_date)   xs_dateTime_greater_equal)
     (xs_time           (xs_time)   xs_dateTime_greater_equal)
     (xs_boolean        (xs_boolean)op_boolean_greater_equal))
    ))

(define (generate-comparison-funs fun table)
  (let loop ((lst table))
    (if (not (null? lst))
        (begin
          (fun (car lst))
          (loop (cdr lst))))))

(define (generate-comparison-fun-prototype fun-info)
  (out "tuple_cell ")
  (out (car fun-info))
  (out "(const tuple_cell &a1, const tuple_cell &a2);")
  (nl))

(define (generate-comparison-fun-e-prototype fun-info)
  (out "tuple_cell ")
  (out (car fun-info))
  (out "_e")
  (out "(const tuple_cell &a1, const tuple_cell &a2);")
  (nl))

(define (generate-comparison-fun-body fun-info)
  (let ((name (car fun-info))
        (variants (cdr fun-info)))
    (out "tuple_cell ")
    (out (car fun-info))
    (out "(const tuple_cell &a1, const tuple_cell &a2)")(nl)
    (out "{")(nl)
    (out "    if (!a1.is_atomic() || !a2.is_atomic())")(nl)
    (out "        throw USER_EXCEPTION2(SE1003, \"Value comparison functions defined on atomic values only\");")(nl)

    (out "    switch (a1.get_atomic_type())")(nl)
    (out "    {")(nl)    
    (let loop1 ((outer variants))
      (if (not (null? outer))
          (begin 
            (out "    case ")
            (out (symbol->string (caar outer)))
            (out ":")(nl)
            (out "            switch (a2.get_atomic_type())")(nl)
            (out "            {")(nl)
            (let loop2 ((inner (cadar outer)))
              (if (not (null? inner))
                  (begin
                    (out "            case ")
                    (out (symbol->string (car inner)))
                    (out ": return ")
                    (out (symbol->string (caddar outer)))                    
                    (cond ((string=? (substring (symbol->string (caddar outer)) 0 10) "op_numeric")
                           (out (symbol->string (caar outer)))
                           (out "_")
                           (out (symbol->string (car inner)))
                           (out "(a1, a2);"))
                          ((string=? (substring (symbol->string (caddar outer)) 0 7) "xs_date")
                           (out "(a1.get_xs_dateTime(), a2.get_xs_dateTime());"))
                          ((string=? (substring (symbol->string (caddar outer)) 0 10) "fn_compare")
                           (out "(")
                           (if (eq? (caar outer) 'xs_untypedAtomic)
                               (out "cast_to_xs_string(a1)")
                               (out "a1"))
                           (out ", ")
                           (if (eq? (car inner) 'xs_untypedAtomic)
                               (out "cast_to_xs_string(a2)")
                               (out "a2"))
                           (out ");"))
                          (else (out "(a1, a2);")))
                    (nl)
                    (loop2 (cdr inner)))))
            (out "            default: throw USER_EXCEPTION2(XPTY0004, \"Type incompatibility in value comparison\");")(nl)
            (out "            }")(nl)
            (loop1 (cdr outer)))))
    (out "    default: throw USER_EXCEPTION2(XPTY0004, \"Type incompatibility in value comparison\");")
    (nl)
    (out "    }")
    (nl)
    
    (out "}")(nl)(nl)))

(define (generate-comparison-fun-e-body fun-info)
  (let ((name (car fun-info)))
    (out "tuple_cell ")
    (out name)
    (out "_e(const tuple_cell &a1, const tuple_cell &a2)")(nl)
    (out "{")(nl)
    (out "    if (a1.is_eos() || a2.is_eos()) return tuple_cell();")(nl)
    (out "    return ")
    (out name)
    (out "(a1, a2);")(nl)
    (out "}")(nl)))



;; GENERATE HEADER FILE
;;
(if output-to-file (set! port (open-output-file "comparison_operations.h")))
(out "#ifndef _COMPARISON_OPERATIONS_H")
(nl)
(out "#define _COMPARISON_OPERATIONS_H")
(nl)
(nl)
(out "// This file was generated. Don't edit it!!!")
(nl)
(nl)
(out "#include \"sedna.h\"")
(nl)
(nl)
(out "#include \"PPBase.h\"")
(nl)
(nl)
(generate-comparison-funs generate-comparison-fun-prototype table)
(nl)
(generate-comparison-funs generate-comparison-fun-e-prototype table)
(nl)
(out "tuple_cell node_comp_is(const tuple_cell &a1, const tuple_cell &a2);")(nl)
(out "tuple_cell node_comp_isnot(const tuple_cell &a1, const tuple_cell &a2);")(nl)
(out "tuple_cell order_comp_lt(const tuple_cell &a1, const tuple_cell &a2);")(nl)
(out "tuple_cell order_comp_gt(const tuple_cell &a1, const tuple_cell &a2);")(nl)
(nl)
(out "#endif")
(nl)
(if output-to-file (close-output-port port))




;;
;; GENERATE SOURCE FILE
;;
(if output-to-file (set! port (open-output-file "comparison_operations.cpp")))
(nl)
(out "// This file was generated. Don't edit it!!!")
(nl)
(nl)
(out "#include \"sedna.h\"")(nl)
(nl)
(out "#include \"comparison_operations.h\"")(nl)
(out "#include \"numeric_operations.h\"")(nl)
(out "#include \"boolean_operations.h\"")(nl)
(out "#include \"string_operations.h\"")(nl)
(out "#include \"casting_operations.h\"")(nl)
(out "#include \"numb_scheme.h\"")(nl)
(out "#include \"XMLDateTime.h\"")(nl)
(nl)
(nl)
(generate-comparison-funs generate-comparison-fun-body table)
(nl)
(generate-comparison-funs generate-comparison-fun-e-body table)
(nl)
(out "tuple_cell node_comp_is(const tuple_cell &a1, const tuple_cell &a2)")(nl)
(out "{")(nl)
(out "    if (!a1.is_node() || !a2.is_node())")(nl)
(out "        throw USER_EXCEPTION2(XPTY0004, \"Can not perform node and order comparison on none-nodes\");")(nl)
(out "    return tuple_cell::atomic(nid_cmp(a1.get_node(), a2.get_node()) == 0);")(nl)
(out "}")(nl)
(nl)
(out "tuple_cell node_comp_isnot(const tuple_cell &a1, const tuple_cell &a2)")(nl)
(out "{")(nl)
(out "    if (!a1.is_node() || !a2.is_node())")(nl)
(out "        throw USER_EXCEPTION2(XPTY0004, \"Can not perform node and order comparison on none-nodes\");")(nl)
(out "    return tuple_cell::atomic(nid_cmp(a1.get_node(), a2.get_node()) != 0);")(nl)
(out "}")(nl)
(nl)
(out "tuple_cell order_comp_lt(const tuple_cell &a1, const tuple_cell &a2)")(nl)
(out "{")(nl)
(out "    if (!a1.is_node() || !a2.is_node())")(nl)
(out "        throw USER_EXCEPTION2(XPTY0004, \"Can not perform node and order comparison on none-nodes\");")(nl)
(out "    return tuple_cell::atomic(nid_cmp(a1.get_node(), a2.get_node()) < 0);")(nl)
(out "}")(nl)
(nl)
(out "tuple_cell order_comp_gt(const tuple_cell &a1, const tuple_cell &a2)")(nl)
(out "{")(nl)
(out "    if (!a1.is_node() || !a2.is_node())")(nl)
(out "        throw USER_EXCEPTION2(XPTY0004, \"Can not perform node and order comparison on none-nodes\");")(nl)
(out "    return tuple_cell::atomic(nid_cmp(a1.get_node(), a2.get_node()) > 0);")(nl)
(out "}")(nl)
(if output-to-file (close-output-port port))
