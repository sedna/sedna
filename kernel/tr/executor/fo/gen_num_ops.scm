
; File:  gen_num_ops.scm
; Copyright (C) 2004 The Institute for System Programming of the Russian Academy of Sciences (ISP RAS)

#>
// only for MSDEV 6.0
#if (_MSC_VER == 1200) && (WINVER < 0x0500)
long _ftol( double ); //defined by VC6 C libs
long _ftol2( double dblSource ) { return _ftol(dblSource ); } 
#endif
<#

(define port (current-output-port))
(define output-to-file #t)

(define (out s)
  (display s port))

(define (nl) (newline port))

(define (type2weight type)
  (cond ((eq? type 'xs_integer) 10)
        ((eq? type 'xs_decimal) 20)
        ((eq? type 'xs_float) 30)
        ((eq? type 'xs_double) 40)
        (else (error "type2weight"))))

(define (weight2type weight)
  (cond ((eq? weight 10) 'xs_integer)
        ((eq? weight 20) 'xs_decimal)
        ((eq? weight 30) 'xs_float)
        ((eq? weight 40) 'xs_double)
        (else (error "weight2type"))))

(define (generate-one-simple-op fun word symb lst1 lst2)
  (let loop1 ((outer lst1))
    (if (not (null? outer))
        (begin 
          (let loop2 ((inner lst2))
            (if (not (null? inner))
                (begin
                  (fun word symb (car outer) (car inner))
                  (loop2 (cdr inner)))))
          (loop1 (cdr outer))))))

(define (generate-arg word type gct a)
  (cond ((eq? gct type)
         (begin
           (out a)
           (out ".get_")
           (out (symbol->string type))
           (out "()")))
        (else
         (begin
           (out (symbol->string type))
           (out "2")
           (out (symbol->string gct))
           (out "(")
           (out a)
           (out ")")))))

(define (find-gct word type1 type2)
  (cond ((and (eq? type1 'xs_untypedAtomic) (eq? type2 'xs_untypedAtomic)) 
         (if (string=? word "idiv") 'xs_integer 'xs_double))
        ((eq? type1 'xs_untypedAtomic)
         (if (string=? word "idiv") (find-gct word 'xs_integer type2) (find-gct word 'xs_double type2)))
        ((eq? type2 'xs_untypedAtomic)
         (if (string=? word "idiv") (find-gct word type1 'xs_integer) (find-gct word type1 'xs_double)))
        (else (weight2type (max (type2weight type1) (type2weight type2))))))

(define (out-XMLSchema-type-as-C-type type)
  (let* ((type-str (symbol->string type))
         (str (substring type-str 3 (string-length type-str))))
    (out (if (string=? str "integer") 
             "__int64" 
             (if (string=? str "decimal") "xs_decimal_t" str)))))

(define (generate-simple-op-body word symb type1 type2)
  (let* ((gct (find-gct word type1 type2)))
    (out "tuple_cell op_numeric_")
    (out word)
    (out "_")
    (out (symbol->string type1))
    (out "_")
    (out (symbol->string type2))
    (out "(const tuple_cell &a1, const tuple_cell &a2)")
    (nl)
    (out "{")
    (nl)
    (cond 
          ((or (string=? word "divide") (string=? word "integer_divide") (string=? word "mod")) 
           (begin
             (out "    return tuple_cell::atomic(")
             (out symb)
             (out "(")
             (generate-arg word type1 gct "a1")
             (out ", ")
             (generate-arg word type2 gct "a2")
             (out "));")))
          ((and (string=? word "equal") (string=? (symbol->string type1) "xs_double"))  ;This temp hack for doubles is needed because
           (begin                                                                       ;you couldn't use '==' in C/C++ to compare them -
             (out "    return tuple_cell::atomic(")                                     ; '==' should be changed to 'a-b < epsilon'.
             (generate-arg word type2 gct "a2")                                         ;But operands transposing gives good effect here too ...
             (out " ")
             (out symb)
             (out " ")
             (generate-arg word type1 gct "a1")
             (out ");")))
          (else 
           (begin
             (out "    return tuple_cell::atomic(")
             (generate-arg word type1 gct "a1")
             (out " ")
             (out symb)
             (out " ")
             (generate-arg word type2 gct "a2")
             (out ");"))))
    (nl)
    (out "}")
    (nl)
    (nl)))

(define (generate-simple-op-prototype word symb type1 type2)
  (out "tuple_cell op_numeric_")
  (out word)
  (out "_")
  (out (symbol->string type1))
  (out "_")
  (out (symbol->string type2))
  (out "(const tuple_cell &a1, const tuple_cell &a2);")
  (nl))


(define (generate-numeric-fun-body word type-lst)
  (out "tuple_cell op_numeric_")
  (out word)
  (out "(const tuple_cell &a1, const tuple_cell &a2)")
  (nl)
  (out "{")
  (nl)
  (out "    if (!a1.is_atomic() || !a2.is_atomic())")
  (nl)
  (out "        throw USER_EXCEPTION2(SE1003, \"Numerical operations are defined on atomic values only\");")
  (nl)
  
  (out "    switch (a1.get_atomic_type())")
  (nl)
  (out "    {")
  (nl)
  (let loop1 ((outer type-lst))
    (if (not (null? outer))
        (begin 
          (out "    case ")
          (out (symbol->string (car outer)))
          (out ":")
          (nl)
          (out "            switch (a2.get_atomic_type())")
          (nl)
          (out "            {")
          (nl)
          (let loop2 ((inner type-lst))
            (if (not (null? inner))
                (begin
                  (out "            case ")
                  (out (symbol->string (car inner)))
                  (out ": return op_numeric_")
                  (out word)
                  (out "_")
                  (out (symbol->string (car outer)))
                  (out "_")
                  (out (symbol->string (car inner)))
                  (out "(a1, a2);")
                  (nl)
                  (loop2 (cdr inner)))))
          (out "            default: throw USER_EXCEPTION2(XPTY0004, \"Invalid arguments of a numeric operation\");")
          (nl)
          (out "            }")
          (nl)
          (loop1 (cdr outer)))))
  (out "    default: throw USER_EXCEPTION2(XPTY0004, \"Invalid arguments of a numeric operation\");")
  (nl)
  (out "    }")
  (nl)
  
  (out "}")
  (nl)
  (nl))

(define (generate-numeric-fun-e-body word type-lst)
  (out "tuple_cell op_numeric_")
  (out word)
  (out "_e(const tuple_cell &a1, const tuple_cell &a2)")(nl)
  (out "{")(nl)
  (out "    if (a1.is_eos() || a2.is_eos()) return tuple_cell::eos();")(nl)
  (out "    return op_numeric_")
  (out word)
  (out "(a1, a2);")(nl)
  (out "}")
  (nl))

(define (generate-numeric-fun-prototype word type-lst)
  (out "tuple_cell op_numeric_")
  (out word)
  (out "(const tuple_cell &a1, const tuple_cell &a2);")
  (nl))

(define (generate-numeric-fun-e-prototype word type-lst)
  (out "tuple_cell op_numeric_")
  (out word)
  (out "_e(const tuple_cell &a1, const tuple_cell &a2);")
  (nl))

(define type-lst (list (string->symbol "xs_integer")
                       (string->symbol "xs_decimal")
                       (string->symbol "xs_float")
                       (string->symbol "xs_double")
                       (string->symbol "xs_untypedAtomic")))

(define op-lst '(("add" "+") 
                 ("subtract" "-")
                 ("multiply" "*")
                 ("divide" "xs_divide")
                 ("integer_divide" "xs_integer_divide")
                 ("mod" "xs_mod")
                 ("equal" "==")
                 ("less_than" "<")
                 ("greater_than" ">")
                 ("not_equal" "!=")
                 ("less_equal" "<=")
                 ("greater_equal" ">=")))

(define (generate-simple-ops fun op-lst type-lst)
  (let loop ((lst op-lst))
    (if (not (null? lst))
        (begin
          (generate-one-simple-op fun (caar lst) (cadar lst) type-lst type-lst)
          (loop (cdr lst))))))

(define (generate-numeric-funs fun op-lst type-lst)
  (let loop ((lst op-lst))
    (if (not (null? lst))
        (begin
          (fun (caar lst) type-lst)
          (loop (cdr lst))))))


;;
;; GENERATE HEADER FILE
;;
(if output-to-file (set! port (open-output-file "numeric_operations.h")))
(out "#ifndef _NUMERIC_OPERATIONS_H")
(nl)
(out "#define _NUMERIC_OPERATIONS_H")
(nl)
(nl)
(out "// This file was generated. Don't edit it!!!")
(nl)
(nl)
(out "#include \"common/sedna.h\"")
(nl)
(nl)
(out "#include \"tr/executor/base/PPBase.h\"")
(nl)
(nl)
(generate-simple-ops generate-simple-op-prototype op-lst type-lst)
(nl)
(nl)
(out "tuple_cell op_numeric_unary_plus_xs_integer(const tuple_cell& a);")(nl)
(out "tuple_cell op_numeric_unary_plus_xs_decimal(const tuple_cell& a);")(nl)
(out "tuple_cell op_numeric_unary_plus_xs_float(const tuple_cell& a);")(nl)
(out "tuple_cell op_numeric_unary_plus_xs_double(const tuple_cell& a);")(nl)
(out "tuple_cell op_numeric_unary_plus_xs_untypedAtomic(const tuple_cell& a);")(nl)
(nl)
(out "tuple_cell op_numeric_unary_minus_xs_integer(const tuple_cell& a);")(nl)
(out "tuple_cell op_numeric_unary_minus_xs_decimal(const tuple_cell& a);")(nl)
(out "tuple_cell op_numeric_unary_minus_xs_float(const tuple_cell& a);")(nl)
(out "tuple_cell op_numeric_unary_minus_xs_double(const tuple_cell& a);")(nl)
(out "tuple_cell op_numeric_unary_minus_xs_untypedAtomic(const tuple_cell& a);")(nl)
(nl)
(out "#endif")
(nl)
(if output-to-file (close-output-port port))






;;
;; GENERATE SOURCE FILE
;;
(if output-to-file (set! port (open-output-file "numeric_operations.cpp")))
(nl)
(out "// This file was generated. Don't edit it!!!")
(nl)
(nl)
(out "#include <math.h>")(nl)
(out "#include \"common/sedna.h\"")(nl)
(out "#include \"tr/executor/fo/numeric_operations.h\"")(nl)
(out "#include \"tr/executor/fo/casting_operations.h\"")(nl)
(out "#include \"tr/executor/base/PPUtils.h\"")(nl)
(out "#include \"tr/executor/base/xs_helper.h\"")(nl)
(nl)
(out "xs_decimal_t xs_integer2xs_decimal(const tuple_cell &tc) { return xs_decimal_t(tc.get_xs_integer()); }")(nl)
(out "float xs_integer2xs_float(const tuple_cell &tc) { return (float)(tc.get_xs_integer()); }")(nl)
(out "double xs_integer2xs_double(const tuple_cell &tc) { return (double)(tc.get_xs_integer()); }")(nl)
(out "float xs_decimal2xs_float(const tuple_cell &tc) { return tc.get_xs_decimal().get_float(); }")(nl)
(out "double xs_decimal2xs_double(const tuple_cell &tc) { return tc.get_xs_decimal().get_double(); }")(nl)
(out "double xs_float2xs_double(const tuple_cell &tc) { return (double)(tc.get_xs_float()); }")(nl)
(out "double xs_untypedAtomic2xs_double(const tuple_cell &tc) { return cast_primitive_to_xs_double(tc).get_xs_double(); }")(nl)
(nl)
(nl)
(nl)
(generate-simple-ops generate-simple-op-body op-lst type-lst)
(nl)
(out "tuple_cell op_numeric_unary_plus_xs_integer(const tuple_cell& a) { return a; }")(nl)
(out "tuple_cell op_numeric_unary_plus_xs_decimal(const tuple_cell& a) { return a; }")(nl)
(out "tuple_cell op_numeric_unary_plus_xs_float(const tuple_cell& a) { return a; }")(nl)
(out "tuple_cell op_numeric_unary_plus_xs_double(const tuple_cell& a) { return a; }")(nl)
(out "tuple_cell op_numeric_unary_plus_xs_untypedAtomic(const tuple_cell& a) { return cast_primitive_to_xs_double(a); }")(nl)
(nl)
(out "tuple_cell op_numeric_unary_minus_xs_integer(const tuple_cell& a)")(nl)
(out "{ return tuple_cell::atomic(-a.get_xs_integer()); }")(nl)
(out "tuple_cell op_numeric_unary_minus_xs_decimal(const tuple_cell& a)")(nl)
(out "{ return tuple_cell::atomic(-a.get_xs_decimal()); }")(nl)
(out "tuple_cell op_numeric_unary_minus_xs_float(const tuple_cell& a)")(nl)
(out "{ return tuple_cell::atomic(-a.get_xs_float()); }")(nl)
(out "tuple_cell op_numeric_unary_minus_xs_double(const tuple_cell& a)")(nl)
(out "{ return tuple_cell::atomic(-a.get_xs_double()); }")(nl)
(out "tuple_cell op_numeric_unary_minus_xs_untypedAtomic(const tuple_cell& a)")(nl)
(out "{ return tuple_cell::atomic(-cast_primitive_to_xs_double(a).get_xs_double()); }")(nl)
(nl)
(if output-to-file (close-output-port port))

