/* */

flwrorExpr! [in_context in_c] >[out_context out_c]:
	  #(AST_FLWR_ORDER_BY flwr1:flwrExpr[in_c] >[out_c] vdl:varDeclList[in_c] >[out_c] obc:orderByClause[in_c] >[out_c] re:exprSingle[in_c] >[out_c])
	  <<#flwrorExpr=#(#["return"], #(#["order-by"], flwr1, 
	                                 #(#["fun-def"], vdl, obc)),
	                    #(#["fun-def"], vdl->dup(), re));
	  >>

	| flwr:flwrExpr[in_c] >[out_c]
	  <<#flwrorExpr = flwr;>>
;

varDeclList! [in_context in_c] >[out_context out_c]:
    <<PCCTS_AST* res = NULL; bool type = false;>>
	(#(AST_VAR_DECL v1:vardecl ev1:expr[in_c] >[out_c] {st1:sequenceType <<type = true;>>})
	<<if (res == NULL)
          {
            if (type) res = #(#[], st1, v1);
            else res = #(#[], #["xs:anyType"], v1);
          }
          else
          {
            if (type) res->append(#(#[], st1, v1));
            else res->append(#(#[], #["xs:anyType"], v1));
          }
   	    type = false;
	>>

	| #(AST_POS_VAR_DECL v2:vardecl)
	  <<if (res == NULL)
	        res = #(#[], #["se:positional-var"], v2);
	    else
	        res->append(#(#[], #["se:positional-var"], v2));
	  >>
	 
	)+

	<<#varDeclList=#(#[], res);>>
;


flwrExpr! [in_context in_c] >[out_context out_c]:
	<<bool isFor=false;
	  out_context _out_c1_, _out_c2_, _out_c3_;
	>>

	#(AST_BOUND (  #(AST_FOR #(AST_VAR_DECL v1:vardecl ev1:expr[in_c] >[_out_c1_] {st1:sequenceType}) {v2:vardecl})
                       <<isFor=true;>>

                      | #(AST_LET #(AST_VAR_DECL v3:vardecl ev2:expr[in_c] >[_out_c2_] {st2:sequenceType})))

                     e:expr[in_c] >[_out_c3_])
	<<
	  if(isFor){ //LR for forClause
	    SORASTBase *iter_seq=NULL, *var_decl=NULL, *pos_decl=NULL;

	    if(v2!=NULL){
	      pos_decl=#(#["se:positional-var"], v2);
//	      iter_seq=#(#["con-gen1"], ev1, #["m"]); //last param must be a number, but it's value is not defined in Logical Reperesentation yet
	    }
	    else{
	      pos_decl=NULL;
//	      iter_seq=ev1;
	    }

            iter_seq=ev1;

	    if(st1!=NULL){
	      var_decl=st1;
	      var_decl->append(v1);
	      var_decl=#(#[], var_decl);
	    }
	    else{
	      var_decl=#(#["xs:anyType"], v1);
	    }

	    #flwrExpr=#(#["return"], iter_seq,
                        #(#["fun-def"],
                          #(#[], var_decl, pos_decl),
                          e)
                       );
	  }// end LR for forClause
	 
          else{ //LR for letClause
	    SORASTBase *var_decl=NULL;

	    if(st2!=NULL){
	      var_decl=st2;
	      var_decl->append(v3);
	      var_decl=#(#[], var_decl);
	    }
	    else{
	      var_decl=#(#["xs:anyType"], v3);
	    }
	    //#flwrExpr=#(#["let@"],
	    //            #(#[], var_decl, ev2),
            //            e
            //           );
	    #flwrExpr=#(#["let@"], 
	                ev2,
	                #(#["fun-def"], #(#[], var_decl), e));

	  }// end LR for letClause

	>>
;


orderByClause! [in_context in_c] >[out_context out_c]:
	  #(AST_ORDER_BY <<#orderByClause=#(#["orderspecs"], #(#["const"], #(#["type"], #["!xs!string"]), #["\"non-stable\""])); >>
         (os1:orderSpec[in_c] >[out_c] <<#orderByClause->addChild(os1);>>)*)
	| #(AST_STABLE_ORDER_BY <<#orderByClause=#(#["orderspecs"], #(#["const"], #(#["type"], #["!xs!string"]), #["\"stable\""])); >>
         (os2:orderSpec[in_c] >[out_c]<<#orderByClause->addChild(os2);>>)*)
;

orderSpec! [in_context in_c] >[out_context out_c]:
	<<out_context out_c;>>
	#(AST_ORDER_SPEC e:exprSingle[in_c] >[out_c] om:orderModifier)
	<<#orderSpec=#(#["orderspec"], om, e );>>
;

orderModifier!:
	#(AST_ORDER 
	  #(AST_ASC_DESC {p1:AST_ORDER_PROPERTY})
	  #(AST_EMPT_GR_LST {p2:AST_ORDER_PROPERTY})
	  #(AST_COLLATION {p3:AST_ORDER_PROPERTY})
	)
	<<#orderModifier=#(#[], #["ordermodifier"]);

	  if(p1!=NULL) 
	    #orderModifier->addChild(#(#["const"], 
	                               #(#["type"], 
	                                 #["!xs!string"]),
	                                 #[p1->getText()]));

	  if(p2!=NULL) 
	    #orderModifier->addChild(#(#["const"], 
	                               #(#["type"], 
	                                 #["!xs!string"]),
	                                 #[p2->getText()]));

	  if(p3!=NULL) 
	    #orderModifier->addChild(#(#["collation"],
	                               #(#["const"], 
	                                 #(#["type"], 
	                                   #["!xs!string"]),
	                                   #[p3->getText()])));

	  
	>>
;

unioExpr! [in_context in_c] > [out_context out_c]:
    #(AST_UNIO vdl:varDeclList[in_c] >[out_c])
    <<PCCTS_AST* res, *it;
      res = #(#["unio"]);
      for (it = vdl->down(); it != NULL; it= it->right())
      {
         res->addChild(it->down()->right());
      }

      #unioExpr= res;
	>>
;     
