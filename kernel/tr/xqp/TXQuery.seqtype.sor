/**/

singleType!:
	#(AST_TYPE #(AST_ATOMIC qn:qname), {m:AST_MULTIPLICITY})
	<<
	  if(std::string(((SORAST *)qn)->getText())=="\"xs\"" &&
	             (std::string(((SORAST *)(qn->down()))->getText())=="\"anySimpleType\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"gYearMonth\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"gYear\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"gMonthDay\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"gDay\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"gMonth\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"dateTime\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"time\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"date\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"duration\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"boolean\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"base64Binary\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"hexBinary\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"float\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"double\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"anyURI\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"QName\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"NOTATION\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"string\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"decimal\"" ||
	              std::string(((SORAST *)(qn->down()))->getText())=="\"integer\"" 
	             )
                   || //xdt prefix
             std::string(((SORAST *)qn)->getText())=="\"xs\"" &&
	              std::string(((SORAST *)(qn->down()))->getText())=="\"untypedAtomic\"")


	  {
	    std::string type=std::string(((SORAST *)(qn->down()))->getText());
	    type.erase(type.begin()); // erase " at the begin 
	    type.erase(type.end()-1); // arase " at the end

	    std::string prefix = std::string(((SORAST *)qn)->getText());
	    prefix.erase(prefix.begin()); // erase " at the begin 
	    prefix.erase(prefix.end()-1); // arase " at the end

	    if(m==NULL) 
	       #singleType=#(#["one"], #[std::string("!")+prefix+std::string("!")+type]);
	    else 
	    {
	       #singleType=#(#[m->getText()], #[std::string("!")+prefix+std::string("!")+type]);
	    }

      }
      else
	  {
	    if(m==NULL) 
	       #singleType=#(#["one"], qn);
	    else 
	    {
	       #singleType=#(#[m->getText()], qn);
	    }

	  }
	           
	>>
;

sequenceType!:
	#(AST_TYPE (  AST_EMPTY  <<#sequenceType=#(#[], #["empty-test"]);>> 

		    | AST_ITEM_TEST {m1:AST_MULTIPLICITY}
	              <<if(m1==NULL)
	                  #sequenceType=#(#["one"], #(#[], #["item-test"]));
	                else
	                {
	                  #sequenceType=#(#[m1->getText()], #(#[], #["item-test"]));
	                }
	              >>

		    | #(AST_ATOMIC qn:qname) {m2:AST_MULTIPLICITY}
	              <<
	                if(std::string(((SORAST *)qn)->getText())=="\"xs\"" &&
	                         (std::string(((SORAST *)(qn->down()))->getText())=="\"anySimpleType\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"gYearMonth\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"gYear\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"gMonthDay\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"gDay\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"gMonth\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"dateTime\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"time\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"date\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"duration\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"boolean\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"base64Binary\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"hexBinary\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"float\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"double\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"anyURI\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"QName\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"NOTATION\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"string\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"decimal\"" ||
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"integer\"" 
	                         )
                               || //xdt prefix
	                    std::string(((SORAST *)qn)->getText())=="\"xs\"" &&
	                          std::string(((SORAST *)(qn->down()))->getText())=="\"untypedAtomic\"")
	                  {
	                   std::string type=std::string(((SORAST *)(qn->down()))->getText());
	                   type.erase(type.begin()); // erase " at the begin 
	                   type.erase(type.end()-1); // arase " at the end

	                   std::string prefix = std::string(((SORAST *)qn)->getText());
	                   prefix.erase(prefix.begin()); // erase " at the begin 
		           prefix.erase(prefix.end()-1); // arase " at the end

	                   if ( m2 == NULL )
	                      #sequenceType=#(#["one"], #[std::string("!")+prefix+std::string("!")+type]);
			   else 
	                      #sequenceType=#(#[m2->getText()], #[std::string("!")+prefix+std::string("!")+type]);
       	                  }
	                
	                else
	                {
	                   if(m2 != NULL)   
	                     #sequenceType=#(#[m2->getText()], #sequenceType);
	                   else
	                     #sequenceType=#(#["one"], qn);
	                
	                }
	              >>

	            | it:kindTest {m3:AST_MULTIPLICITY}

	              <<if(m3==NULL)
	                   #sequenceType=#(#["one"], it);
	                else
	                   #sequenceType=#(#[m3->getText()], it);
	              >>
                   )
	 )
;



kindTest!:
	( AST_COMMENT_TEST <<#kindTest=#(#[], #["comment-test"]);>>
	| AST_TEXT_TEST    <<#kindTest=#(#[], #["text-test"]);>>
	| AST_NODE_TEST    <<#kindTest=#(#[], #["node-test"]);>>
	| #(AST_DOCUMENT_TEST {et:elementTest})

	  <<#kindTest=#(#["doc-test"], et);>>

	| et:elementTest      <<#kindTest=et;>>	
	| at:attributeTest    <<#kindTest=at;>>
	| pi:piTest           <<#kindTest=pi;>>
	)
;


elementTest!:
	#(AST_ELEMENT_TEST ( ( AST_EMPTY_ELEMENT_CONTENT 
	                       <<
	                          #elementTest=
	                             #(#["ename"],
	                               #(#["const"], #(#["type"], #["!xs!QName"]), #["unspecified"]),
	                               #(#["type"], #["unspecified"]),
	                               #(#["const"], #(#["type"], #["!xs!string"]), #["\"non-nil\""]));

	                       >>
	                      )
	                    |
	                     ( scp:schemaContextPath  qn:qname

	                      <<#elementTest=#(#["sname"], scp, qn);>>
	                     )
	                    | (enw:elemNameorWildcard {tnw:typeNameorWildcard {n:nillable}} 

	                      <<
	                       if(tnw==NULL && n==NULL)
	                          #elementTest=
	                             #(#["ename"], enw,
	                               #(#["type"], #["unspecified"]),
	                               #(#["const"], #(#["type"], #["!xs!string"]), #["\"non-nil\""]));
	                       else

	                       if(tnw!=NULL && n==NULL)
	                          #elementTest=
	                             #(#["ename"], enw, tnw,
	                               #(#["const"], #(#["type"], #["!xs!string"]), #["\"non-nil\""]));
	                       else
	                          #elementTest=#(#["ename"], enw, tnw, n);
	                          

	                      >>
	                      )

	                   )
	 )
	<<#elemTest=#(#["elem-test"], #elemTest);>>
;

attributeTest!:
	#(AST_ATTRIBUTE_TEST (( AST_EMPTY_ATTRIBUTE_CONTENT 
	                       <<
	                          #attributeTest=
	                             #(#["ename"],
	                               #(#["const"], #(#["type"], #["!xs!QName"]), #["unspecified"]),
	                               #(#["type"], #["unspecified"]));

	                       >>
	                      )
	                    |
	                       ( scp:schemaContextPath qn:qname

	                        <<#attributeTest=#(#["sname"], scp, qn);>>
	                       )
	                      | (anw:attrNameorWildcard {tnw:typeNameorWildcard}

	                        <<
	                          if(tnw==NULL)
	                             #attributeTest=
	                                #(#["ename"], anw,
	                                  #(#["type"], #["unspecified"]));
	                          else
	                             #attributeTest=
	                                #(#["ename"], anw, tnw);
	                        >>
	                        )

	                     )
	)
	<<#attributeTest=#(#["attr-test"], #attributeTest);>>
;

piTest!:
	<<bool exist_arg=false;>>
	#(AST_PI {
	           (  n:AST_LOCAL_NAME  <<#piTest=#(#["pi-test"], #(#["const"], #(#["type"], #["!xs!NCName"]), #[n->getText()])); exist_arg=true;>>
	            | s:AST_STRING_CONST  <<#piTest=#(#["pi-test"], #(#["const"], #(#["type"], #["!xs!string"]), #[s->getText()])); exist_arg=true;>>
	           )
	        })
	<<if(!exist_arg) #piTest=#(#[], #["pi-test"]);>>
;

schemaContextPath!:
	#(AST_SCHEMA_CONTEXT_PATH 
	    (  #(AST_GLOBAL_NAME qn1:qname)
               <<#schemaContextPath=qn1;>>

	       (qn2:qname
	        <<#schemaContextPath->append(qn2);>>
	       )*
	
	     | #(AST_GLOBAL_TYPE qn3:qname)  
               <<#schemaContextPath=#(#["*type*"], qn3);>>

	       (qn4:qname
	        <<#schemaContextPath->append(qn4);>>
	       )*
	    )
	 )
	<<#schemaContextPath=#(#["sgc"], #schemaContextPath);>>
;

elemNameorWildcard!:
	  #(AST_ELEMENT_NAME qn:qname)

	  <<#elemNameorWildcard=
	       #(#["const"], #(#["type"], #["!xs!QName"]), qn);
	  >>	

	| AST_WILDCARD

	  <<#elemNameorWildcard=
	       #(#["const"], #(#["type"], #["!xs!QName"]), #["*"]);
	  >>
;

nillable!:
	AST_NIL 
	 <<#nillable=#(#["const"], #(#["type"], #["!xs!string"]), #["nil"]);>>
        
;

attrNameorWildcard!:
	  #(AST_ATTRIBUTE_NAME qn:qname)

	  <<#attrNameorWildcard=
	       #(#["const"], #(#["type"], #["!xs!QName"]), qn);
	  >>	

	| AST_WILDCARD

	  <<#attrNameorWildcard=
	       #(#["const"], #(#["type"], #["!xs!QName"]), #["*"]);
	  >>

;

typeNameorWildcard!:
	   AST_WILDCARD  <<#typeNameorWildcard=#(#["type"], #["*"]);>>
	 | #(AST_TYPE_NAME qn:qname)
	  <<
	    std::string loc_name=((SORAST *)(qn))->getText();
	    std::string prefix="";

	    if(qn->down()!=NULL) 
	      prefix=((SORAST *)(qn->down()))->getText();

	    if(prefix=="" || prefix=="xs") //built in types
	      //check: loc_name must be one of the built in types
	      #typeNameorWildcard=#(#["type"], #[std::string("!xs")+loc_name]);
	    else
	      #typeNameorWildcard=#(#["type"], qn);
	      
	  >>
;

}