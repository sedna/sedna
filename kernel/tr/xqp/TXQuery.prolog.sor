/**/

prolog!:
	<<SORASTBase* prolog_ = NULL;>>
	(  fd:functionDefn
	   <<if (prolog_ == NULL) prolog_ =fd; else prolog_->append(fd);>>
	 | nd:namespaceDecl
	   <<if (prolog_ == NULL) prolog_ =nd; else prolog_->append(nd);>>
	 | dnd:defaultNamaspaceDecl
	   <<if (prolog_ == NULL) prolog_ =dnd; else prolog_->append(dnd);>>

	 | dc:defaultCollation
	   <<if (prolog_ == NULL) prolog_ =dc; else prolog_->append(dc);>>

	 | dbur:declareBaseURI
	   <<if (prolog_ == NULL) prolog_ =dbur; else prolog_->append(dbur);>>

	 | dconstr:declareConstruction
	   <<if (prolog_ == NULL) prolog_ =dconstr; else prolog_->append(dconstr);>>

	 | do_:declareOrder
	   <<if (prolog_ == NULL) prolog_ =do_; else prolog_->append(do_);>>

	 | dv:declareVar
	   <<if (prolog_ == NULL) prolog_ =dv; else prolog_->append(dv);>>

	 | dcns:declareCopyNS
	   <<if (prolog_ == NULL) prolog_ =dcns; else prolog_->append(dcns);>>

	 | eod:emptyOrderDecl
	   <<if (prolog_ == NULL) prolog_ =eod; else prolog_->append(eod);>>

	 | bsd:boundarySpaceDecl
	   <<if (prolog_ == NULL) prolog_ =bsd; else prolog_->append(bsd);>>
	 | dopt:declareOption
	   <<if (prolog_ == NULL) prolog_ =dopt; else prolog_->append(dopt);>>

	 | vd:versionDecl
	   <<if (prolog_ == NULL) prolog_ =vd; else prolog_->append(vd);>>

	 | im:importModule
	   <<if (prolog_ == NULL) prolog_ =im; else prolog_->append(im);>>

	)*
	<<#prolog= prolog_;>>
;

functionDefn!:
	 <<out_context _out_c_;>>
	 #(AST_FUNCTION qn1:qname 
	   pl1:paramList
	   #(AST_RETURNED_TYPE st1:sequenceType)
	   #(AST_BODY_FUNC {e:expr[in_context()] >[_out_c_]}))

	 <<
	   if (e != NULL)
	      #functionDefn=#(#["declare-function"],
	                      #(#["const"],
	                        #(#["type"], #["!xs!QName"]),
	                        qn1),
	                      pl1,
	                      #(#[], #["result-type"], st1),
	                      #(#["body"], e));
	   else
	      #functionDefn=#(#["declare-external-function"],
	                      #(#["const"],
	                        #(#["type"], #["!xs!QName"]),
	                        qn1),
	                      pl1,
	                      #(#[], #["result-type"], st1));

	 >>
;


paramList!:
	<<#paramList=#[];>>
	#(AST_FPARAMS (p:param <<#paramList->addChild(p);>>)*)
	<<if(p==NULL) //there is no params
	    #paramList->addChild(#[]);
	>>
;


param!:
	#(AST_PARAM v:vardecl st:sequenceType)

	<<#param=#(#[], st, v);>>
;

versionDecl!:
	#(AST_VERSION_DECL s1:AST_STRING_CONST 
	<<#versionDecl=#(#["version-declaration"],
	                   #(#["const"], 
	                     #(#["type"], #["!xs!string"]),
	                     #[s1->getText()]));
	>>

	  {s2:AST_STRING_CONST <<#versionDecl->addChild(#(#["const"], 
	                                                  #(#["type"], #["!xs!string"]),
	                                                  #[s2->getText()]));>>
	  }
	)
;



namespaceDecl!:
	#(AST_DECL_NSP p:AST_PREFIX s:AST_STRING_CONST)

	<<#namespaceDecl=#(#["declare-namespace"], 
	                   #[p->getText()],
	                   #(#["const"], 
	                     #(#["type"], #["!xs!string"]),
	                     #[s->getText()]));
	>>
;

defaultNamaspaceDecl!:
	(#(AST_DECL_DEF_ELEM_NSP s:AST_STRING_CONST)

	 <<#defaultNamaspaceDecl=#(#["declare-default-element-namespace"],
	                           #(#["const"], 
	                             #(#["type"], #["!xs!string"]),
	                             #[s->getText()]));   
	 >>
	|
	 #(AST_DECL_DEF_FUNC_NSP s2:AST_STRING_CONST)
	 <<#defaultNamaspaceDecl=#(#["declare-default-function-namespace"],
	                           #(#["const"], 
	                             #(#["type"], #["!xs!string"]),
	                             #[s2->getText()]));   
	 >>

	)
;

defaultCollation!:
	#(AST_DEF_COLL s:AST_STRING_CONST)
	<<#defaultCollation=#(#["declare-default-collation"],
	                           #(#["const"], 
	                             #(#["type"], #["!xs!string"]),
	                             #[s->getText()]));   

	>>
;

boundarySpaceDecl!:
	(  AST_BSPACE_P <<#boundarySpaceDecl = #(#["boundary-space-decl"], #(#["const"], #(#["type"], #["!xs!string"]), #["\"preserve\""]));>>
	 | AST_BSPACE_S <<#boundarySpaceDecl = #(#["boundary-space-decl"], #(#["const"], #(#["type"], #["!xs!string"]), #["\"strip\""]));>>
	)
;

declareOption!:
	#(AST_DECLARE_OPT qn:qname s:AST_STRING_CONST)
	<<
	  #declareOption = #(#["declare-option"],
	                     #(#["const"],
	                       #(#["type"], #["!xs!QName"]),
	                       qn),
	                     #(#["const"],
	                       #(#["type"], #["!xs!string"]),
	                       #[s->getText()]));
	>>
;

declareBaseURI!:
	#(AST_DECL_BURI s:AST_STRING_CONST)
	<<#declareBaseURI=#(#["declare-base-uri"],
	                     #(#["const"],
	                       #(#["type"], #["!xs!string"]),
	                       #[s->getText()]));>>
;

declareOrder!:
	(  AST_DECL_ORD 
	   <<#declareOrder = #(#["declare-order"], #(#["const"], #(#["type"], #["!xs!string"]), #["\"ordered\""]));>>
	 | AST_DECL_UNORD
	   <<#declareOrder = #(#["declare-order"], #(#["const"], #(#["type"], #["!xs!string"]), #["\"unordered\""]));>>
	)
;

declareConstruction!:
	(  AST_DECL_CONSTR_P
	   <<#declareConstruction = #(#["declare-construction"], #(#["const"], #(#["type"], #["!xs!string"]), #["\"preserve\""]));>>
	 | AST_DECL_CONSTR_S
	   <<#declareConstruction = #(#["declare-construction"], #(#["const"], #(#["type"], #["!xs!string"]), #["\"strip\""]));>>
	)
;

declareCopyNS!:
	#(AST_DECL_COPY_NS s1:AST_STRING_CONST s2:AST_STRING_CONST)
	<<#declareCopyNS=#(#["declare-copy-namespaces"],
	                       #(#["const"], #(#["type"], #["!xs!string"]), #[std::string("\"")+std::string(s1->getText())+ std::string("\"")]), 
	                       #(#["const"], #(#["type"], #["!xs!string"]), #[std::string("\"")+std::string(s2->getText())+ std::string("\"")]));
	>>
;

declareVar!:
	 <<out_context _out_c_;>>
	(  #(AST_VAR_DECL_EXPR v1:vardecl e1:exprSingle[in_context()] > [_out_c_] {st1:sequenceType})
	    <<#declareVar=#(#["declare-global-var"], v1, e1, st1); >>
	 | #(AST_VAR_DECL_EXT v2:vardecl {st2:sequenceType})
	    <<#declareVar=#(#["declare-external-var"], v2, st2); >>
	)
;

emptyOrderDecl!:
	(   AST_DEF_ORDER_EG
	    <<#emptyOrderDecl= #(#["declare-default-order"], #(#["const"], #(#["type"], #["!xs!string"]), #["\"empty-greatest\""]));>>
	  |  AST_DEF_ORDER_EL
	    <<#emptyOrderDecl= #(#["declare-default-order"], #(#["const"], #(#["type"], #["!xs!string"]), #["\"empty-least\""]));>>
	)
;

importModule!:
	#(AST_IMPORT_MODULE l:AST_LOCAL_NAME s1:AST_STRING_CONST s2:AST_STRING_CONST
	<<#importModule=#(#["import-module"],
	                  #(#["const"], #(#["type"], #["!xs!NCName"]), #[std::string("\"")+std::string(l->getText())+ std::string("\"")]),
	                  #(#["const"], #(#["type"], #["!xs!string"]), #[std::string("\"")+std::string(s1->getText())+ std::string("\"")]),
	                  #(#["const"], #(#["type"], #["!xs!string"]), #[std::string("\"")+std::string(s2->getText())+ std::string("\"")]));>>
	 (s3:AST_STRING_CONST 
	<<#importModule->addChild(#(#["const"], #(#["type"], #["!xs!string"]), #[std::string("\"")+std::string(s3->getText())+ std::string("\"")]));>>)*)
;


