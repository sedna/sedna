    /*
        Please, in case of lexer changes, try to support 'no backing up' policy. In this case lexer can be much faster and smaller.

        To check if lexer must back up, generate it with: -b option. 'lex.backup' file will tell if you've got backing up lexer.
    */

%top{
/* We want this pronto:
    1) to avoid including unistd.h in CYGWIN since cl doesn't know about it
    2) to include stdint.h (libs/compat) in CYGWIN to avoid clashing with flex int definitions
*/
#ifdef _WIN32
    #define YY_NO_UNISTD_H 1
    #include <stdint.h>
#endif
}

%{
#include "XQueryDriver.h"
#include "XQueryLexer.h"
#include "XQueryParser.hpp"

#include "common/errdbg/exceptions.h"
#include "tr/executor/base/xs_helper.h"
#include "tr/executor/base/xs_names.h"

#include <string>

/* Work around an incompatibility in flex (at least versions
        2.5.31 through 2.5.33): it generates code that does
        not conform to C89.  See Debian bug 333231
        <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=333231>.  */
#undef yywrap
#define yywrap() 1

/* By default yylex returns int, we use token_type.
        Unfortunately yyterminate by default returns 0, which is
        not of token_type.  */
#define yyterminate() return token::END

typedef sedna::XQueryParser::token token;

    /* we want to manage locations for each rule here
       see interface for location structure in location.hh generated by Bison */
#define YY_USER_ACTION \
{ \
    int last_endl = -1;\
    \
    yylloc->step();\
    for (int i = 0; i < yyleng; i++) \
        if (yytext[i] == '\n')  \
        { \
            yylloc->lines(1);\
            last_endl = i;\
        }\
    \
    yylloc->columns(yyleng - last_endl - 1);\
    \
    yylval->isUpper = 0; \
}

#define IS_WS(c) (c == '\n' || c == '\r' || c== '\t' || c == ' ')

static std::string cdata_cont; // we accumulate CDATA content here

%}

%option noyywrap
%option c++
%option nounput
%option batch
%option nodefault
%option stack
%option 8bit
%option prefix="sedna"
%option outfile="XQueryLexer.cpp"

Digits [0-9]+
HexDigits [0-9a-fA-F]+
EscapeQuot "\"\""
EscapeApos "''"
PredefinedEntityRef "&"("lt"|"gt"|"amp"|"quot"|"apos")";"
CharRef "&#"({Digits}|("x"{HexDigits}))";"
WS [ \t\n\r]+

IntegerLiteral {Digits}
DecimalLiteral ("."{Digits})|({Digits}"."[0-9]*)
DoubleLiteral  (("."{Digits})|({Digits}("."[0-9]*)?))("e"|"E")("+"|"-")?{Digits}
StringLiteral ("\""({PredefinedEntityRef}|{CharRef}|{EscapeQuot}|[^"&])*"\"")|("'"({PredefinedEntityRef}|{CharRef}|{EscapeApos}|[^'&])*"'")

    /* we define \x80-\xFF here; actually we check for a valid UTF-8 NCName later, when NCName-pattern has been matched */
NCNameStartChar [a-zA-Z_\x80-\xFF]
NCNameChar ({NCNameStartChar}|[0-9]|[.\-])

NameStartChar [:a-zA-Z_\x80-\xFF]
NameChar ({NameStartChar}|[0-9]|[.\-])

Name {NameStartChar}{NameChar}*
NCName {NCNameStartChar}{NCNameChar}*
QName ({NCName}":")?{NCName}

Char [\x09\x0D\x0A\x20-\xFF]

    /* we duplicate Char definition below since flex doesn't understand {Char}{-} declaration */
AposAttrContentChar [\x09\x0D\x0A\x20-\xFF]{-}['{}<&]
QuotAttrContentChar [\x09\x0D\x0A\x20-\xFF]{-}["{}<&]
ElemContentChar [\x09\x0D\x0A\x20-\xFF]{-}[{}<&]

%x M_START_TAG
%x M_END_TAG
%x M_XML_COMMENT
%x M_PIS
%x M_PI_WS
%x M_PI_CONTENT
%x M_PRAGMA
%x M_PRAGMA_WS
%x M_PRAGMA_CONTENT
%x M_CDATA
%x M_XQUERY_COMM

%x M_COMP_CONST

%x M_APOS_CONT
%x M_QUOT_CONT
%x M_ELEM_CONT

%%

"-" { return token::MINUS; }
"+" { return token::PLUS; }
"," { return token::COMMA; }
";" { return token::SEMI; }
"::" { return token::AXIS; }
":=" { return token::ASSIGN; }
"!=" { return token::NE_SIGN; }
"?" { return token::QUEST; }
"/" { return token::SLASH; }
"//" { return token::SLASH_SLASH; }
"." { return token::DOT; }
".." { return token::DOT_DOT; }
"(" { return token::LPAREN; }
")" { return token::RPAREN; }
"[" { return token::LBRACK; }
"]" { return token::RBRACK; }
"@" { return token::ATSIGN; }
"$" { return token::DOLLAR; }
"*" { return token::STAR; }
"<<" { return token::PREC; }
">>" { return token::FOLLOW; }
"|" { return token::BAR; }
"<=" { return token::LE_SIGN; }
"=" { return token::EQ_SIGN; }
">" { return token::GT_SIGN; }
">=" { return token::GE_SIGN; }

"\n\\" {return token::ST_SEP; }

    /* made with: sed -e 's/\"\([^"]*\)\"/"\1" { return token::\U\1\E; }/' */

    /* standard XQuery keywords */
"ancestor" { return token::ANCESTOR; }
"ancestor-or-self" { return token::ANCESTOR_OR_SELF; }
"and" { return token::AND; }
"as" { return token::AS; }
"ascending" { return token::ASCENDING; }
"at" { return token::AT; }
    /* "attribute" { return token::ATTRIBUTE; } */
"base-uri" { return token::BASE_URI; }
"boundary-space" { return token::BOUNDARY_SPACE; }
"by" { return token::BY; }
"case" { return token::CASE; }
"cast" { return token::CAST; }
"castable" { return token::CASTABLE; }
"child" { return token::CHILD; }
"collation" { return token::COLLATION; }
"comment" { return token::COMMENT; }
"construction" { return token::CONSTRUCTION; }
"copy-namespaces" { return token::COPY_NAMESPACES; }
"declare" { return token::DECLARE; }
"default" { return token::DEFAULT; }
"descendant" { return token::DESCENDANT; }
"descendant-or-self" { return token::DESCENDANT_OR_SELF; }
"descending" { return token::DESCENDING; }
"div" { return token::DIV; }
"document" { return token::DOCUMENT; }
"document-node" { return token::DOCUMENT_NODE; }
    /* "element" { return token::ELEMENT; } */
"else" { return token::ELSE; }
"empty" { return token::EMPTY; }
"empty-sequence" { return token::EMPTY_SEQUENCE; }
"encoding" { return token::ENCODING; }
"eq" { return token::EQ; }
"every" { return token::EVERY; }
"except" { return token::EXCEPT; }
"external" { return token::EXTERNAL; }
"following" { return token::FOLLOWING; }
"following-sibling" { return token::FOLLOWING_SIBLING; }
"for" { return token::FOR; }
"function" { return token::FUNCTION; }
"ge" { return token::GE; }
"greatest" { return token::GREATEST; }
"gt" { return token::GT; }
"idiv" { return token::IDIV; }
"if" { return token::IF; }
"import" { return token::IMPORT; }
"in" { return token::_IN; }
"inherit" { return token::INHERIT; }
"instance" { return token::INSTANCE; }
"intersect" { return token::INTERSECT; }
"is" { return token::IS; }
"item" { return token::ITEM; }
"lax" { return token::LAX; }
"le" { return token::LE; }
"least" { return token::LEAST; }
"let" { return token::LET; }
"lt" { return token::LT; }
"mod" { return token::MOD; }
"module" { return token::MODULE; }
"namespace" { return token::NAMESPACE; }
"ne" { return token::NE; }
"node" { return token::NODE; }
"no-inherit" { return token::NO_INHERIT; }
"no-preserve" { return token::NO_PRESERVE; }
"of" { return token::OF; }
"option" { return token::OPTION; }
"or" { return token::OR; }
"order" { return token::ORDER; }
"ordered" { return token::ORDERED; }
"ordering" { return token::ORDERING; }
"parent" { return token::PARENT; }
"preceding" { return token::PRECEDING; }
"preceding-sibling" { return token::PRECEDING_SIBLING; }
"preserve" { return token::PRESERVE; }
    /* "processing-instruction" { return token::PROCESSING_INSTRUCTION; } */
"return" { return token::RETURN; }
"satisfies" { return token::SATISFIES; }
"schema" { return token::SCHEMA; }
"schema-attribute" { return token::SCHEMA_ATTRIBUTE; }
"schema-element" { return token::SCHEMA_ELEMENT; }
"self" { return token::SELF; }
"some" { return token::SOME; }
"stable" { return token::STABLE; }
"strict" { return token::_STRICT; }
"strip" { return token::STRIP; }
"text" { return token::TEXT; }
"then" { return token::THEN; }
"to" { return token::TO; }
"treat" { return token::TREAT; }
"typeswitch" { return token::TYPESWITCH; }
"union" { return token::UNION; }
"unordered" { return token::UNORDERED; }
"validate" { return token::VALIDATE; }
"variable" { return token::VARIABLE; }
"version" { return token::VERSION; }
"where" { return token::WHERE; }
"xquery" { return token::XQUERY; }

    /* Axis rules for 'axis':: Note that 'axis'<Space>:: is parsed normally. This is to avoid conflict with ({NCName}|"*")":"[:=] rule */
"child::" {
    yyless(yyleng - 2);
    return token::CHILD;
}

"descendant::" {
    yyless(yyleng - 2);
    return token::DESCENDANT;
}

"attribute::" {
    yyless(yyleng - 2);
    return token::ATTRIBUTE;
}

"self::" {
    yyless(yyleng - 2);
    return token::SELF;
}

"descendant-or-self::" {
    yyless(yyleng - 2);
    return token::DESCENDANT_OR_SELF;
}

"following-sibling::" {
    yyless(yyleng - 2);
    return token::FOLLOWING_SIBLING;
}

"following::" {
    yyless(yyleng - 2);
    return token::FOLLOWING;
}

"parent::" {
    yyless(yyleng - 2);
    return token::PARENT;
}

"ancestor::" {
    yyless(yyleng - 2);
    return token::ANCESTOR;
}

"preceding-sibling::" {
    yyless(yyleng - 2);
    return token::PRECEDING_SIBLING;
}

"preceding::" {
    yyless(yyleng - 2);
    return token::PRECEDING;
}

"ancestor-or-self::" {
    yyless(yyleng - 2);
    return token::ANCESTOR_OR_SELF;
}

    /* Sedna update extensions */
"all" { return token::ALL; }
"ALL" { yylval->isUpper = 1; return token::ALL; }
"after" { return token::AFTER; }
"AFTER" { yylval->isUpper = 1; return token::AFTER; }
"alter" { return token::ALTER; }
"ALTER" { yylval->isUpper = 1; return token::ALTER; }
"AS" { return token::AS_; }
"before" { return token::BEFORE; }
"BEFORE" { yylval->isUpper = 1; return token::BEFORE; }
"BY" { return token::BY_; }
"collection" { return token::COLLECTION; }
"COLLECTION" { yylval->isUpper = 1; return token::COLLECTION; }
"collections" { return token::COLLECTIONS; }
"COLLECTIONS" { yylval->isUpper = 1; return token::COLLECTIONS; }
"create" { return token::CREATE; }
"CREATE" { yylval->isUpper = 1; return token::CREATE; }
"database" { return token::DATABASE; }
"DATABASE" { yylval->isUpper = 1; return token::DATABASE; }
"delete" { return token::_DELETE; }
"DELETE" { yylval->isUpper = 1; return token::_DELETE; }
"delete_undeep" { return token::DELETE_UNDEEP; }
"DELETE_UNDEEP" { yylval->isUpper = 1; return token::DELETE_UNDEEP; }
"descriptive" { return token::DESCRIPTIVE; }
"DESCRIPTIVE" { yylval->isUpper = 1; return token::DESCRIPTIVE; }
"do" { return token::DO; }
"DO" { yylval->isUpper = 1; return token::DO; }
"DOCUMENT" { return token::DOCUMENT_; }
"documents" { return token::DOCUMENTS; }
"DOCUMENTS" { yylval->isUpper = 1; return token::DOCUMENTS; }
"drop" { return token::DROP; }
"DROP" { yylval->isUpper = 1; return token::DROP; }
"each" { return token::EACH; }
"EACH" { yylval->isUpper = 1; return token::EACH; }
"FOLLOWING" { return token::FOLLOWING_; }
"FOR" { return token::FOR_; }
"from" { return token::FROM; }
"FROM" { yylval->isUpper = 1; return token::FROM; }
"full-text" { return token::FULLTEXT; }
"FULL-TEXT" { yylval->isUpper = 1; return token::FULLTEXT; }
"grant" { return token::GRANT; }
"GRANT" { yylval->isUpper = 1; return token::GRANT; }
"IN"  { return token::IN_; }
"index" { return token::INDEX; }
"INDEX" { yylval->isUpper = 1; return token::INDEX; }
"into" { return token::INTO; }
"INTO" { yylval->isUpper = 1; return token::INTO; }
"insert" { return token::INSERT; }
"INSERT" { yylval->isUpper = 1; return token::INSERT; }
"load" { return token::LOAD; }
"LOAD" { yylval->isUpper = 1; return token::LOAD; }
"metadata" { return token::METADATA; }
"METADATA" { yylval->isUpper = 1; return token::METADATA; }
"MODULE" { return token::MODULE_; }
"move" { return token::MOVE; }
"MOVE" { yylval->isUpper = 1; return token::MOVE; }
"NODE" { return token::NODE_; }
"on" { return token::ON; }
"ON" { yylval->isUpper = 1; return token::ON; }
"OR" { return token::OR_; }
"password" { return token::PASSWORD; }
"PASSWORD" { yylval->isUpper = 1; return token::PASSWORD; }
"PRECEDING" { return token::PRECEDING_; }
"public" { return token::PUBLIC; }
"PUBLIC" { yylval->isUpper = 1; return token::PUBLIC; }
"rename" { return token::RENAME; }
"RENAME" { yylval->isUpper = 1; return token::RENAME; }
"replace" { return token::REPLACE; }
"REPLACE" { yylval->isUpper = 1; return token::REPLACE; }
"retrieve" { return token::RETRIEVE; }
"RETRIEVE" { yylval->isUpper = 1; return token::RETRIEVE; }
"revoke" { return token::REVOKE; }
"REVOKE" { yylval->isUpper = 1; return token::REVOKE; }
"role" { return token::ROLE; }
"ROLE" { yylval->isUpper = 1; return token::ROLE; }
"SCHEMA" { return token::SCHEMA_; }
"statement" { return token::STATEMENT; }
"STATEMENT" { yylval->isUpper = 1; return token::STATEMENT; }
"statistics" { return token::STATISTICS; }
"STATISTICS" { yylval->isUpper = 1; return token::STATISTICS; }
"stdin" { return token::STDIN; }
"STDIN" { yylval->isUpper = 1; return token::STDIN; }
"TO" { return token::TO_; }
"trigger" { return token::TRIGGER; }
"TRIGGER" { yylval->isUpper = 1; return token::TRIGGER; }
"type" { return token::TYPE; }
"TYPE" { yylval->isUpper = 1; return token::TYPE; }
"update" { return token::UPDATE; }
"UPDATE" { yylval->isUpper = 1; return token::UPDATE; }
"user" { return token::USER; }
"USER" { yylval->isUpper = 1; return token::USER; }
"with" { return token::WITH; }
"WITH" { yylval->isUpper = 1; return token::WITH; }


    /* element, attribute and processing-instruction are ambiguous in LALR(1)-sense since we need 2-token lookahead ('attribute or 2' is synt. valid)
            we perform it using lookahead in next_token function, which is called as a scanner from parser*/
"element" { BEGIN M_COMP_CONST; return token::ELEMENT; }
"attribute" { BEGIN M_COMP_CONST; return token::ATTRIBUTE; }
"processing-instruction" { BEGIN M_COMP_CONST; return token::PROCESSING_INSTRUCTION; }

<M_COMP_CONST>({QName}{WS}"{")|({QName}"{") {
    BEGIN INITIAL;

    int i;

    for (i = 0; i <= yyleng; i++)
        if (IS_WS(yytext[i]) || yytext[i] == '{') break;

    if ((yylval->qname = xqMakeQName(yylloc, yytext, i)) == NULL)
        return token::_ERROR_;

    yyless(yyleng - 1); // return '{'

    return token::COMP_CONST_QNAME;
}

<M_COMP_CONST>{WS} { /* skip whitespaces */ }

<M_COMP_CONST>{NCName}":"|{QName}{WS}|{QName}|. {
    BEGIN INITIAL;
    yyless(0);
}

{IntegerLiteral} {
    yylval->littext = xqMakeNumLiteral(yylloc, yytext, yyleng);
    return token::IntegerLiteral;
}

{DecimalLiteral} {
    yylval->littext = xqMakeNumLiteral(yylloc, yytext, yyleng);
    return token::DecimalLiteral;
}
{DoubleLiteral} {
    yylval->littext = xqMakeNumLiteral(yylloc, yytext, yyleng);
    return token::DoubleLiteral;
}
{StringLiteral} {
    if ((yylval->littext = xqMakeStrLiteral(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;

    return token::StringLiteral;
}

    /* this solves 10div 3 related problems */
({IntegerLiteral}|{DoubleLiteral}|{DecimalLiteral})[a-zA-Z\x80-\xFF] {
    driver.error(*yylloc, XPST0003, "numeric literal must be followed by a separator");
    return token::_ERROR_;
}

{NCName}":*" {
    if ((yylval->qname = xqMakeQName(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;

    return token::PREF_WCARD;
}

"*:"{NCName} {
    if ((yylval->qname = xqMakeQName(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;
    return token::WCARD_LOC;
}

{QName} {
    if ((yylval->qname = xqMakeQName(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;
    return token::QNAME;
}

{WS} {
    /* do nothing for WS in initial state */
}

"{"         { yy_push_state(INITIAL); return token::LBRACE; }
"}"         {

    if (yy_start_stack_ptr > 0)
        yy_pop_state();

    return token::RBRACE;
}

"<"         { yy_push_state(M_START_TAG); return token::LT_OR_ST; }
"<!--"      { yy_push_state(M_XML_COMMENT); return token::XML_COMM_BEG; }
"<?"        { yy_push_state(M_PIS); return token::PI_START; }
"(#"        { yy_push_state(M_PRAGMA); return token::PRAGMA_BEG; }
"<![CDATA[" { cdata_cont = ""; yy_push_state(M_CDATA); return token::CDATA_BEG; }
"(:"        { yy_push_state(M_XQUERY_COMM); } /* won't return anything here since comments are ignored */

    /* This state corresponds to start tag in xquery direct constructor */

<M_START_TAG>{QName} {
    if ((yylval->qname = xqMakeQName(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;
    return token::QNAME;
}

<M_START_TAG>{WS} { return token::S; }
<M_START_TAG>"="  { return token::EQ_SIGN; }
<M_START_TAG>"'"  {
    BEGIN M_APOS_CONT;
    return token::APOS;
}
<M_START_TAG>"\"" {
    BEGIN M_QUOT_CONT;
    return token::QUOT;
}
<M_START_TAG>"/>" {
    yy_pop_state();
    return token::EMPTY_TAG;
}
<M_START_TAG>">" {
    BEGIN M_ELEM_CONT;
    return token::START_TAG_END;
}

    /* This state corresponds to apos attribute content */

<M_APOS_CONT>"'"  { BEGIN M_START_TAG; return token::APOS; }
<M_APOS_CONT>{PredefinedEntityRef} { yylval->scont = xqDecodePredRef(yylloc, yytext, yyleng); return token::PREF; }
<M_APOS_CONT>{CharRef} {
    if ((yylval->scont = xqDecodeCharRef(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;
    return token::CREF;
}
<M_APOS_CONT>"{{" { return token::DOUB_LBRACE; }
<M_APOS_CONT>"}}" { return token::DOUB_RBRACE; }
<M_APOS_CONT>"{"  { yy_push_state(INITIAL); return token::LBRACE; }
<M_APOS_CONT>"''" { return token::ESCAPE_APOS; }
<M_APOS_CONT>{AposAttrContentChar}+ {
    if ((yylval->scont = xqMakeContent(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;
    return token::CHAR_CONT;
}

    /* This state corresponds to quot attribute content */

<M_QUOT_CONT>"\""  { BEGIN M_START_TAG; return token::QUOT; }
<M_QUOT_CONT>{PredefinedEntityRef} { yylval->scont = xqDecodePredRef(yylloc, yytext, yyleng); return token::PREF; }
<M_QUOT_CONT>{CharRef} {
    if ((yylval->scont = xqDecodeCharRef(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;
    return token::CREF;
}
<M_QUOT_CONT>"{{" { return token::DOUB_LBRACE; }
<M_QUOT_CONT>"}}" { return token::DOUB_RBRACE; }
<M_QUOT_CONT>"{"  { yy_push_state(INITIAL); return token::LBRACE; }
<M_QUOT_CONT>"\"\"" { return token::ESCAPE_QUOT; }
<M_QUOT_CONT>{QuotAttrContentChar}+ {
    if ((yylval->scont = xqMakeContent(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;
    return token::CHAR_CONT;
}

    /* This state corresponds to element content */
<M_ELEM_CONT>{ElemContentChar}+ {
    if ((yylval->scont = xqMakeContent(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;
    return token::CHAR_CONT;
}
<M_ELEM_CONT>"<![CDATA[" { cdata_cont = ""; yy_push_state(M_CDATA); return token::CDATA_BEG; }
<M_ELEM_CONT>{PredefinedEntityRef} { yylval->scont = xqDecodePredRef(yylloc, yytext, yyleng); return token::PREF; }
<M_ELEM_CONT>{CharRef} {
    if ((yylval->scont = xqDecodeCharRef(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;
    return token::CREF;
}
<M_ELEM_CONT>"{{" { return token::DOUB_LBRACE; }
<M_ELEM_CONT>"}}" { return token::DOUB_RBRACE; }
<M_ELEM_CONT>"{"  { yy_push_state(INITIAL); return token::LBRACE; }
<M_ELEM_CONT>"<!--" { yy_push_state(M_XML_COMMENT); return token::XML_COMM_BEG; }
<M_ELEM_CONT>"<?"   { yy_push_state(M_PIS); return token::PI_START; }
<M_ELEM_CONT>"<"    { yy_push_state(M_START_TAG); return token::LT_OR_ST; }
<M_ELEM_CONT>"</"   {
    BEGIN M_END_TAG;
    return token::END_TAG_OPEN;
}

    /* This state corresponds to closing of element (end-tag) content */

<M_END_TAG>{QName} {
    if ((yylval->qname = xqMakeQName(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;
    return token::QNAME;
}
<M_END_TAG>{WS} { return token::S; }
<M_END_TAG>">"  { yy_pop_state(); return token::END_TAG_CLOSE; }

    /* This state corresponds to XML comment content */

<M_XML_COMMENT>{Char} { yymore(); }
<M_XML_COMMENT>"-->" {
    if ((yylval->scont = xqMakeContent(yylloc, yytext, yyleng-3)) == NULL)
        return token::_ERROR_;

    yy_pop_state();
    return token::XML_CONT_WITH_END;
}

    /* These states correspond to PI content */

<M_PIS>{Name} { BEGIN M_PI_WS; yylval->qname = xqMakePITarget(yylloc, yytext, yyleng); return token::PI_TARGET; }

<M_PI_WS>{WS} { BEGIN M_PI_CONTENT; }
<M_PI_WS>"?>" { BEGIN M_PI_CONTENT; yyless(0); }

<M_PI_CONTENT>{Char} { yymore(); }
<M_PI_CONTENT>"?>" {
    if ((yylval->scont = xqMakeContent(yylloc, yytext, yyleng-2)) == NULL)
        return token::_ERROR_;

    yy_pop_state();
    return token::PI_CONT_WITH_END;
}

    /* These states correspond to Pragma content */

<M_PRAGMA>{QName} {
    BEGIN M_PRAGMA_WS;

    if ((yylval->qname = xqMakeQName(yylloc, yytext, yyleng)) == NULL)
        return token::_ERROR_;
    return token::QNAME;
}
<M_PRAGMA>{WS} { /* do nothing */ }

<M_PRAGMA_WS>{WS} { BEGIN M_PRAGMA_CONTENT; }
<M_PRAGMA_WS>"#)" { BEGIN M_PRAGMA_CONTENT; yyless(0); }

<M_PRAGMA_CONTENT>{Char} { yymore(); }
<M_PRAGMA_CONTENT>"#)" {
    if ((yylval->scont = xqMakeContent(yylloc, yytext, yyleng-2)) == NULL)
        return token::_ERROR_;

    yy_pop_state();
    return token::PRAGMA_CONT_WITH_END;
}

    /* This state corresponds to CDATA content */

<M_CDATA>{Char} { yymore(); }
<M_CDATA>"]]" {
    cdata_cont += std::string(yytext, yyleng-1);
    yyless(yyleng-1); /* return one ']' since we want to take by one; consider 'a]]]>' as an example */
}

<M_CDATA>"]]>" {
    cdata_cont += std::string(yytext, yyleng-3);
    if ((yylval->scont = xqMakeContent(yylloc, cdata_cont.c_str(), cdata_cont.size())) == NULL)
        return token::_ERROR_;

    yy_pop_state();
    return token::CDATA_CONT_WITH_END;
}

<M_XQUERY_COMM>"(:" { yy_push_state(M_XQUERY_COMM); }
<M_XQUERY_COMM>{Char} { yymore(); }
<M_XQUERY_COMM>":)" {
    yy_pop_state();

    /* we should check if comment consists of Chars only */
    if (!xqCheckComment(yylloc, yytext, yyleng-2))
        return token::_ERROR_;
}

<M_XQUERY_COMM><<EOF>> {
    driver.error(*yylloc, XPST0003, "unclosed XQuery comment");
    return token::END;
}

    /* These rules are error rules to avoid backing up to default rule */

    /* "catch all" rule for attribute content to avoide backing up */
<M_QUOT_CONT,M_APOS_CONT,M_ELEM_CONT,M_START_TAG,M_END_TAG>. {
    std::string err = std::string("unexpected symbol in constructor: '") + std::string(yytext, yyleng) + "'";
    driver.error(*yylloc, XPST0003, err.c_str());
    return token::_ERROR_;
}

<M_QUOT_CONT,M_APOS_CONT,M_ELEM_CONT>"&"[^;]* {
    driver.error(*yylloc, XPST0003, "invalid reference or entity");
    return token::_ERROR_;
}

<M_XML_COMMENT>. {
    std::string err = std::string("unexpected symbol in XML comment: '") + std::string(yytext, yyleng) + "'";
    driver.error(*yylloc, XPST0003, err.c_str());
    return token::_ERROR_;
}

<M_XML_COMMENT>"--" {
    driver.error(*yylloc, XPST0003, "-- is not allowed in XML comment");
    return token::_ERROR_;
}

<M_PIS,M_PI_WS>.|\n {
    driver.error(*yylloc, XPST0003, "invalid processing instruction name");
    return token::_ERROR_;
}

<M_PI_CONTENT>. {
    std::string err = std::string("unexpected symbol in processing instruction: '") + std::string(yytext, yyleng) + "'";
    driver.error(*yylloc, XPST0003, err.c_str());
    return token::_ERROR_;
}

<M_PRAGMA,M_PRAGMA_CONTENT>. {
    std::string err = std::string("unexpected symbol in pragma: '") + std::string(yytext, yyleng) + "'";
    driver.error(*yylloc, XPST0003, err.c_str());
    return token::_ERROR_;
}

<M_CDATA>. {
    std::string err = std::string("unexpected symbol in CDATA: '") + std::string(yytext, yyleng) + "'";
    driver.error(*yylloc, XPST0003, err.c_str());
    return token::_ERROR_;
}

<M_XQUERY_COMM>. {
    std::string err = std::string("unexpected symbol in comment: '") + std::string(yytext, yyleng) + "'";
    driver.error(*yylloc, XPST0003, err.c_str());
    return token::_ERROR_;
}

    /* "catch all" rule for string literal */
("\""([^"]|{EscapeQuot})*"\""?)|("'"([^']|{EscapeApos})*"'"?) {
    driver.error(*yylloc, XPST0003, "invalid string literal");
    return token::_ERROR_;
}

(("."{Digits})|({Digits}("."[0-9]*)?))("e"|"E")("+"|"-")? {
    driver.error(*yylloc, XPST0003, "invalid double literal");
    return token::_ERROR_;
}

    /* This rule deals with situations like a:=5 or a::b (to eliminate backing and to be consistent with the next rule) */
<INITIAL,M_START_TAG,M_END_TAG,M_PRAGMA>({NCName}|"*")":"[:=] {
    if ((yylval->qname = xqMakeQName(yylloc, yytext, yyleng-2)) == NULL)
        return token::_ERROR_;

    yyless(yyleng-2); // return :: or :=
    return token::QNAME;
}

<INITIAL,M_START_TAG,M_END_TAG,M_PRAGMA>({NCName}|"*")":" {
    driver.error(*yylloc, XPST0003, "invalid QName or wildcard");
    return token::_ERROR_;
}

<INITIAL,M_ELEM_CONT>"<!"("-"|"["|"[C"|"[CD"|"[CDA"|"[CDAT"|"[CDATA")? {
    driver.error(*yylloc, XPST0003, "unknown construction in query");
    return token::_ERROR_;
}

<M_PRAGMA_WS>. {
    driver.error(*yylloc, XPST0003, "invalid pragma (check for separator between QName and content)");
    return token::_ERROR_;
}

    /* "catch all" rule for the initial state */

. {
    std::string err = std::string("unexpected symbol: '") + std::string(yytext, yyleng) + "'";
    driver.error(*yylloc, XPST0003, err.c_str());
    return token::_ERROR_;
}

%%

/* Here goes various helper-function to deal with XQuery and Sedna quirks */
using namespace sedna;

// function that creates numeric literal
//
// Parameters:
//      yylloc -- location
//      text -- StringLiteral string
//      len -- its length
//
// Returns:
//      string to replace StringLiteral
//
std::string *XQueryLexer::xqMakeNumLiteral(XQueryParser::location_type *yylloc, const char *text, int len)
{
    std::string *res;

    res = new std::string(text, len);

    return res;
}

// Helper function that scans str and replaces all 'find' with 'repl' beginning with start_pos and ending with end_pos
static void find_replace_str(std::string *str, const char *find, const char *repl, unsigned int start_pos, unsigned int end_pos)
{
    unsigned int pos = start_pos;

    while (pos <= end_pos)
    {
        pos = str->find(find, pos);

        if (pos == std::string::npos) break;

        if (pos <= end_pos)
        {
            str->replace(pos, strlen(find), repl);
            pos += strlen(repl);
            end_pos += (strlen(repl) - strlen(find));
        }
    }

    return;
}

// Decodes predefined entity to a usual string
//
// Parameters:
//      yylloc -- location
//      text -- StringLiteral string
//      len -- its length
//
// Returns:
//      string to replace StringLiteral
//
std::string *XQueryLexer::xqDecodePredRef(XQueryParser::location_type *loc, const char *text, int len)
{
    if (!strncmp(text, "&lt;", len))
        return new std::string("<");
    else if (!strncmp(text, "&gt;", len))
        return new std::string(">");
    else if (!strncmp(text, "&amp;", len))
        return new std::string("&");
    else if (!strncmp(text, "&quot;", len))
        return new std::string("\"");
    else if (!strncmp(text, "&apos;", len))
        return new std::string("\'");
    else
    {
        driver.error(*loc, XPST0003, "invalid predefined entity");
        return NULL;
    }
}

// Decodes char reference entity to a usual string
// This function doesn't check validity of reference and assumes that it is in format &#xxx; with &#; as mininmum
//
// Parameters:
//      yylloc -- location
//      text -- StringLiteral string
//      len -- its length
//
// Returns:
//      string to replace StringLiteral
//
std::string *XQueryLexer::xqDecodeCharRef(XQueryParser::location_type *loc, const char *text, int len)
{
    std::string ref;
    int code;

    if (text[2] == 'x') // hex ref
    {
        ref = std::string(&text[3], len - 4);

        code = strtol(ref.c_str(), NULL, 16);
    }
    else // dec ref
    {
        ref = std::string(&text[2], len - 3);

        code = atoi(ref.c_str());
    }

    // check for validity to XML 1.1
    if (!isXML10Valid(code))
    {
        driver.error(*loc, XQST0090, NULL);
        return NULL;
    }

    return new std::string(utf8_encode_char(code));
}

// Function that creates string literal
// Modifies StringLiteral
//      -- escapes " with \"
//      -- replaces charrefs ant predef entities
//      -- replaces '' xor "" with ' xor "
//
// Parameters:
//      yylloc -- location
//      text -- StringLiteral string
//      len -- its length
//
// Returns:
//      string to replace StringLiteral
//
std::string *XQueryLexer::xqMakeStrLiteral(XQueryParser::location_type *loc, const char *text, int len)
{
    std::string res, *repl;
    bool isQuoted = (text[0] == '"');
    unsigned int pos, pos2;
    std::string find;

    res = std::string(text + 1, len - 2); // strip boundary " or '

    // first, we want to decode all Predefined Entities and char-refs

    // normalize eol
    if (res.size() >= 1)
    {
        for (unsigned int i = 0; i < res.size() - 1; i++)
        {
            if (res[i] == 0x0D && res[i + 1] == 0x0A)
                res.replace(i, 2, "\x0A");
            else if (res[i] == 0x0D)
                res[i] = 0x0A;
        }
        if (res[res.size() - 1] == 0x0D) res[res.size() - 1] = 0x0A;
    }

    pos = 0;
    while (true)
    {
        pos = res.find("&", pos);
        if (pos == std::string::npos) break;

        pos2 = res.find(";", pos);
        if (pos == std::string::npos)
        {
            loc->begin.columns(pos);
            driver.error(*loc, XPST0003, (res[pos+1] == '#') ? "unclosed CharRef" : "unclosed Predefined Entity");
            loc->begin -= pos;
            return NULL;
        }

        find = res.substr(pos, pos2 - pos + 1);

        if (res[pos + 1] == '#')
        {
            repl = xqDecodeCharRef(loc, find.c_str(), find.size());
        }
        else
        {
            repl = xqDecodePredRef(loc, find.c_str(), find.size());
        }

        if (repl != NULL)
        {
            res.replace(pos, find.size(), repl->c_str());
            pos += repl->size();
            delete repl;
        }
        else
        {
            // error is already set by xqDecodeXXX
            return NULL;
        }
    }

    // Then, we must get rid of double-quotes and double-apos depending on str type
    find_replace_str(&res, (isQuoted) ? "\"\"" : "''", (isQuoted) ? "\"" : "'", 0, res.size() - 1);

    // then escape back-slashes
    find_replace_str(&res, "\\", "\\\\", 0, res.size() - 1);

    // then escape quotes
    find_replace_str(&res, "\"", "\\\"", 0, res.size() - 1);

    // do we need to escape apos as well for Scheme part?

    // quotate string regarding of type
    res.insert(0, "\"");
    res.append("\"");
//    res[0] = res[res.size() - 1] = '"';

    // finally, check if string contains only valid Chars
    char_iterator_utf8 cont_it(const_cast<char *>(res.c_str()), res.size(), 0);

    while (!cont_it.at_end())
    {
        if (!isXML10Valid(*cont_it))
        {
            driver.error(*loc, XPST0003, "invalid character in string literal");
            return false;
        }

        cont_it++;
    }

    return new std::string(res);
}

// this function checks that QName consists of valid characters as defined by XQuery spec
//
// Parameters:
//      yylloc -- location
//      text -- StringLiteral string
//      len -- its length
//
// Returns:
//      string to replace StringLiteral
//
std::string *XQueryLexer::xqMakeQName(XQueryParser::location_type *loc, const char *text, int len)
{
    int col_pos = 0; // colon position

    while (col_pos <= len && text[col_pos] != ':') col_pos++;

    if (col_pos >= len) col_pos = -1;

    if (col_pos != -1) // NCName:NCName
    {
        // check prefix ('*' is normal as a wildcard)
        if (text[0] != '*' && !check_constraints_for_xs_NCName(text, col_pos))
        {
            driver.error(*loc, XPST0003, "invalid QName (invalid NCName character)");
            return NULL;
        }
    }

    // check local part ('*' is normal as a wildcard)
    if (text[col_pos + 1] != '*' && !check_constraints_for_xs_NCName(text + col_pos + 1, len - col_pos - 1))
    {
        driver.error(*loc, XPST0003, "invalid QName (invalid NCName character)");
        return NULL;
    }

    return new std::string(text, len);
}

// checks content for valid XML 1.1 characters
//
// Parameters:
//      yylloc -- location
//      text -- StringLiteral string
//      len -- its length
//
// Returns:
//      string to replace StringLiteral
//
std::string *XQueryLexer::xqMakeContent(XQueryParser::location_type *loc, const char *text, int len)
{
    std::string res(text, len);

    // normalize eol
    if (res.size() >= 1)
    {
        for (unsigned int i = 0; i < res.size() - 1; i++)
        {
            if (res[i] == 0x0D && res[i + 1] == 0x0A)
                res.replace(i, 2, "\x0A");
            else if (res[i] == 0x0D)
                res[i] = 0x0A;
        }
        if (res[res.size() - 1] == 0x0D) res[res.size() - 1] = 0x0A;
    }

    char_iterator_utf8 cont_it(const_cast<char *>(text), len, 0);

    while (!cont_it.at_end())
    {
        if (!isXML10Valid(*cont_it))
        {
            driver.error(*loc, XPST0003, "invalid character in content");
            return NULL;
        }

        cont_it++;
    }

    // escape back-slashes
    find_replace_str(&res, "\\", "\\\\", 0, res.size() - 1);

    // then escape quotes
    find_replace_str(&res, "\"", "\\\"", 0, res.size() - 1);

    return new std::string(res);
}

// check if pi-target is valid; it must consist of valid Name chars
//
// Parameters:
//      yylloc -- location
//      text -- StringLiteral string
//      len -- its length
//
// Returns:
//      string to replace StringLiteral
//
std::string *XQueryLexer::xqMakePITarget(XQueryParser::location_type *loc, const char *text, int len)
{
    if (!check_constraints_for_xs_Name(text, len))
    {
        driver.error(*loc, XPST0003, "invalid PI target (invalid Name character)");
        return NULL;
    }

    return new std::string(text, len);
}

// Checks if XQuery comment consist of valid characters; XQuery spec explicitly says that it must be sequence of Chars
//
// Parameters:
//      yylloc -- location
//      text -- StringLiteral string
//      len -- its length
//
// Returns:
//      true - ok; false - invalid character;
//
bool XQueryLexer::xqCheckComment(XQueryParser::location_type *loc, const char *text, int len)
{
    char_iterator_utf8 cont_it(const_cast<char *>(text), len, 0);

    while (!cont_it.at_end())
    {
        if (!isXML10Valid(*cont_it))
        {
            driver.error(*loc, XPST0003, "invalid character in XQuery comment");
            return false;
        }

        cont_it++;
    }

    return true;
}

void XQueryLexer::xqDiscardConstructor()
{
    yy_pop_state();
}

// function that returns token for the parser
XQueryParser::token_type XQueryLexer::nextToken(XQueryParser::semantic_type* yylval, XQueryParser::location_type* yylloc)
{
    XQueryParser::token_type res;

    if (have_la)
    {
        *yylval = la_lval;
        *yylloc = la_lloc;
        res = la_tok;
        have_la = false;
    }
    else
    {
        res = yylex(yylval, yylloc);
    }

/*
    // lookahead fix for element(attribute, processing-instruction) qname ('element' or is valid)
    // so, we look for '{' after 'element qname'; if it is '{' then we return COMP_CONST_QNAME and parser will reduce it to computed constructor eventually
    // else we return just QNAME
    if ((prev_tok == token::ELEMENT || prev_tok == token::ATTRIBUTE || prev_tok == token::PROCESSING_INSTRUCTION) && res == token::QNAME)
    {
        have_la = true;
        la_tok = yylex(&la_lval, &la_lloc);

        if (la_tok == token::LBRACE)
            res = token::COMP_CONST_QNAME;
        else
            yyless(0);
    }*/
    // Another fix for 'xquery version ...'; we want to return token::XQUERY only when it may be a part of versionDecl
    if (res == token::XQUERY)
    {
        have_la = true;
        la_tok = yylex(&la_lval, &la_lloc);

        if (la_tok != token::VERSION)
        {
            res = token::QNAME;
            yylval->qname = new std::string("xquery");
        }
    }
    // Another fix for 'module namespace ...'; we want to return token::MODULE only when it may be a part of moduleDecl
    else if (res == token::MODULE)
    {
        have_la = true;
        la_tok = yylex(&la_lval, &la_lloc);

        if (la_tok != token::NAMESPACE && prev_tok != token::IMPORT && prev_tok != token::LOAD && prev_tok != token::REPLACE && prev_tok != token::DROP)
        {
            res = token::QNAME;
            yylval->qname = new std::string("module");
        }
    }

    prev_tok = res;

    return res;
}

int sednaFlexLexer::yylex()
{
    throw SYSTEM_EXCEPTION("sednaFlexLexer::yylex is called!");

    return 0;
}
