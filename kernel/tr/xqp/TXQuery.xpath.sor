/**/

relativePathExpr![in_context in_c] >[out_context out_c]:
	<<SORASTBase *test=NULL;>>
	#(AST_RELATIVE_PATH 
	  (
	    <<kt=NULL; nt=NULL;>>
	    #(AST_AXIS_PATH_STEP 
	      #(AST_STEP 
	        #(AST_AXIS a:axis)
	        #(AST_TEST (kt:kindTest |
	                    nt:nameTest)))

	      p1:predicates[in_c] >[out_c]
	     )
	     
	   <<if(#relativePathExpr==NULL) //the begin of relative path
	        #relativePathExpr=#(#["var"], #(#["\"\""], #["\"$%v\""]));
	     
	     //init test
	     if(kt!=NULL) //when test is kindTest
	        test=#(#["type"], kt);
	     else //when test is nameTest
	        if(std::string(a->getText())=="attr-axis") //test for attribute axis
	        {
	           test=#(#["type"], #(#["attr-test"], nt));
	        }
	        else //test for other axis
	           test=#(#["type"], #(#["elem-test"], nt));

	     //construct relativePath
	     if(p1 == NULL)//step without predicates
	       #relativePathExpr=
	            #(#["ddo"],
	              #(a, #relativePathExpr, test));
	     else //step with predicates
	     {

			 SORASTBase* it;
			 SORASTBase* inner_preds = 
   	                  #(#["predicate"], 
				        #(a, #(#["var"], #(#["\"\""], #["\"$%v\""])), test),
	                    #(#["fun-def"], #(#[], #(#["!xs!anyType"], #(#["var"], #(#["\"\""], #["\"$%v\""])))),
			              (SORAST*)(p1->down()->down())));

	 		 for (it = p1->down()->right(); it != NULL; it = it->right())
			      inner_preds = 
   	                  #(#["predicate"], 
				        inner_preds,
	                    #(#["fun-def"], #(#[], #(#["!xs!anyType"], #(#["var"], #(#["\"\""], #["\"$%v\""])))),
			              (SORAST*)(it->down())));

	         #relativePathExpr=
	              #(#["ddo"],
	                #(#["return"], 
			          #relativePathExpr,

	                  #(#["fun-def"], 
	                    #(#[], #(#["!xs!anyType"], #(#["var"], #(#["\"\""], #["\"$%v\""])))),
			            inner_preds))); 
	     }

	   >>
	  
	   |
	    #(AST_FILTER_PATH_STEP 
	      pe:primaryExpr[in_c] >[out_c]
	      p2:predicates[in_c] >[out_c]
	     ) 

	    <<if(#relativePathExpr == NULL) // the begin of the path
	      {
	        if(p2 == NULL) //the begin of relative path without predicate
	        {
	          #relativePathExpr=pe;
	        }
	        else
	        {
			    SORASTBase* it;
			    SORASTBase* inner_preds = 
   	                  #(#["predicate"], 
				        pe,
	                    #(#["fun-def"], #(#[], #(#["!xs!anyType"], #(#["var"], #(#["\"\""], #["\"$%v\""])))),
			              (SORAST*)(p2->down()->down())));

	 		    for (it = p2->down()->right(); it != NULL; it = it->right())
			      inner_preds = 
   	                  #(#["predicate"], 
				        inner_preds,
	                    #(#["fun-def"], #(#[], #(#["!xs!anyType"], #(#["var"], #(#["\"\""], #["\"$%v\""])))),
			              (SORAST*)(it->down())));

	            #relativePathExpr= inner_preds;
	        } 
	      }
	      else //relativePathExpr != NULL
	      {
            if (p2 == NULL)
            {
	           #relativePathExpr=
	                #(#["return"],
	                  #relativePathExpr,
	                  #(#["fun-def"], #(#[], #(#["!xs!anyType"], #(#["var"], #(#["\"\""], #["\"$%v\""])))), pe));	                   
                 
            }
            else
            {
			   SORASTBase* it;
			   SORASTBase* inner_preds = 
   	                  #(#["predicate"], 
				        pe,
	                    #(#["fun-def"], #(#[], #(#["!xs!anyType"], #(#["var"], #(#["\"\""], #["\"$%v\""])))),
			              (SORAST*)(p2->down()->down())));

			   for (it = p2->down()->right(); it != NULL; it = it->right())
			      inner_preds = 
   	                  #(#["predicate"], 
				        inner_preds,
	                    #(#["fun-def"], #(#[], #(#["!xs!anyType"], #(#["var"], #(#["\"\""], #["\"$%v\""])))),
			              (SORAST*)(it->down())));
				   


	           #relativePathExpr=
	             #(#["return"],
			        #relativePathExpr,
	                #(#["fun-def"], #(#[], #(#["!xs!anyType"], #(#["var"], #(#["\"\""], #["\"$%v\""])))), 
				      inner_preds));
			}
  	      }
	
	    >>


	  )* //multiple step
	)

;

predicates![in_context in_c] >[out_context out_c]:
	<<SORASTBase *pred=NULL;>>

	#(AST_PREDICATES (e:expr[in_c] >[out_c]
	                  <<if(pred==NULL) pred=#(#[], #(#[], e));
	                    else pred->addChild(#(#[], e));
	                  >>
	                 )*
	 )
	 <<#predicates=pred;>>
;
/*
step:!
	(  #(AST_AXIS_PATH_STEP 

	     #(AST_STEP #(AST_AXIS axis) #(AST_TEST (kindTest | nameTest))))
	)

	 | #(AST_FILTER_PATH_STEP)
	)
;


forwardStep:!
	#(AST_FORWARD_STEP 
	  #(AST_AXIS axis)
	  #(AST_TEST (kindTest | nameTest)))
;

reverseStep:!
	#(AST_REVERSE_STEP 
          #(AST_AXIS raxis)
          #(AST_TEST (kindTest | nameTest)))
;	
*/


axis!:
	(  AST_CHILD_AXIS               <<#axis=#["child"];>>
	 | AST_DESCENDANT_AXIS          <<#axis=#["descendant"];>>
	 | AST_ATTRIBUTE_AXIS           <<#axis=#["attr-axis"];>>
	 | AST_SELF_AXIS                <<#axis=#["self"];>>
	 | AST_DESCENDANT_OR_SELF_AXIS  <<#axis=#["descendant-or-self"];>>
	 | AST_FOLLOWING_SIBLING_AXIS   <<#axis=#["following-sibling"];>>
	 | AST_FOLLOWING_AXIS           <<#axis=#["following"];>>   
	 | AST_PARENT_AXIS              <<#axis=#["parent"];>>
	 | AST_ANCESTOR_AXIS            <<#axis=#["ancestor"];>>
	 | AST_PRECEDING_SIBLING_AXIS   <<#axis=#["preceding-sibling"];>>
	 | AST_PRECEDING_AXIS           <<#axis=#["preceding"];>>
	 | AST_ANCESTOR_OR_SELF_AXIS    <<#axis=#["ancestor-or-self"];>>
	)
; 


test!:
	(  kindt:kindTest <<#test=kindt;>>
	 | nt:nameTest    <<#test=nt;>>
	)
;

nameTest!:
	(  qn:qname  
	   <<#nameTest=#(#["ename"], 
                         #(#["const"], #(#["type"], #["!xs!QName"]), qn),
                         #(#["type"], #["*"]),
	                 #(#["const"], #(#["type"], #["!xs!string"]), #["\"non-nil\""]));
	   >>
	 | w:wildcard
	   <<#nameTest=#(#["ename"], 
                         #(#["const"], #(#["type"], #["!xs!QName"]), w),
                         #(#["type"], #["*"]),
	                 #(#["const"], #(#["type"], #["!xs!string"]), #["\"non-nil\""]));
	   >>
	   
	)
;

wildcard!:
	#(AST_WILDCARD {p:AST_PREFIX l:AST_LOCAL_NAME})
	<<
	  if (p == NULL && l == NULL)
	  {
	     #wildcard=#["*"];
	  }
	  else
	  { 
	     if (std::string(p->getText()) == "*")
	        #wildcard=#(#["*"], #[std::string("\"")+std::string(l->getText())+"\""]);
	     else
	     if (std::string(l->getText()) == "*")
	        #wildcard=#(#[std::string("\"")+std::string(p->getText())+"\""], #["*"]);
	     else
	        throw USER_ENV_EXCEPTION("unknown wildcard", false);
	     
	       
	  }
	>>
;

primaryExpr![in_context in_c] >[out_context out_c]:
	<<SORASTBase* f_params=NULL;
	>>

	(  v:vardecl
	   <<#primaryExpr=v; >>
	 | l:literal
	   <<#primaryExpr=l; >> 	
	 | e:expr[in_c] >[out_c]    <<#primaryExpr=e;>>

	 | AST_CONTEXT_ITEM  
	   <<#primaryExpr=#(#["var"], #(#["\"\""], #["\"$%v\""])); >>

	 | AST_EMPTY_SEQUENCE
	   <<#primaryExpr=#(#[], #["sequence"]); >>

	 | #(AST_FCALL qn:qname 
             (e:exprSingle[in_c] >[out_c] 
	      <<if(f_params == NULL)
	        { 
	           f_params=e;
	        }
	        else 
	        {
	           f_params->append(e);
	        }
              >>
	     )*
	   )
	  <<
	    SORASTBase* prefix = qn;
	    SORASTBase* loc_name = qn->down();

/*	    
        if (std::string(((SORAST *)loc_name)->getText()) == "\"true\"")
        {
           #primaryExpr=#(#["const"], #(#["type"], #["!xs!boolean"]), #["true"]);
        }
        else
        if (std::string(((SORAST *)loc_name)->getText()) == "\"false\"")
        {
           #primaryExpr=#(#["const"], #(#["type"], #["!xs!boolean"]), #["false"]);
        }
        else
        {
*/
           #primaryExpr=#(#["fun-call"],
                          #(#["const"], #(#["type"], #["!xs!QName"]), qn),
                          f_params);
           
//        }
	
	  >>

	 | gc:gconstructor[in_c] >[out_c] <<#primaryExpr=gc;>>
//	 | ale:arithmLogicalExpr <<#primaryExpr=ale;>>
	)
;

literal!:
	  i:AST_INTEGER_CONST 
	  <<#literal=#(#["const"], #(#["type"], #["!xs!integer"]), #[i->getText()]);
	  >>

	| dec:AST_DECIMAL_CONST
	  <<#literal=#(#["const"], #(#["type"], #["!xs!decimal"]), #[dec->getText()]);
	  >>

	| d:AST_DOUBLE_CONST
	  <<#literal=#(#["const"], #(#["type"], #["!xs!double"]), #[d->getText()]);
	  >>

	| s:AST_STRING_CONST
	  <<
            std::string str=s->getText();
            str=str.substr(1, str.size()-2);
            str = std::string("\"") + str + std::string("\"");

            #literal=#(#["const"], #(#["type"], #["!xs!string"]), #[str.c_str()]);
	  >>
;