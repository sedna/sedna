% ProgGuide.tex: Sedna Programmer's Guide
% Copyright (C) 2010 ISP RAS
% The Institute for System Programming of the Russian Academy of Sciences

\documentclass[a4paper,12pt]{article}

\usepackage{alltt}         % Like verbatim but supports commands inside
\usepackage{theorem}
\newtheorem{note}{Note}    % To insert notes
\usepackage{multirow}      % Allows inserting tables
\usepackage{ifpdf}         % Package for conditionals in TeX
\newcommand{\TocAt}[6]{}   % To avoid processing \TocAt by LaTeX

\title{Sedna Programmer's Guide}
\date{}

% Switch for between PDF and other formats to generate bookmarks,
% pretty table of contents and set document's information in PDF
\ifpdf
  \usepackage[colorlinks=true, linkcolor=blue,
              citecolor=blue, urlcolor=blue,
              pdftex,                %%% hyper-references for pdflatex
              bookmarks=true,        %%% generate bookmarks ...
              bookmarksnumbered=true %%% ... with numbers
  ]{hyperref}
  \pdfadjustspacing=1
  \hypersetup{
	pdfauthor   = {Sedna Team},
	pdftitle    = {Sedna Programmer's Guide}
  }
\else
  \usepackage[colorlinks=true, linkcolor=blue,
			  citecolor=blue, urlcolor=blue]{hyperref}
\fi

% Use citemize environment to produce tightly packed lists
\newenvironment{citemize}
{\begin{itemize}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}}
{\end{itemize}}


%===============================================================================
%             Sedna Programmer's Guide: Client APIs: Java API
%===============================================================================
\begin{document}
\sloppy
\maketitle

\TocAt*{section,subsection,subsubsection}
\TocAt*{subsection,subsubsection}

\tableofcontents
\newpage

\section{Client Application Programming Interfaces}
The Sedna client application programming interfaces (APIs) provides programmatic
access to Sedna from client applications developed in host programming
languages. This section describes the client APIs distributed with Sedna.

\subsection{Java API}
The Java API provides programmatic access to XML data from the Java programming
language. Using the Java API, applications written in the Java can access one or
more databases of the Sedna DBMS and manipulate database data using the database
language described in Section \ref{sec:DBLang}.

Application working with the Sedna DBMS through the Java API operates with the
following notions of the Java API: session, transaction, statement, result.

\subsubsection{Sessions}
To start working with Sedna application has to open a session via establishing
an authenticated connection with the server. The Java API defines the
\verb!SednaConnection! interface to represent a session.

To open a session application uses static method \verb!getConnection! of the
\verb!DatabaseManager! class.

\small{
\begin{verbatim}
 SednaConnection getConnection(String url,
                               String DBName,
                               String user,
                               String password)
     throws DriverException
\end{verbatim}
}

Parameters:

\verb!url! - the name of the computer where the Sedna DBMS is running. This
parameter may contain a port number. If the port number is not specified, the
default port number (5050) is used.

\verb!DBName! - the name of the database to connect.

\verb!user! - user name.

\verb!password! - user password.

If the connection is established and authentication succeeds the method returns
an object that implements the \verb!SednaConnection! interface. Otherwise,
\verb!DriverException! is thrown.

Application can close session using the \verb!close! method of the
\verb!SednaConnection! interface.

\begin{verbatim}
 public void close() throws DriverException
\end{verbatim}

If the server does not manage to close connection properly the \verb!close!
method throws \verb!DriverException!.

The \verb!isClosed! method retrieves whether this connection has been closed or
not. A connection is closed if the method \verb!close! has been called on it or
if certain fatal errors have occurred.

\begin{verbatim}
 public boolean isClosed()
\end{verbatim}

Setting connection into debug mode allows getting debug information when XQuery
query fails due to some reason (see \ref{debug-mode} for details). To set the
connection into debug mode use \verb!setDebugMode! method of
\verb!SednaConnection! interface:

\begin{verbatim}
 public void setDebugMode(boolean debug)
\end{verbatim}

Parameters:

\verb!debug! - set to \verb!true! to turn debug mode on; set to \verb!false! to
turn debug mode off. Debug mode is off by default.

Sedna supports \verb!fn:trace! function for debugging purpose also (see
\ref{trace} for details). By default trace output is included into XQuery query
result. You can turn trace output on/off using \verb!setTraceOutput! method of
the \verb!SednaConnection! interface:

\begin{verbatim}
 public void setTraceOutput(boolean doTrace)
\end{verbatim}

Parameters:

\verb!doTrace! - set to \verb!true! to turn trace output on; set to \verb!false!
to turn trace output off. Trace output is on by default.


%===============================================================================
%                      Java API: Transactions Management
%===============================================================================
\subsubsection{Transactions Management}
Application can execute queries and updates against specified database only in
the scope of a transaction. That is, once a session has been opened, application
can begin a transaction, execute statements and commit (or rollback) this
transaction.

In the session transactions are processed sequentially. That is, application
must commit a begun transaction before beginning a new one.

To specify transaction boundaries application uses methods of the
\verb!SednaConnection! interface: \verb!begin!, \verb!commit!.

The \verb!begin! method begins a new transaction.

\begin{verbatim}
 public void begin() throws DriverException
\end{verbatim}

If the transaction has not begun successfully the \verb!begin! method throws
\verb!DriverException!.

The \verb!commit! method commits a transaction.

\begin{verbatim}
 public void commit() throws DriverException
\end{verbatim}

If the transaction has not been committed successfully the \verb!commit! method
throws \verb!DriverException!.

To rollback transaction the \verb!rollback! method is used.

\begin{verbatim}
 public void rollback() throws DriverException
\end{verbatim}

If the transaction has not been rollback successfully the \verb!rollback! method
throws \verb!DriverException!.

The Java API does not provide auto-commit mode for transactions. That is, every
transaction must be explicitly started (by means of \verb!begin!) and committed
(by means of \verb!commit!). If session is closed (by means of \verb!close!)
before a transaction committed, server does rollback for that transaction, and
\verb!close! throws \verb!DriverException!.


%===============================================================================
%                          Java API: Statements
%===============================================================================
\subsubsection{Statements}

The \verb!SednaStatement! interface provides methods for loading documents into
the database, executing statements of the database language defined in Section
\ref{sec:DBLang} and retrieving results that statements produce.
\verb!SednaStatement! object is created using the \verb!createStatement! method
of the \verb!SednaConnection! interface:

\begin{verbatim}
 public SednaStatement createStatement()
     throws DriverException
\end{verbatim}

\verb!SednaStatement! object may only be created on an open connection.
Otherwise, the \verb!createStatement! method throws \verb!DriverException!.

To load the document into the database use:

\begin{verbatim}
 public void loadDocument(InputStream in,
                          String doc_name)
     throws DriverException, IOException
\end{verbatim}

The \verb!in! parameter is an input stream to get the document from. The
\verb!doc_name! parameter is the name for this document in the database.

To load the document into the specified collection of the database use:

\begin{verbatim}
 public void loadDocument(InputStream in,
                          String doc_name,
                          String col_name)
     throws DriverException, IOException
\end{verbatim}

The \verb!in! parameter is an input stream to get the document from. The
\verb!doc_name! parameter is the name for this document in the database. The
\verb!col_name! parameter is the name of the collection to load the document
into.

To execute a statement the \verb!execute! methods of the \verb!SednaStatement!
are used.

\begin{verbatim}
 public boolean execute(String queryText)
     throws DriverException
\end{verbatim}

The \verb!queryText! parameter contains the text of the statement.

\begin{verbatim}
 public boolean execute(InputSteram in)
     throws DriverException
\end{verbatim}

The \verb!in! parameter is some input stream to read an XQuery statement from.

Some statements (such as XQuery statements or the retrieve metadata command)
produce the result. In case of such statements, the \verb!execute! methods
return true and the result can be obtained as described in Section
\ref{sec:results}. In case of statements that do not produce the result (such as
updates or bulk load), the \verb!execute! methods return false.

The results of XQuery queries to the Sedna DBMS can be represented either in XML
or SXML~\cite{paper:sxml}. To specify the type of the result use the following
extended versions of the \verb!execute! method:

\begin{verbatim}
 boolean execute(InputStream in,
                 ResultType resultType)
     throws DriverException, IOException;
\end{verbatim}

\begin{verbatim}
 boolean execute(String queryText,
                 ResultType resultType)
     throws DriverException, IOException;
\end{verbatim}

The \verb!resultType! parameter is either \verb!ResultType.XML! or
\verb!ResultType.SXML!.


%===============================================================================
%                             Java API: Results
%===============================================================================
\subsubsection{Results}
\label{sec:results}

The \verb!SednaSerializedResult! interface represents the result of the
statement evaluation. Application can obtain the result using the
\verb!getSerializedResult! method of the \verb!SednaStatement! interface.

\begin{verbatim}
 public SednaSerializedResult getSerializedResult()
\end{verbatim}

The result of the non-XQuery statement evaluation is retrieved as a sequence
with only one item, where the item is a string. For example, in case of the
retrieve descriptive schema command the result is a sequence with an item that
is a descriptive schema represented as a string. The result of the XQuery
statement evaluation is retrieved as a sequence of items, where every item is
represented as a string.

Application can use the \verb!next! methods of the \verb!SednaSerializedResult!
interface to iterate over the result sequence:

\begin{verbatim}
 public String next() throws DriverException
\end{verbatim}

The method returns an item of the result sequence as a string. If the sequence
has ended it returns null. It throws \verb!DriverException! in the case of
error.

\begin{verbatim}
 public int next(Writer writer) throws DriverException
\end{verbatim}

The method writes an item of the result sequence to some output stream using
\verb!writer!. It returns 0 if an item was retrieved and written successful, and
1 if the result sequence has ended. It throws \verb!DriverException! in the case
of error.

Please, notice, that in the current version of the Sedna DBMS application has to
execute statements and use the results of their execution sequentially. To
explain this note, suppose application execute a statement, obtains a result of
that statement execution and iterates over this result. If, after that,
application executes next statement, it cannot iterate over the result of the
previous statement any more.


%===============================================================================
%                           Java API: Exceptions
%===============================================================================
\subsubsection{Exceptions}

The \verb!DriverException! class provides information about errors that occur
while application works with the Sedna DBMS through the Java API.
\verb!DriverException! is also thrown when application loses its connection with
the server.


%===============================================================================
%                          Java API: Code Example
%===============================================================================
\subsubsection{Code Example}

In this section we provide an example program that uses the Java API to work
with Sedna DBMS. This application connects to the Sedna DBMS, opens a session.
The session consists of one transaction. Application loads data from the file
\verb!region.xml! and executes the XQuery statement. When statement is executed,
application drop the document, commits the transaction and closes the session.

\small{
\begin{verbatim}
import ru.ispras.sedna.driver.*;
class Client {
  public static void main(String args[]) {

    SednaConnection con = null;
    try {
      /* Get a connection */
      con = DatabaseManager.getConnection("localhost",
                                          "testdb",
                                          "SYSTEM",
                                          "MANAGER");

      /* Begin a new transaction */
      con.begin();

      /* Create statement */
      SednaStatement st = con.createStatement();

      /* Load XML into the database */
      System.out.println("Loading data ...");
      boolean res;
      res = st.execute("LOAD 'C:/region.xml' 'region'");

      System.out.println("Document 'region.xml' "+
          "has been loaded successfully");
      /* Execute query */
      System.out.println("Executing query");
      res = st.execute("doc('region')/*/*");

      /* Print query results */
      printQueryResults(st);

      /* Remove document */
      System.out.println("Removing document ...");
      res = st.execute("DROP DOCUMENT 'region'");

      System.out.println("Document 'region' " +
                 "has been dropped successfully");
      /* Commit current transaction */
      con.commit();
    }
    catch(DriverException e) {
        e.printStackTrace();
    }
    finally {
      /* Properly close connection */
      try { if(con != null) con.close(); }
      catch(DriverException e) {
        e.printStackTrace();
      }
    }
  }

  /* Pretty printing for query results */
  private static void printQueryResults(SednaStatement st)
    throws DriverException {
    int count = 1;
    String item;
    SednaSerializedResult pr = st.getSerializedResult();
    while ((item = pr.next()) != null) {
      System.out.println(count + " item: " + item);
      count++;
    }
  }
}
\end{verbatim}}

The full-version source code of this example program can be found at:
\begin{verbatim}
[win:] INSTALL_DIR\examples\api\java\Client.java
[nix:] INSTALL_DIR/examples/api/java/Client.java
\end{verbatim}
where \verb!INSTALL_DIR! refers to the directory where Sedna is installed.

Before running the example make sure that the Sedna DBMS is installed and do the
following steps:

\begin{enumerate}
\item Start Sedna by running the following command:
\begin{verbatim}
se_gov
\end{verbatim}
If Sedna is started successfully it prints "GOVERNOR has been started in
the background mode".
\item Create a new database \verb!testdb! by running the following command:
\begin{verbatim}
se_cdb testdb
\end{verbatim}
If the database is created successfully it prints "The database 'testdb' has
been created successfully".
\item Start the testdb database by running the following command:
\begin{verbatim}
se_sm testdb
\end{verbatim}
If the database is started successfully it prints "SM has been started in
the background mode".
\end{enumerate}

You can compile and run the example following the steps listed below:

\begin{enumerate}
\item To compile the example, run the script:
\begin{verbatim}
    [win:] Clientbuild.bat
    [nix:] ./Clientbuild.sh
\end{verbatim}
located in the same folder as \verb!Client.java!.

\item  To run the compiled example, use the script:
\begin{verbatim}
    [win:] Client.bat
    [nix:] ./Client.sh
\end{verbatim}
located in the same folder as \verb!Client.java!.
\end{enumerate}


%===============================================================================
%                       Sedna Programmer's Guide: C API
%===============================================================================
\subsection{C API}
\label{c-api}

libsedna is the C application programmer's interface to Sedna XML DBMS. libsedna
is a set of library functions that allow client programs to access one or more
databases of Sedna XML DBMS and manipulate database data using database language
(XQuery and XUpdate) described in Section 2.

libsedna library is supplied with two header files: \verb!"libsedna.h"!,
\verb!"sp_defs.h"!. Client programs that use libsedna must include the header
file libsedna.h, must link with the libsedna library and provide the compiler
with the path to the directory where \verb!"libsedna.h"!, \verb!sp_defs.h! files
are stored.

For convenience three versions of \verb!libsedna! are provided on the Windows
operating system:

\begin{enumerate}
\item\verb!libsednamt.lib! - static multi-threaded version built with /MT
option. Use it if you compile your project with /MT[d] option.
\item\verb!libsednamd.lib! - static multi-threaded version built with /MD
option. Use it if you compile your project with /MD[d] option.
\item\verb!sednamt.dll! - dynamic version. \verb!sednamt.lib! is import library.
\end{enumerate}

On Unix-like operating systems the following versions of \verb!libsedna! are
provided:

\begin{enumerate}
\item\verb!libsedna.so! - dynamic shared library.
\item\verb!libsedna.a! - static version of the library.
\item\verb!libsedna_pic.a! - static version of the library with PIC enabled. You
may need it to build drivers for Sedna which are based on \verb!libsedna!.
\end{enumerate}


%===============================================================================
%                           C API: Error Handling
%===============================================================================
\subsubsection{Errors Handling}

C API provides set of functions for sessions and transactions management, query
and update statements execution, etc. If the function fails it returns negative
value. In this case application can obtain the error message and code which help
to understand the reason of the error occurred.

To get the last error message use \verb!SEgetLastErrorMsg! function:

\begin{verbatim}
char* SEgetLastErrorMsg(SednaConnection* conn)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type
(see \ref{c-api-connecting}, Connecting to a Database section for details on
how to obtain a connection instance).
\end{citemize}

The function \verb!SEgetLastErrorCode! returns the last error code occurred in
the session:

\begin{verbatim}
int SEgetLastErrorCode(struct SednaConnection *conn)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type
(see \ref{c-api-connecting}, Connecting to a Database section for details on
how to obtain a connection instance).
\end{citemize}


%===============================================================================
%                      C API: Connecting to a Database
%===============================================================================
\subsubsection{Connecting to a Database}
\label{c-api-connecting}

Before working with Sedna an application has to declare variable of the
\verb!SednaConnection! type and initialize it in the following manner:

\begin{verbatim}
struct SednaConnection conn = SEDNA_CONNECTION_INITIALIZER;
\end{verbatim}

\begin{note}
The initialization with \verb!SEDNA_CONNECTION_INITIALIZER! is mandatory for
Sedna version 0.5 and earlier.
\end{note}

To start working with Sedna an application has to open a session via
establishing an authenticated connection with the server using \verb!SEconnect!:

\begin{verbatim}
int SEconnect(SednaConnection* conn,
              const char* url,
              const char* db_name,
              const char* login,
              const char* password)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - is a pointer to an instance of SednaConnection type, that is
associated with a session. The instance of SednaConnection type is initialized
by the SEconnect if the session is open successfully.
\item\verb!url! - the name of the computer where the Sedna DBMS is running. This
parameter may contain a port number. If the port number is not specified, the
default port number (5050) is used.
\item\verb!db_name! - the name of the database to connect to.
\item\verb!login! - user login.
\item\verb!password! - user password.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_SESSION_OPEN! - connection to the database is established,
authentication passed successfully.
\end{citemize}

\noindent
If the function fails, the return value is negative and session is not opened:

\begin{citemize}
\item\verb!SEDNA_AUTHENTICATION_FAILED! - authentication failed.
\item\verb!SEDNA_OPEN_SESSION_FAILED! - failed to open session.
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}

To access multiple databases at one time or to better process its complex logic
an application can have several sessions open at one time.

When an application finished it's work with the database, it must close the
session. \verb!SEclose! finishes the session and closes the connection to the
server. \verb!SEclose! also frees resources that were equipped by the call to
\verb!SEconnect! function, that is for every successful call to \verb!SEconnect!
there must be a call to \verb!SEclose! in the client program. You must call
\verb!SEclose! both when application finishes its work with the database, and
when application cannot work with the database anymore due to some error.

\begin{verbatim}
int SEclose(SednaConnection* conn)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the SednaConnection type,
associated with a session to be closed.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_SESSION_CLOSED! - session closed successfully.
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_CLOSE_SESSION_FAILED! - session closed with errors.
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}


%===============================================================================
%                     C API: Setting Session Options
%===============================================================================
\subsubsection{Setting Session Options}
\label{session-option-capi}

An application can set attributes that govern aspects of a session using
\verb!SEsetConnectionAttr!:

\begin{verbatim}
int SEsetConnectionAttr(struct SednaConnection *conn,
                        enum SEattr attr,
                        const void* attrValue,
                        int attrValueLength)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the SednaConnection type,
associated with a session to be closed.
\item\verb!attr! - an attribute to set (one of the predefined Sedna connection
attributes listed below).
\item\verb!attrValue! - a pointer to the value to be associated with the
attribute.
\item\verb!attrValueLength! - a length of the value in bytes.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_SET_ATTRIBUTE_SUCCEEDED! - the attribute was set successfully.
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}

\medskip

\noindent
\textbf{Supported attributes:}

\begin{itemize}
\item\verb!SEDNA_ATTR_AUTOCOMMIT! Autocommit mode is the default transaction
management mode of the Sedna server (\verb!SEDNA_AUTOCOMMIT_OFF! is the default
value of this attribute). Every XQuery or update statement is committed or
rolled back when it completes. If a statement completes successfully, it is
committed; if it encounters any error, it is rolled back. A connection to an
instance of the Sedna database operates in autocommit mode whenever this default
mode has not been overridden by setting this attribute into
\verb!SEDNA_AUTOCOMMIT_OFF! value.

\begin{tabular}{|l|l|}
\hline
\emph{Atrribute values} & \emph{Value size} \\
\hline
\verb!SEDNA_ATTR_AUTOCOMMIT_ON!, & \\
\verb!SEDNA_ATTR_AUTOCOMMIT_OFF! & sizeof(int) \\
\hline
\end{tabular}

\item\verb!SEDNA_ATTR_SESSION_DIRECTORY! connection attribute defines the
\verb!session directory!. If this attribute is set, paths in the \verb!LOAD!
statement \ref{bulk-load} or \verb!LOAD MODULE! are evaluated relative to the
session directory.

\begin{tabular}{|l|l|}
\hline
\emph{Atrribute values} & \emph{Size of value} \\
\hline
\emph{path to directory} & \emph{length of path} \\
\hline
\end{tabular}

\item\verb!SEDNA_ATTR_DEBUG! connection attribute turns on/off query debug
mode. Query debug mode is off by default. \textbf{Note:} \verb!SEDNA_ATTR_DEBUG!
connection attribute must be set only after \verb!SEconnect! has been called on
the \verb!conn!.

\begin{tabular}{|l|l|}
\hline
\emph{Atrribute values} & \emph{Value size} \\
\hline
\verb!SEDNA_ATTR_DEBUG_ON!, & \\
\verb!SEDNA_ATTR_DEBUG_OFF! & sizeof(int) \\
\hline
\end{tabular}

\item\verb!SEDNA_ATTR_CONCURRENCY_TYPE! connection attribute changes the
mode of the next transactions. Transaction can be set to run as \verb!READ-ONLY!
(\verb!SEDNA_READONLY_TRANSACTION!) or \verb!UPDATE!-transaction
(\verb!SEDNA_UPDATE_TRANSACTION!). \verb!READ-ONLY! transactions have one major
benefit: they never wait for other transactions (they do not have to acquire any
document/collection locks). However they might access slightly obsolete state of
the database (for example, they probably would not see the most recent committed
updates). You should use \verb!READ-ONLY! transactions in a highly concurrent
environment. Notice that the current transaction, if any, will be forcefully
committed.

\begin{tabular}{|l|l|}
\hline
\emph{Atrribute values} & \emph{Value size} \\
\hline
\verb!SEDNA_READONLY_TRANSACTION!, & \\
\verb!SEDNA_UPDATE_TRANSACTION! & sizeof(int) \\
\hline
\end{tabular}

\item\verb!SEDNA_ATTR_QUERY_EXEC_TIMEOUT! connection attribute allows to set the
limit on query execution time. If set, for each next query in this session,
query execution will be stopped if it lasts longer than timeout set. In this
case transaction in bounds of which the query run is rollback. By default (value
0) there is no any timeout for query execution, that is a query can be executed
as long as needed.

\begin{tabular}{|l|l|}
\hline
\emph{Atrribute values} & \emph{Value size} \\
\hline
\emph{time in seconds} & sizeof(int) \\
\hline
\end{tabular}

\item\verb!SEDNA_ATTR_MAX_RESULT_SIZE! connection attribute allows to set the
limit on query result size. If this attribute is set, the server will cut the
result data if its size exceeds the specified limit. By default, result data
that is passed from server in response to user query can be of unlimited size.

\begin{tabular}{|l|l|}
\hline
\emph{Atrribute values} & \emph{Value size} \\
\hline
\emph{size in bytes} & sizeof(int) \\
\hline
\end{tabular}

\item\verb!SEDNA_LOG_AMOUNT! connection attribute changes the mode of logical
logging for the following transactions in the same session. Transaction can be
set to run in full log mode (\verb!SEDNA_LOG_FULL!) or reduced log mode
(\verb!SEDNA_LOG_LESS!). The former means transaction writes much less log info
during bulk loads. Also, when such transaction commits the checkpoint is made,
which might greatly reduce recovery time. There is a caveat, however: such
transaction always runs in exclusive mode, which means there can be no
concurrent transactions. Before it starts it waits for other concurrent
transactions to finish. In turn, all other transactions will not start until
exlusive transaction finishes. You should use this option with care, since it
effectively stalls any concurrent activity. The main purpose of such
transactions is to bulk-load data. The other possible use-case includes
transactions performing heavy update operations. Since checkpoint will be made
when such transaction commits, it might reduce recovery time in case of database
crash. Otherwise, you should not use this option since you will not gain
anything. Notice also that the current transaction in the same session, if any,
will be forcefully committed. The default value for this attribute is
\verb!SEDNA_LOG_FULL!.

\begin{tabular}{|l|l|}
\hline
\emph{Atrribute values} & \emph{Value size} \\
\hline
\verb!SEDNA_LOG_LESS!, & \\
\verb!SEDNA_LOG_FULL! & sizeof(int) \\
\hline
\end{tabular}
\end{itemize}

An application can retrieve current value of hte connection attributes using
\verb!SEgetConnectionAttr!:

\begin{verbatim}
int SEgetConnectionAttr(struct SednaConnection *conn,
                        enum SEattr attr,
                        void* attrValue,
                        int* attrValueLength);
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type,
associated with a session to be closed.
\item\verb!attr! - an attribute to retrieve.
\item\verb!attrValue! - a pointer to memory in which to return the current value
of the attribute specified by \verb!attr!.
\item\verb!attrValueLength! - a length of the retrieved value in bytes.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_GET_ATTRIBUTE_SUCCEEDED! - the attribute was retrieved
successfully.
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}

To reset all connection attributes to default values use:

\begin{verbatim}
int SEresetAllConnectionAttr(struct SednaConnection *conn);
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type,
associated with a session to be closed.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_RESET_ATTRIBUTES_SUCCEEDED! - attributes has been reset
successfully.
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}


%===============================================================================
%                     C API: Transactions Management
%===============================================================================
\subsubsection{Transactions Management}
An application can execute queries and updates against the specified database
only in the scope of a transaction. That is, once a session has been opened, an
application can begin a transaction, execute statements and commit this
transaction. In a session transactions are processed sequentially. That is,
application must commit an ongoing transaction before beginning a new one.

There are two ways to manage transactions in Sedna sessions: \emph{autocommit
mode} and \emph{manual-commit mode}:

\begin{itemize}
\item\textbf{Autocommit mode}. Each individual statement is committed when it
completes successfully. When running in autocommit mode no other transaction
management functions are needed. By default, Sedna sessions are run in
autocommit mode.
\item\textbf{Manual-commit mode}. Transaction boundaries are specified
explicitly by means of \verb!SEbegin!, \verb!SEcommit! and \verb!SErollback!
functions. All statements between the call to \verb!SEbegin! and
\verb!SEcommit!/\verb!SErollback! are included in the same transaction.
\end{itemize}

An application can switch between the two modes using \verb!SEsetConnectionAttr!
and \verb!SEgetConnectionAttr! functions (see \ref{session-option-capi}) for
\verb!SEDNA_ATTR_AUTOCOMMIT! attribute.

To specify transaction boundaries application uses \verb!SEbegin!,
\verb!SEcommit! and \verb!SErollback! functions. \verb!SEbegin! function starts
new transaction in the provided session:

\begin{verbatim}
int SEbegin(SednaConnection* conn)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_BEGIN_TRANSACTION_SUCCEEDED! - transaction has been
successfully started.
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_BEGIN_TRANSACTION_FAILED! - failed to start a transaction.
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}

\verb!SEcommit! function commits the current transaction:

\begin{verbatim}
int SEcommit(SednaConnection* conn)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_COMMIT_TRANSACTION_SUCCEEDED! - transaction has been committed.
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_COMMIT_TRANSACTION_FAILED! - failed to commit transaction.
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}

\verb!SErollback! function rollbacks the current transaction:

\begin{verbatim}
int SErollback(SednaCommection* conn)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_ROLLBACK_TRANSACTION_SUCCEEDED! - transaction has been
rollbacked.
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_ROLLBACK_TRANSACTION_FAILED! - failed to rollback transaction.
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}


%===============================================================================
%               C API: Getting connection and transaction status
%===============================================================================
\subsubsection{Getting Connection and Transaction Status}

An application can obtain the connection status by \verb!SEconnectionStatus!
function:

\begin{verbatim}
int SEconnectionStatus(SednaConnection* conn)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\begin{citemize}
\item\verb!SEDNA_CONNECTION_OK! - specified connection is open and functions ok.
\item\verb!SEDNA_CONNECTION_CLOSED! - specified connection is closed. This could
be either after the call to \verb!SEclose! function, or before the call to
\verb!SEconnect! function.
\item\verb!SEDNA_CONNECTION_FAILED! - specified connection has been failed.
(\textbf{Note:} in this case you should call \verb!SEclose! function to release
resources).
\end{citemize}

An application may obtain the transaction status by \verb!SEtransactionStatus!
function:

\begin{verbatim}
int SEtransactionStatus(SednaConnection* conn)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\end{citemize}

\noindent
\textbf{Return values:}

\begin{citemize}
\item\verb!SEDNA_TRANSACTION_ACTIVE! - specified connection runs transaction.
\item\verb!SEDNA_NO_TRANSACTION! - specified connection does not run
transaction. This could be for example when previous transaction has been
committed and a new one has not begun yet.
\end{citemize}


%===============================================================================
%                  C API: Executing Queries and Updates
%===============================================================================
\subsubsection{Executing Queries and Updates}
\label{exec-capi}

There are two functions to execute a statement (query or update):
\verb!SEexecute! function and \verb!SEexecuteLong! function. First one reads
statement from a C-string, the second reads long statement from a provided file.
To get trace (\verb!fn:trace! XQuery function) and debug information application
may implement custom debug handler and set it using function:
\verb!SEsetDebugHandler!.

\begin{verbatim}
int SEexecute(SednaConnection* conn, const char* query)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\item\verb!query! - a null-terminated string with an XQuery or XUpdate
statement.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_QUERY_SUCCEEDED! - specified query succeeded and result data
can be retrieved.
\item\verb!SEDNA_UPDATE_SUCCEEDED! - specified update succeeded.
\item\verb!SEDNA_BULK_LOAD_SUCCEEDED! - specified update (bulk load
\ref{bulk-load}) succeeded.
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_QUERY_FAILED! - specified query failed.
\item\verb!SEDNA_UPDATE_FAILED! - specified update failed.
\item\verb!SEDNA_BULK_LOAD_FAILED! - bulk load failed.
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}

If the statement is really long, and you prefer to pass it to the Sedna directly
from a file use \verb!SEexecuteLong! function.

\begin{verbatim}
int SEexecuteLong(SednaConnection* conn,
                  const char* query_file_path)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\item\verb!query_file! - a path to the file with a statement to execute.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_QUERY_SUCCEEDED! - specified query succeeded and result data
can be retrieved.
\item\verb!SEDNA_UPDATE_SUCCEEDED! - specified update succeeded.
\item\verb!SEDNA_BULK_LOAD_SUCCEEDED! - specified update (bulk load
\ref{bulk-load}) succeeded.
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_QUERY_FAILED! - specified query failed.
\item\verb!SEDNA_UPDATE_FAILED! - specified update failed.
\item\verb!SEDNA_BULK_LOAD_FAILED! - bulk load failed.
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}

If \verb!SEexecute! function or \verb!SEexecuteLong! function return
\verb!SEDNA_QUERY_SUCCEEDED!, the result data can be retrieved. The result of
XQuery query evaluation is a sequence of items, where every item is represented
as a string. Use the \verb!SEnext! function to iterate over the sequence and
\verb!SEgetData! function to retrieve the current item of the sequence.

\begin{verbatim}
int SEnext(SednaConnection* conn)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_NEXT_ITEM_SUCCEEDED! - moving to the next item succeeded, and
the item can be retrieved.
\end{citemize}

\noindent
If the function fails or the is no result items available to retrieve, the
return value is negative:

\begin{citemize}
\item\verb!SEDNA_NEXT_ITEM_FAILED! - failed to get next item.
\item\verb!SEDNA_RESULT_END! - the result sequence is ended, no result data to
retrieve.
\item\verb!SEDNA_NO_ITEM! - there was no succeeded query that produced the
result data, no result data to retrieve.
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}

\verb!SEgetData! function retrieves current item from the result sequence:

\begin{verbatim}
int SEgetData(SednaConnection* conn,
              char* buf,
              int bytes_to_read)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\item\verb!buf! - pointer to the buffer that receives the data got from the
server.
\item\verb!bytes_to_read! - number of bytes to be read from the server into the
buffer.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is non-negative:

\begin{citemize}
\item\verb!number of bytes! actually read from the server and put into the
buffer.
\item\verb!zero! - no data was read from the server and put into the buffer
because of the item end. (use \verb!SEnext! to move to the next item of the
result).
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_GET_DATA_FAILED! - failed to get data.
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}

Since version 1.5 Sedna supports reporting tracing information (\verb!fn:trace!
XQuery function). To handle tracing information while retrieving result data use
debug handler \verb!debug_handler_t! and \verb!SEsetDebugHandler! function:

\begin{verbatim}
void SEsetDebugHandler(struct SednaConnection *conn,
                       debug_handler_t debug_handler)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\item\verb!debug_handler! - a pointer to your own defined function of the
following type: \verb!void (*debug_handler_t)(int subtype, const char *msg)!
where \verb!subtype! is a type of debug information (currently only
\verb!SEDNA_QUERY_TRACE_INFO! is supported), \verb!msg! is a buffer with debug
information.
\end{citemize}

For example the following debug handler prints out debug iformation to the
stdout:

\small{
\begin{verbatim}
void my_debug_handler(enum SEdebugType subtype,
                      const char *msg) {
  printf("TRACE: ");
  printf("subtype(%d), msg: %s\n", subtype, msg);
}
\end{verbatim}}

If the debug handler is not defined by the application, trace information is
ignored.


%===============================================================================
%                            C API: Loading Data
%===============================================================================
\subsubsection{Loading Data}

XML data can be loaded into a database using \verb!"LOAD"! statement of the Data
Manipulation Language (see \ref{bulk-load}). Besides, libsedna library provides
\verb!SEloadData! and \verb!SEendLoadData! functions to load well-formed XML
documents divided into parts of any convenient size.

\verb!SEloadData! functions loads a chunk of an XML document:

\begin{verbatim}
int SEloadData(SednaConnection* conn,
               const char* buf,
               int bytes_to_load,
               const char* doc_name,
               const char* col_name)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\item\verb!buf! - a buffer with chunk of an XML document to load.
\item\verb!bytes_to_load! - number of bytes to load.
\item\verb!doc_name! - name of the document in a database the data loads to.
\item\verb!col_name! - name of the collection in the case if document is loaded
into the collection, \verb!NULL! if document is loaded as a standalone one.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_DATA_CHUNK_LOADED! - chunk of an XML document loaded
successfully.
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_ERROR! - some error occurred. Data is not loaded.
\end{citemize}

When the whole document is loaded using \verb!SEloadData!, application must use
\verb!SEendLoadData! to notify server that transfer of an XML document is
finished:

\begin{verbatim}
int SEendLoadData(SednaConnection* conn)
\end{verbatim}

\noindent
\textbf{Parameters:}

\begin{citemize}
\item\verb!conn! - a pointer to an instance of the \verb!SednaConnection! type.
\end{citemize}

\noindent
\textbf{Return values:}

\medskip

\noindent
If the function succeeds, the return value is positive:

\begin{citemize}
\item\verb!SEDNA_BULK_LOAD_SUCCEEDED! - XML document was successfully loaded
into the database.
\end{citemize}

\noindent
If the function fails, the return value is negative:

\begin{citemize}
\item\verb!SEDNA_BULK_LOAD_FAILED! - failed to load XML document into the
database.
\item\verb!SEDNA_ERROR! - some error occurred.
\end{citemize}


%===============================================================================
%                            C API: Example Code
%===============================================================================
\subsubsection{Example Code}

\small{
\begin{verbatim}
#include "libsedna.h"
#include "stdio.h"

int handle_error(SednaConnection* conn,
                 const char* op,
                 int close_connection) {
    printf("%s failed: \n%s\n", op, SEgetLastErrorMsg(conn));
    if(close_connection == 1) SEclose(conn);
    return -1;
}

int main() {
  struct SednaConnection conn = SEDNA_CONNECTION_INITIALIZER;
  int bytes_read, res, value;
  char buf[1024];

  /* Turn off autocommit mode */
  value = SEDNA_AUTOCOMMIT_OFF;
  res = SEsetConnectionAttr(&conn, SEDNA_ATTR_AUTOCOMMIT,
                            (void*)&value, sizeof(int));

  /* Connect to the database */
  res = SEconnect(&conn, "localhost", "test_db",
                  "SYSTEM", "MANAGER");
  if(res != SEDNA_SESSION_OPEN)
    return handle_error(&conn, "Connection", 0);

  /* Begin a new transaction */
  res = SEbegin(&conn);
  if(res != SEDNA_BEGIN_TRANSACTION_SUCCEEDED)
    return handle_error(&conn, "Transaction begin", 1);

  /* Load file "region.xml" into the document "region" */
  res = SEexecute(&conn, "LOAD 'region.xml' 'region'");
  if(res != SEDNA_BULK_LOAD_SUCCEEDED)
    return handle_error(&conn, "Bulk load", 1);

  /* Execute XQuery statement */
  res = SEexecute(&conn, "doc('region')/*/*");
  if(res != SEDNA_QUERY_SUCCEEDED)
    return handle_error(&conn, "Query", 1);

  /* Iterate and print the result sequence */
  while((res = SEnext(&conn)) != SEDNA_RESULT_END) {
    if (res == SEDNA_ERROR)
      return handle_error(&conn, "Getting item", 1);

    do {
      bytes_read = SEgetData(&conn, buf, sizeof(buf) - 1);
      if(bytes_read == SEDNA_ERROR)
        return handle_error(&conn, "Getting item", 1);
      buf[bytes_read] = '\0';
      printf("%s\n", buf);
    } while(bytes_read > 0);
  }

  /* Drop document "region" */
  res = SEexecute(&conn, "DROP DOCUMENT 'region'");
  if(res != SEDNA_UPDATE_SUCCEEDED)
    return handle_error(&conn, "Drop document", 1);

  /* Commit transaction */
  res = SEcommit(&conn);
  if(res != SEDNA_COMMIT_TRANSACTION_SUCCEEDED)
    return handle_error(&conn, "Commit", 1);

  /* Close connection */
  res = SEclose(&conn);
  if(res != SEDNA_SESSION_CLOSED)
    return handle_error(&conn, "Close", 0);

  return 0;
}
\end{verbatim}}

The full version of this example program can be found in:
\begin{verbatim}
[win:] INSTALL_DIR\examples\api\c\Client.c
[nix:] INSTALL_DIR/examples/api/c/Client.c
\end{verbatim}

Here \verb!INSTALL_DIR! refers to the directory where Sedna is installed.

Before running the example make sure that the Sedna DBMS is installed and do the
following steps:

\begin{enumerate}
\item Start Sedna by running the following command:
\begin{verbatim}
se_gov
\end{verbatim}
If Sedna is started successfully it prints "GOVERNOR has been started in
the background mode".
\item Create a new database \verb!testdb! by running the following command:
\begin{verbatim}
se_cdb testdb
\end{verbatim}
If the database is created successfully it prints "The database 'testdb' has
been created successfully".
\item Start the testdb database by running the following command:
\begin{verbatim}
se_sm testdb
\end{verbatim}
If the database is started successfully it prints "SM has been started in
the background mode".
\end{enumerate}

You can compile and run the example by following the steps listed below:

\begin{enumerate}
\item To compile the example use:
\begin{verbatim}
    [win:] Clientbuild.bat
    [nix:] ./Clientbuild.sh
\end{verbatim}
located in the same folder as \verb!Client.c!.

\item To run the compiled example use:
\begin{verbatim}
    [win:] Client.exe
    [nix:] ./Client
\end{verbatim}
located in the same folder as \verb!Client.c!.
\end{enumerate}


%===============================================================================
%                            Scheme API: Sessions
%===============================================================================
\subsection{Scheme API}

Scheme API allows querying and managing XML data from an application written in
Scheme. Scheme API follows the spirit of SchemeQL~\cite{paper:scheme-ql}, an
implementation of SQL 1992 for Scheme. The results of XQuery statements to the
Sedna DBMS via the Scheme API can be represented either in XML or
SXML~\cite{paper:sxml}.


\subsubsection{Sessions}
For working with the Sedna DBMS from Scheme, you should first establish a
connection between the Scheme API driver and the Sedna DBMS. Here are two
functions to manage connections:

\begin{verbatim}
> (sedna:connect-to-database host db-name user password)
  : String String String String -> connection-object
\end{verbatim}

Establishes a connection between the client application and the Sedna DBMS.
Returns a 'connection' object which encapsulate information about the
connection.
The arguments are strings that denote connection parameters:

\begin{citemize}
\item \texttt{host} is the host where the Sedna DBMS is running. If it is on the
same machine as your Scheme application, you can use \texttt{"localhost"} for
the value of this parameter.
\item \texttt{db-name} is the name of the database you want to work with. You
are to establish a separate connection for each database you would like to work
with.
\item \texttt{user} is your user name for the session. You can use
\texttt{"SYSTEM"} for the value of this parameter.
\item \texttt{password} is your password for the session. You can use the
\texttt{"MANAGER"} value of this parameter.
\end{citemize}

To disconnect from the database, you can use the following function:

\begin{verbatim}
> (sedna:disconnect-from-database connection)
  : connection-object -> void
\end{verbatim}

Closes the connection represented by the \texttt{connection} object. If server
fails to close the connection, the function closes the connection forcibly from
the client side and raises the exception, as discussed in subsubsection
\ref{scheme-errors}.


%===============================================================================
%                       Scheme API: Manage Transactions
%===============================================================================
\subsubsection{Manage Transactions}

After the connection with a database is established and the session is begun,
you can run zero or more transactions in this session. Transactions are to be
run sequentially, with no more than a single transaction at a time, so you
should commit your running transaction before starting a new one.

To begin a new transaction, the following function is provided:

\begin{verbatim}
> (sedna:begin-transaction connection)
  : connection-object -> void
\end{verbatim}

It accepts the \texttt{connection} object (earlier created by
\texttt{sedna:connect-to-database} function) and starts a new transaction. If
the transaction could not be created, the exception is raised, as discussed in
subsubsection \ref{scheme-errors}.

To end your running transaction, you are provided with the following function:

\begin{verbatim}
> (sedna:end-transaction connection action)
  : connection-object, symbol -> void
\end{verbatim}

If \texttt{action} is \texttt{'COMMIT} the transaction in the given connection
will be committed, if \texttt{'ROLLBACK} is given, the transaction will be rolled
back.


%===============================================================================
%                  Scheme API: Executing Queries and Updates
%===============================================================================
\subsubsection{Executing Queries and Updates}

Within a transaction, you can execute zero or more queries to the database.

\begin{verbatim}
> (sedna:execute-query connection query)
  : connection-object, string -> result
\end{verbatim}

The first argument is the \texttt{connection} object, earlier created by
\texttt{sedna:connect-to-database} function. The \texttt{query} is represented
as a string and can express one of the following kinds of statements:

\begin{citemize}
\item \textbf{XQuery statement} -- for querying data from the database, without
modifying it;
\item \textbf{Update statement} -- for making modifications to the database you
work with;
\item \textbf{Bulk load command} -- for loading a new XML document from the
local file to the database;
\item \textbf{Database management statement} -- to create index, trigger,
retrieve metadata, etc.
\end{citemize}

If an error occurs at the server side during query execution (e.g.\ the
requested document not found), the function raises an exception that contains
the message about the error occurred.

In the successful case of query execution, \texttt{sedna:execute-query} returns
\texttt{\#t} for the last 3 kinds of queries, to denote a successful update made
to the database. The XQuery \texttt{query} results to a sequence of items, which
are evaluated lazily and are represented as a pair:

\begin{verbatim}
xquery-result ::= (cons current-item promise)
\end{verbatim}

\noindent
This way of result representation is very close to the notion of SchemeQL {\em
cursor}~\cite{paper:scheme-ql} (with the only difference in that the Scheme API
driver returns XQuery items instead of table rows returned by SchemeQL). The
first member of the pair is the \texttt{current-item} represented in SXML, and
the second member of the pair holds a promise (which can be forced) to evaluate
and return the next item in the result sequence.

To iterate over the result sequence, you can use the function:

\begin{verbatim}
> (sedna:next xquery-result)
  : xquery-result -> xquery-result or '()
\end{verbatim}

\noindent
which forces the evaluation of the following items in the result sequence, until
the end of the sequence is reached.

Such design allows you to process a query result in a lazy stream-wise fashion
and provides you with an ability to process large query results, which would not
otherwise fit in the main memory.

However, for query results that are not very large, you may find it convenient
to evaluate them all at once and represent the result sequence as a Scheme list.
Scheme API provides a function that converts the \texttt{xquery-result} into the
list that contains all items of the result sequence:

\begin{verbatim}
> (sedna:result->list xquery-result)
  : xquery-result -> (listof item)
\end{verbatim}

\noindent
To obtain the result sequence in the form of the list, you can execute your
queries as a superposition of the above considered functions:

\begin{verbatim}
(sedna:result->list
  (sedna:execute-query connection query))
\end{verbatim}

\noindent
It should be noted that the XQuery statement result in that case exactly
corresponds to the term of a {\em node-set} in the XPath implementation in
Scheme SXPath~\cite{paper:sxpath}.

If you want to obtain your query results in XML instead of SXML, you can use
the function:

\begin{verbatim}
> (sedna:execute-query-xml connection query)
  : connection-object, string -> result
\end{verbatim}

\noindent
It is the counterpart of earlier discussed \texttt{sedna:execute-query} and
has the same signature, but represents query results in XML.
The function returns a sequence of items, in the form of \texttt{xquery-result}
discussed above, but the \texttt{current-item} is now a string containing the
representation for the current item in the form of XML.


%===============================================================================
%                     Scheme API: Bulk Load from Stream
%===============================================================================
\subsubsection{Bulk Load from Stream}

The following wrapper function provides a natural way to load an input stream
containing an XML document into your database:

\begin{verbatim}
> (sedna:bulk-load-from-xml-stream
      connection port document-name . collection-name)
  : connection-object, input-port,
      string [, collection-name] -> boolean
\end{verbatim}

As for \texttt{sedna:execute-query}, the first argument here is the
\texttt{connection} object, earlier created by
\texttt{sedna:connect-to-database} function. Argument \texttt{port} is a Scheme
input port and is supposed to contain a well-formed XML document. Argument
\texttt{document-name} specifies the name that will be given to the XML document
within a database. If the $4$-th argument \texttt{collection-name} is supplied,
the XML document is loaded into the collection which name is specified by the
\texttt{collection-name} argument. If the $4$-th argument of the function call
is not supplied, the XML document is loaded into the database as a standalone
document.

By allowing you to specify the input port you would like to use, this function
provides a higher-level shortcut for \texttt{sedna:execute-query} when bulk load
from stream is concerned. For more details on bulk load, see section
\ref{bulk-load}.


%===============================================================================
%             Scheme API: Higher-level Function for a Transaction
%===============================================================================
\subsubsection{Higher-level Function for a Transaction}

This higher-level function provides a convenient way for executing a transaction
consisting of several queries, within a single function call:

\begin{verbatim}
> (sedna:transaction connection . queries)
  : connection-object, string* -> result
\end{verbatim}

This function starts a new transaction on the \texttt{connection} objects and
executes all the \texttt{queries} given in order. If no exception occurs, the
function commits the transaction and returns the result of the last query. If
any exception occurred during query execution, the function sends rollback to
the Sedna DBMS and passes along the exception to the application.


%===============================================================================
%                  Scheme API: Executing Queries and Updates
%===============================================================================
\subsubsection{Error handling}
\label{scheme-errors}

Error handling in the Scheme API driver is based on the exception mechanism
suggested in the (currently withdrawn) SRFI-12~\cite{paper:srfi-12}. The SRFI-12
exception mechanism is natively supported in the Chicken Scheme
compiler~\cite{paper:chicken}. In the Scheme API driver, we also provide the
SRFI-12 implementation for PLT and Gambit.

%===============================================================================
%                          Scheme API: Code Example
%===============================================================================
\subsubsection{Code Example}

This section presents an example that illustrates the application of the Scheme
API driver.

\small{
\begin{verbatim}
; Load the necessary Scheme API driver files
(load "collect-sedna-plt.scm")

; Create a connection
(define conn
  (sedna:connect-to-database "localhost" "testdb"
                             "SYSTEM" "MANAGER"))
; Begin a transaction
(sedna:begin-transaction conn)

; Bulk load
(call/cc
 (lambda (k)
   (with-exception-handler  ; Exception handler
    (lambda (x)
      (display "File already loaded to the database")
      (newline)
      (k #f))
    (lambda ()
      (sedna:execute-query conn
                           "LOAD 'region.xml' 'regions'")))))

; Execute a statement and represent it as an SXML nodeset
(pp
 (sedna:result->list
  (sedna:execute-query conn "doc('region')/*/*")))

; Update statement
(pp
 (sedna:execute-query conn
                  "UPDATE delete doc('region')//africa"))

; Querying all regions once again
(pp
 (sedna:result->list
  (sedna:execute-query conn "doc('region')/*/*")))

; Commit transaction
(sedna:end-transaction conn 'COMMIT)

; Close the connection
(sedna:disconnect-from-database conn)
\end{verbatim}}

You can find the full version of this example and the Scheme API driver code in:
\begin{verbatim}
[win:] INSTALL_DIR\examples\api\scheme
[nix:] INSTALL_DIR/examples/api/scheme
\end{verbatim}
where \verb!INSTALL_DIR! refers to the directory where Sedna is installed.

Before running the example make sure that the Sedna DBMS is installed and do the
following steps:

\begin{enumerate}
\item Start Sedna by running the following command in a command line:
\begin{verbatim}
se_gov
\end{verbatim}
If Sedna is started successfully it prints "GOVERNOR has been started in the
background mode".
\item Create a new database \verb!testdb! by running the following command:
\begin{verbatim}
se_cdb testdb
\end{verbatim}
If the database is created successfully it prints "The database 'testdb' has
been created successfully".
\item Start the testdb database by running the following command:
\begin{verbatim}
se_sm testdb
\end{verbatim}
If the database is started successfully it prints "SM has been started in the
background mode".
\end{enumerate}

If the Sedna DBMS is running on the same computer as your Scheme application,
you don't need to change anything in the example code. If the Sedna DBMS is
running on a remote machine, you should use the name of this machine when
connecting to the database with \texttt{sedna:connect-to-database} function.

For running the example supplied, you should copy all files from the folder:
\begin{verbatim}
     [win:] INSTALL_DIR\examples\api\scheme
     [nix:] INSTALL_DIR/examples/api/scheme
\end{verbatim}
into the folder where the Scheme API driver code is located
\begin{verbatim}
     [win:] INSTALL_DIR\driver\scheme
     [nix:] INSTALL_DIR/driver/scheme
\end{verbatim}
where \verb!INSTALL_DIR! refers to the directory where Sedna is installed.

You can use PLT DrScheme GUI to open and run \texttt{"client.scm"} in the
graphical mode. You can also run the example from your command line, by typing:

\begin{verbatim}
mzscheme -gr client.scm
\end{verbatim}

For running the example with a different Scheme implementation (Chicken or
Gambit), uncomment the corresponding line at the beginning of the example code
in \texttt{"client.scm"} and follow the instructions of the chosen Scheme
implementation in running the program.


%===============================================================================
%                        Database Language: XQuery Support
%===============================================================================
\section{Database Language}
\label{sec:DBLang}

\subsection{XQuery Support}
\label{sec:xquery-support}
The Sedna query language is XQuery \cite{paper:query-language} developed by W3C.
Sedna conforms to January 2007 specification of XQuery except the following
features:

\begin{itemize}
\item \verb!copy-namespaces! declaration works only in \verb!preserve!,
\verb!inherit! mode regardless of actual prolog values;
\item \verb!fn:normalize-unicode! function is not conformant (it always returns
the same string or raises exception);
\item External variables are not supported. However they are supported by XQJ
driver by Charles Foster (see download page);
\item Regular expressions (e.g. \verb!fn:matches()! use them) are based on
PCRE~\cite{lib:pcre-lib} syntax which differs from the one defined in W3C
specifications.
\end{itemize}

Sedna also has full support for two optional XQuery features:
\begin{itemize}
\item\textbf{Full Axis}. The following optional axes are supported:
\verb!ancestor!, \verb!ancestor-or-self!, \verb!following!,
\verb!following-sibling!, \verb!preceding!, and \verb!preceding-sibling!;
\item\textbf{Module Feature} allows a query Prolog to contain a Module Import
and allows library modules to be created.
\end{itemize}

Sedna passes "XML Query Test Suite (XQTS)" and has official "almost passed"
status. The detailed report can be found at
\url{http://www.w3.org/XML/Query/test-suite/XQTSReport.html}


%===============================================================================
%                  XQuery Options and Extensions: Serialization
%===============================================================================
\subsection{XQuery Options and Extensions}
\label{sec:xquery-extensions}

\subsubsection{Controlling Serialization}
\label{indents}
Serialization is the process of converting XML nodes evaluated by XQuery into a
stream of characters. In Sedna serialization is carried out when the result of a
query is returned to the user. You can control the serialization by setting the
\emph{serialization parameters} specified in \cite{paper:query-serialization}.
Currently, Sedna supports the following serialization parameters:

\medskip

\begin{tabular}{|l|l|l|}
\hline
Parameter name & Values & Description \\
\hline
\hline
indent & "yes" or "no" (default yes) & Output indented \\
\hline
\end{tabular}

\medskip

To set a serialization parameter, use the \verb!output! option in a query
prolog. The \verb!output! option is in the Sedna namespace
(http://www.modis.ispras.ru/sedna) which is the predefined namespace in Sedna so
you can omit its declaration. The value of the \verb!output! option must have
the following structure "\verb!parameter-name=value; parameter-name=value!".
Consider the following examples:

\begin{verbatim}
declare namespace se = "http://www.modis.ispras.ru/sedna";
declare option se:output "indent=yes";
\end{verbatim}

As mentioned above, you may omit the Sedna namespace declaration:
\begin{verbatim}
declare option se:output "indent=yes";
\end{verbatim}


%===============================================================================
%                  XQuery Options and Extensions: Index Scan
%===============================================================================
\subsubsection{Value index-scan Functions}
\label{sec:value-index-scan-fun}

In the current version of Sedna, query executor does not use indices
automatically. Use the following functions to enforce executor to employ
indices.

\begin{verbatim}
index-scan ($title as xs:string,
            $value as xdt:anyAtomicType,
            $mode as xs:string) as node()*
\end{verbatim}

The \verb!index-scan! function scans the index with the \verb!$title! name and
returns the sequence of nodes which keys are equal (less than, greater than,
greater or equal, less or equal) to the search value \verb!$value!. A Sedna
error is raised if the search value can not be cast to the atomic type of the
index. The \verb!$mode! parameter of the \verb!xs:string! type is used to set
the type of the scan. The value of the parameter must be equal to one of the
following: 'EQ' (equal), 'LT'(less than), 'GT' (greater than), 'GE' (greater or
equal), 'LE' (less or equal).

\begin{verbatim}
index-scan-between ($title as xs:string,
                    $value1 as xdt:anyAtomicType,
                    $value2 as xdt:anyAtomicType,
                    $range as xs:string) as node()*
\end{verbatim}

The \verb!index-scan-between! scans the index with the \verb!$title! name and
returns the sequence of nodes which keys belong to the interval (segment, left
half-interval, right half-interval) between the first \verb!$value1! and second
\verb!$value2! search values. A Sedna error is raised if the search values can
not be cast to the atomic type of the index. This function provides the
\verb!$range! parameter of the \verb!xs:string! type to set the type of the
scan. The value of the string must be equal to one of the following: 'INT'
(interval), 'SEG' (segment), 'HINTR' (right half-interval), 'HINTL' (left
half-interval).

For example, to select the names of people who live in the London city employing
the "people" index defined in section \ref{sec:managing-value-indices}, use the
following expression:

\begin{verbatim}
index-scan("people", "London", "EQ")/name
\end{verbatim}


%===============================================================================
%           XQuery Options and Extensions: Full-Text Search Functions
%===============================================================================
\subsubsection{Full-Text Search Functions}
\label{sec:ft-fun}

Please read section \ref{sec:managing-ft-indices} before reading this section.

In the current version of Sedna, query executor does not use full-text indices
automatically. Use the following functions to enforce executor to employ
indices.

\begin{verbatim}
ftindex-scan($title as xs:string,
             $query as xs:string,
             $options as xs:string) as node()*
\end{verbatim}

The \verb!ftindex-scan! function scans the full-text index with the
\verb!$title! name and returns the sequence of items which satisfy the
\verb!$query!. As full-text index is based on dtSearch
\cite{link:dtsearch-engine}, use the dtSearch request language
\cite{doc:dtsearch} to specify the query. DtSearch options dtsSearchAnyWords or
dtsSearchAllWords may be specified in \verb!$options!.

For example, you can employ the "articles" index defined in section
\ref{sec:managing-ft-indices} to select the titles of articles that contain word
"apple" but not "pear":

\begin{verbatim}
ftindex-scan("articles", "apple and not pear")/title
\end{verbatim}

The \verb!ftscan! function returns those items of the input sequence \verb!$seq!
which satisfy the query \verb!$query!. The function does not use indices and can
be applied to any sequence of nodes, even those that are not indexed. The query
\verb!$query! is evaluated over the text representation constructed according to
the \verb!$type! and \verb!$customization_rules! parameters. The values of the
parameters are the same as those used when a full-text index is created (see
section \ref{sec:managing-ft-indices} for details).

\begin{verbatim}
ftscan($seq as node()*,
       $query as xs:string,
       $type as xs:string,
       $customization_rules as xs:string) as node()*
\end{verbatim}

For example, you can select the titles of articles that contain word "apple" but
not "pear" \emph{without} using indices and using special customization rules as
follows:

\begin{verbatim}
ftscan(doc("foo")/library//article,
       "apple and not pear",
       "customized-value",
       (("b","string-value"),("a","delimited-value")))/title
\end{verbatim}


%===============================================================================
%              XQuery Options and Extensions: SQL Connection
%===============================================================================
\subsubsection{SQL Connection}

SQL Connection allows access to relational databases from XQuery using SQL. The
resulting relations are represented on-the-fly as sequences of XML-elements
representing rows. These elements have sub-elements corresponding with the
columns returned by the SQL query and thus can be easy processed in XQuery. All
functions dealing with access to SQL data are located in the namespace
\verb!http://modis.ispras.ru/Sedna/SQL! which is referred as \verb!sql! in the
following function declarations and examples.


\subsubsection*{Connections} In order to execute SQL queries on a RDBMS, you
should first establish a connection to it using one of the \verb!sql:connect!
functions:

\begin{verbatim}
function sql:connect($db-url as xs:string) as xs:integer
function sql:connect($db-url as xs:string,
                     $user as xs:string) as xs:integer
function sql:connect($db-url as xs:string,
                     $user as xs:string,
                     $password as xs:string) as xs:integer
function sql:connect($db-url as xs:string,
                     $user as xs:string,
                     $password as xs:string,
                     $options as element()*) as xs:integer
\end{verbatim}

These functions attempt to establish a database connection to the given URL
using a user name and password if specified. They return a connection handle
which could be then passed to \verb!sql:execute!, \verb!sql:prepare!,
\verb!sql:close!, \verb!sql:rollback!, and \verb!sql:commit! functions. If
connection could not be established, a Sedna error is raised.

All arguments of the \verb!sql:connect! functions except for \verb!$db-url! are
optional:

\begin{itemize}
\item\verb!$db-url! is the URL of the database to which a connect is
established. It should be one of the following form:
\small{\begin{verbatim}
odbc:<driver name>:[//<server>[/<database>][;]][<options>]
\end{verbatim}}
``;'' after \verb!<database>! or \verb!<server>! is required if there are some
driver options following it. Driver options must be in the following form:
\begin{verbatim}
<option>=<value>{;<option>=<value>}
\end{verbatim}
List of available options depends on the ODBC driver used. One of the common
options is ``Port'' which is used to specify the port on which the database
server is configured to listen. For example:
\small{\begin{verbatim}
odbc:MySQL ODBC 3.51 Driver://localhost/somedb;Port=1234
\end{verbatim}}
\item\verb!$user! is your user name for the session.
\item\verb!$password! is your password for the session.
\item\verb!$options! is an optional sequence of connection options. Connection
options are elements of the form:
\begin{verbatim}
<sql:option name="<option-name>" value="<option-value>"/>
\end{verbatim}
The only connection option available for the moment is \verb!manual-commit!
which enables manual commit mode if its value is \verb!on!.
\end{itemize}

To disconnect from the database, you can use the following function:
\begin{verbatim}
function sql:close($connection as xs:integer) as element()?
\end{verbatim}
It closes database connection associated with connection handle
\verb!$connection!. A Sedna error is raised if operation cannot be completed.


\subsubsection*{Executing Queries}
When a database connection is established you can start executing queries. Two
types of query execution are supported: \emph{direct query execution} and
\emph{prepared query execution}.


\subsubsection*{Direct Queries}
Simple SQL queries are executed as the following XQuery example shows:
\small{
\begin{verbatim}
declare namespace sql="http://modis.ispras.ru/Sedna/SQL";
let $connection :=
   sql:connect("odbc:MySQL ODBC 3.51 Driver://localhost/somedb",
               "user", "pass")
return
   sql:execute($connection,
               "SELECT * FROM people WHERE first = 'Peter'");
\end{verbatim}}

The result will be something like this:
\small{
\begin{verbatim}
<tuple first="Peter" last="Jackson" city="Wellington"/>
\end{verbatim}}

There are two functions for direct query execution:
\begin{verbatim}
function sql:execute($connection as xs:integer,
                     $statement as xs:string) as element()*
function sql:execute($connection as xs:integer,
                     $statement as xs:string,
                     $query-options as element()*) as element()*
\end{verbatim}
These functions execute a SQL query and return a sequence of elements
representing the query result. SQL query can be as both a query statement and an
update statement. In case of query statement, the result sequence contains an
element named 'row' for each row of the query result. Each element contains as
many children attributes as there are non-NULL fields in the corresponding
result-row. Each attribute has the name of a row field. Fields with NULL values
are not included. In case of update statement, empty sequence is returned.A
Sedna error is raised on an erroneous statement.

The \verb!sql:execute! have the following arguments:
\begin{citemize}
\item\verb!$connection! is a connection handle, returned by \verb!sql:connect!
function;
\item\verb!$statement! is a string containing SQL statement to be executed;
\item\verb!$query-options! is a sequence of optional query parameters.
\end{citemize}

Update queries can be executed using the \verb!sql:exec-update! function:
\begin{verbatim}
function sql:exec-update($connection as xs:integer,
      $statement as xs:string) as xs:integer
function sql:exec-update($connection as xs:integer,
      $statement as xs:string,
      $query-options as element()*) as xs:integer
\end{verbatim}
these functions are similar to \verb!sql:execute!, but return the number of rows
affected by an update query (instead of an empty sequence returned by
\verb!sql:execute! for update-queries). Function arguments are same as for
\verb!sql:execute!. The behaviour of this function is undefined for non-update
queries.


\subsubsection*{Prepared Statements}
Sometimes it is more convenient or more efficient to use prepared SQL statements
instead of direct query execution. In most cases, when a SQL statement is
prepared it will be sent to the DBMS right away, where it will be compiled. This
means that the DBMS does not have to compile a prepared statement each time it
is executed.

Prepared statements can take parameters. This allows using the same statement
and supply it with different values each time you execute it, as in the
following XQuery example:
\small{
\begin{verbatim}
declare namespace sql="http://modis.ispras.ru/Sedna/SQL";
let $connection :=
   sql:connect("odbc:MySQL ODBC 3.51 Driver://localhost/somedb",
               "user", "pass")
let $statement :=
   sql:prepare($connection,
               "INSERT INTO people(first, last) VALUES (?, ?)")
return (sql:execute($statement, "John", "Smith"),
        sql:execute($statement, "Matthew", "Barney"))
\end{verbatim}}
\noindent
this XQuery code inserts two rows into table \verb!people! and returns an empty
sequence.

To use prepared statements, first you need to create a prepared statement handle
using the \verb!sql:prepare! function:
\small{
\begin{verbatim}
function sql:prepare($connection as xs:integer,
                     $statement as xs:string) as xs:integer
function sql:prepare($connection as xs:integer,
                     $statement as xs:string,
                     $query-options as element()*) as xs:integer
\end{verbatim}}
\noindent
these functions prepare a SQL statement for later execution and returns a
prepared statement handle which can be used in the \verb!sql:execute! and
\verb!sql:exec-update! functions. A Sedna error is raised on an erroneous
statement.

The \verb!sql:prepare! functions have the following arguments:

\begin{citemize}
\item \verb!$connection! is a connection handle, created by \verb!sql:connect!
function;
\item \verb!$statement! is a string containing a SQL statement that may
contain one or more '?' - \verb!IN! parameter placeholders;
\item \verb!$query-options! is a sequence of optional query parameters.
\end{citemize}

There are two prepared statement execution functions, similar to direct
query execution:

\begin{verbatim}
function sql:execute($prepared-statement as xs:integer,
                     $param1 as item()?,
                     ...) as element()*
\end{verbatim}
this function is similar to \verb!sql:execute! for direct queries and returns a
sequence of elements representing the query result.

The \verb!sql:execute! function have the following arguments:

\begin{citemize}
\item\verb!$prepared-statement! is a prepared statement handle created by
\verb!$sql:prepare!;
\item\verb!$param1, ...! are parameters for parametrized
statements. The number of parameters specified must exactly match the number
of parameters of the prepared statement. NULL values are represented as empty
sequences \verb!()!.
\end{citemize}

To execute a prepared update statement you may use \verb!exec-update! function:
\begin{verbatim}
function sql:exec-update($prepared-statement as xs:integer,
                         $param1 as item()?,
                         ...) as xs:integer
\end{verbatim}
This function is similar to \verb!sql:execute!, but returns the number of rows
affected by an update query (instead of an empty sequence returned by
\verb!sql:execute! for update-queries). Function arguments are the same as for
\verb!sql:execute!. The behavior of this function is undefined for non-update
queries.


\subsubsection*{Transactions}

The default commit mode of connection is auto-commit, meaning that all updates
will be committed automatically. If this is not desired behaviour, you can pass
manual-commit option to \verb!sql:connect! when you create a connection handle.

In manual commit mode you can specify when updates will be committed or rolled
back:

\small{
\begin{verbatim}
declare namespace sql="http://modis.ispras.ru/Sedna/SQL";
let $connection :=
  sql:connect("odbc:MySQL ODBC 3.51 Driver://localhost/testdb",
              "user-name",
              "user-password",
              <sql:option name="manual-commit" value="1"/>)
return
  for $person in doc("auction")/person
  return (
    sql:execute($connection, "<do something with person>"),
    if (fn:all-is-ok($connection, $person)) then
      (
        sql:execute($connection, "<do something with person>"),
        sql:commit($connection)
      )
    else
      sql:rollback($connection))
\end{verbatim}}

There are two functions for specifying transaction boundaries -
\verb!sql:commit! and \verb!sql:rollback! (transactions are started
automatically by queries, these functions only close them):

\begin{verbatim}
function sql:commit($connection as xs:integer) as element()?
\end{verbatim}

\verb!sql:commit! function commits all changes made during the last transaction
in the database connection specified by connection handle \verb!$connection! and
closes transaction. A Sedna error is raised if operation cannot be completed.

Function \verb!sql:rollback! rolls back all changes made during the last
transaction in the database connection specified by the connection handle
\verb!$connection! and closes transaction. A Sedna error is raised if operation
cannot be completed.

\begin{verbatim}
function sql:rollback($connection as xs:integer) as element()?
\end{verbatim}


%===============================================================================
%               XQuery Options and Extensions: External Functions
%===============================================================================
\subsubsection{External Functions}

\emph{External function} is a notion defined in the XQuery specification
\cite{paper:query-language} as follows: "External functions are functions that
are implemented outside the query environment". Support for external functions
allows you to extend XQuery by implementing functions in other languages.

Sedna provides a server programming API to write external functions in the C/C++
language. External functions in Sedna are limited to dealing with sequences of
atomic values. External functions are compiled and linked in the form of shared
libraries (i.e. \verb!.dll! files in Windows or \verb!.so! files in
Linux/FreeBSD and \verb!.dylib! in Mac OS) and loaded by the server on demand.
Although the Sedna XQuery executor evaluates queries in a lazy manner, all
external function calls are evaluated in an eager manner.

\subsubsection*{Using External Functions}
To use an external function you need to declare this function in prologue with
\verb!external! keyword instead of function body. Then it may be used normally:

\small{
\begin{verbatim}
declare function se:f($a as xs:integer) as $xs:integer external;
f(10)
\end{verbatim}}


\subsubsection*{Creating External Functions}
External functions must be written in C/C++. To implement a new XQuery function
\verb!func! you should write the following C (or C++) functions: \verb!func!,
\verb!func_init! and \verb!func_deinit!. When executor decides that it needs to
use an external function, first it initializes this function by calling
\verb!func_init!, after that it will call \verb!func! to compute results as many
times as needed. When some external function is not needed anymore, executor
calls \verb!func_deinit! (which probably will free any memory allocated by
\verb!func_init!). Each one of the three functions receives an
\verb!SEDNA_EF_INIT!\footnote{All needed types and constants are defined in the
sedna\_ef.h file, located in the include directory of the Sedna distribution.
See Section ``Sedna Directory Structure'' in \cite{doc:admin} to learn where the
include directory is located.} structure as a parameter. This structure has
several fields that are initialized by executor before any \verb!func_init! or
\verb!func_deinit! calls:
\begin{verbatim}
typedef struct sedna_ef_init
{
    void *(*sedna_malloc)(size_t);
    void (*sedna_free)(void *);
    SEDNA_SEQUENCE_ITEM *item_buf;
} SEDNA_EF_INIT;
\end{verbatim}
The fields of this structure may be used in your implementation:
\begin{itemize}
\item \verb!sedna_malloc! is a pointer to a malloc function which must be used
to allocate memory for function results, this memory will be automatically freed
by the query executor. It may also be used to allocate memory for internal use,
such memory must be freed manually using the \verb!sedna_free! function.
\item \verb!sedna_free! is a pointer to free function that releases memory
allocated using \verb!sedna_malloc! function.
\item \verb!item_buf! is a pointer to a preallocated \verb!SEDNA_SEQUENCE_ITEM!
which may be used to store results (this allows to avoid using
\verb!sedna_malloc! function when result is a single atomic non-string value)
\end{itemize}

\verb!func!, \verb!func_init! and \verb!func_deinit! must have specific
signatures:
\begin{itemize}
\item \verb!func()! (required) -- computes external function results. This
function has the following signature:
\begin{verbatim}
SEDNA_SEQUENCE_ITEM *func(SEDNA_EF_INIT *init,
                          SEDNA_EF_ARGS *args,
                          char * error_msg_buf);
\end{verbatim}
\begin{citemize}
\item\verb!init! is a pointer to the \verb!SEDNA_EF_INIT! structure which was
passed to \verb!func_init! function (if written);
\item\verb!args! is a pointer to the \verb!SEDNA_EF_ARGS! structure which
contains all function arguments;
\item\verb!error_msg_buf! is a pointer to the string buffer used for specifying
error message if function invocation fails. Maximum message length is
\verb!SEDNA_ERROR_MSG_BUF_SIZE! bytes, including the null character \verb!'\0'!.
\end{citemize}

\item \verb!func_init()! (optional) -- the initialization function. It can be
used to allocate any memory required by the main function. This function has the
following signature:
\begin{verbatim}
void func_init(SEDNA_EF_INIT *init, char * error_msg_buf);
\end{verbatim}
\begin{citemize}
\item\verb!init! is a pointer to the \verb!SEDNA_EF_INIT! structure (the pointer
to this structure will be passed then to \verb!func! and \verb!func_deinit!
functions);
\item\verb!error_msg_buf! is a pointer to the string buffer used for specifying
error message if function invocation fails. Maximum message length is
\verb!SEDNA_ERROR_MSG_BUF_SIZE!, including the null character \verb!'\0'!.
\end{citemize}

\item \verb!func_deinit()! (optional) -- the deinitialization function. It
should deallocate any memory allocated by the initialization function. This
function has the following signature:
\begin{verbatim}
void func_init(SEDNA_EF_INIT *init, char * error_msg_buf);
\end{verbatim}
\begin{citemize}
\item\verb!init! is a pointer to the \verb!SEDNA_EF_INIT! structure which was
passed to \verb!func_init! function (if written);
\item\verb!error_msg_buf! is a pointer to the string buffer used for specifying
error message if function invocation fails. Maximum message length is
\verb!SEDNA_ERROR_MSG_BUF_SIZE!, including the null character \verb!'\0'!.
\end{citemize}
\end{itemize}

When \verb!func!, \verb!func_init! or \verb!func_deinit! is being executed
\verb!error_msg_buf! contains an empty string. If function succeedes, it should
leave this value empty. In case of error a non-empty string (error description)
must be placed in \verb!error_msg_buf! (if you place an empty string in
\verb!error_msg_buf! executor assumes that function execution was successful).

Each shared library must also export an null-terminated array with the names
of the XQuery functions defined by this library:

\begin{verbatim}
char const *ef_names[] = {"func", NULL};
\end{verbatim}

The file \verb!sedna_ef.h! defines several types for representing function
arguments and results:

\begin{itemize}
\item \verb!SEDNA_ATOMIC_TYPE! -- represents an atomic type, defined as:
\begin{verbatim}
typedef enum sedna_atomic_type {
     SEDNATYPE_integer,
     SEDNATYPE_float,
     SEDNATYPE_double,
     SEDNATYPE_string
} SEDNA_ATOMIC_TYPE;
\end{verbatim}

\item \verb!SEDNA_ATOMIC_VALUE! -- represents an atomic value, defined as:
\begin{verbatim}
typedef int     SEDNA_integer;
typedef float   SEDNA_float;
typedef double  SEDNA_double;
typedef char   *SEDNA_string;
typedef struct sedna_atomic_value {
    SEDNA_ATOMIC_TYPE type;
    union	{
        SEDNA_integer   val_integer;
        SEDNA_float     val_float;
        SEDNA_double    val_double;
        SEDNA_string    val_string;
    };
} SEDNA_ATOMIC_VALUE;
\end{verbatim}

Memory for values that are pointers (i.e. \verb!SEDNA_string!) MUST be allocated
using the malloc function passed in the \verb!SEDNA_EF_INIT! structure.

\item \verb!SEDNA_SEQUENCE_ITEM! -- represents a node in a linked list of atomic
values, defined as:
\begin{verbatim}
typedef struct sedna_sequence_item {
    SEDNA_ATOMIC_VALUE	data;
    struct sedna_sequence_item	*next;
} SEDNA_SEQUENCE_ITEM;
\end{verbatim}

Linked lists are used to represent sequences of atomic values. An empty sequence
is presented by a \verb!NULL! pointer. If \verb!func! needs to return a sequence
of values, memory for nodes MUST be allocated using the malloc function passed
in \verb!SEDNA_EF_INIT! structure.

\item \verb!SEDNA_EF_ARGS! -- represents an array of arguments passed to a
function, defined as:
\begin{verbatim}
typedef struct sedna_ef_args {
    int length;
    SEDNA_SEQUENCE_ITEM **args;
} SEDNA_EF_ARGS;
\end{verbatim}
\end{itemize}


\subsubsection*{Location of External Function Libraries}
Compiled libraries must be placed in the directory \verb!lib! that is (1) in the
same directory where the directory \verb!data! with database data is located or
(2) in the directory \verb!<db_name>_files! where database data are
stored\footnote{See Section ``Sedna Directory Structure'' in \cite{doc:admin} to
learn where database data are located}. Libraries that are database-independent
should be placed in (1). Libraries that are database-specific should be placed
in (2). Overloaded functions are not allowed. If two libraries located in (1)
and (2) contain functions with the same name, a function from the library in (2)
is called. If libraries in the same directory (1 or 2) contain functions with
the same name, it is not specified which one is called.

There is a sample external function code available in the folder:
\begin{verbatim}
     [win:] INSTALL_DIR\examples\api\external-functions\c\
     [nix:] INSTALL_DIR/examples/api/external-functions/c/
\end{verbatim}
where \verb!INSTALL_DIR! refers to the directory where Sedna is installed.


%===============================================================================
%             XQuery Options and Extensions: Runtime Properties
%===============================================================================
\subsubsection{Runtime Properties}

The \verb!se:get-property! function provides a method for applications to
determine in runtime the current values of system parameters, configurable
limits, environment information. The name argument specifies the system variable
to be queried. The function is defined within the predefined Sedna namespace
(\verb!se! prefix) as follows:

\begin{verbatim}
se:get-property($name as xs:string) as item()
\end{verbatim}

The available \verb!names! are as follows:

\begin{itemize}
\item\verb!$user! - retrieves string which contains current user name
\end{itemize}


%===============================================================================
%                               Update Language
%===============================================================================
\subsection{Update Language}
\label{upd-lang}

The update language is based on the XQuery update proposal by Patrick Lehti
\cite{paper:query-update} with the number of improvements.

\begin{note}
The result of each update statement, shouldn't break the well-formedness and
validness of XML entities, stored in the database. Otherwise, an error is
raised.
\end{note}

Sedna provides several kinds of update statements:
\begin{citemize}
\item\verb!INSERT! statement inserts zero or more nodes into a designated
position with respect to a target nodes;
\item\verb!DELETE! statement removes target nodes from the database with theirs
descendants;
\item\verb!DELETE_UNDEEP! statement removes target nodes from the database
preserving theirs content;
\item\verb!REPLACE! statement replaces target nodes with a new sequence of zero
or more nodes;
\item\verb!RENAME! statement changes the name of the target nodes.
\end{citemize}
The syntax and semantics of these expressions are described in the following
sections.


\subsubsection*{Insert Statement}
The insert statement inserts result of the given expression at the position
identified by the \verb!into!, \verb!preceding! or \verb!following! clauses:

\begin{verbatim}
UPDATE
insert SourceExpr (into|preceding|following) TargetExpr
\end{verbatim}
\verb!SourceExpr! identifies the ordered sequence of the nodes to be inserted.
The \verb!into!, \verb!preceding! or \verb!following! clause identifies the
position. For each node in the result sequence of \verb!TargetExpr!, the result
sequence of \verb!SourceExpr! is inserted to the position identified by the
\verb!into!, \verb!preceding! or \verb!following! clauses. If the \verb!into!
clause is specified, the sequence is appended to the random position of the
child sequence for each node in the result of \verb!TargetExpr!. If the
\verb!preceding! clause is specified, the sequence is appended before each node
in the result of \verb!TargetExpr!. If the \verb!following! clause is specified,
the sequence is appended after each node in the result of \verb!TargetExpr!.

Error is raised if one of the following conditions is met:
\begin{itemize}
\item There are non-element nodes in the result of the \verb!TargetExpr!
expression evaluation in case of the \verb!into! clause;
\item There are temporary nodes in the result of the \verb!TargetExpr!
expression evaluation (a node is considered \emph{temporary}, if it is created
as the result of the XQuery constructor evaluation).
\end{itemize}

For example, the following update statement inserts new \emph{warning} element
into all \emph{blood\_pressure} elements which have \emph{systolic} value
greater then 180:

\begin{verbatim}
UPDATE
insert <warning>High Blood Pressure!</warning>
preceding doc("hospital")//blood_pressure[systolic>180]
\end{verbatim}


\subsubsection*{Delete Statement}
The \verb!DELETE! statement removes persistent nodes from the database. It
contains a subexpression, that returns the nodes to be deleted.

\begin{verbatim}
UPDATE
delete Expr
\end{verbatim}
\verb!Expr! identifies the nodes to be removed from the database. Note, that
nodes are removed from the database with all their descendants.

Error is raised if one of the following conditions is met:
\begin{itemize}
\item There are atomic values in the result of the \verb!Expr! expressions;
\item There are temporary nodes in the result of the \verb!Expr! expression
evaluation (a node is considered \emph{temporary}, if it is created as the
result of the XQuery constructor evaluation).
\end{itemize}

The following update statement deletes all \emph{blood\_pressure} nodes which
contain \emph{systolic} value higher than 180:

\begin{verbatim}
UPDATE
delete doc("hospital")//blood_pressure[systolic>180]
\end{verbatim}


\subsubsection*{Delete Undeep Statement}
The \verb!DELETE_UNDEEP! statement removes nodes identified by \verb!Expr!, but
in contrast to the \verb!DELETE! statement it leaves the descendants of the
nodes in the database.

\begin{verbatim}
UPDATE
delete_undeep Expr
\end{verbatim}
\verb!Expr! identifies the nodes to be removed from the database.

Error is raised if one of the following conditions is met:
\begin{itemize}
\item There are atomic values in the result of the \verb!Expr! expressions;
\item There are temporary nodes in the result of the \verb!Expr! expression
evaluation (a node is considered \emph{temporary}, if it is created as the
result of the XQuery constructor evaluation).
\end{itemize}

Consider the following example. The document named \verb!a.xml! before update:
\begin{verbatim}
<A>
  <B>
    <C/>
    <D/>
  </B>
</A>
\end{verbatim}
The following delete undeep statement removes \emph{B} nodes and makes \emph{C}
and \emph{D} nodes children of the \emph{A} element:
\begin{verbatim}
UPDATE
delete_undeep doc("a.xml")//B
\end{verbatim}
This is how the \verb!a.xml! document will look after the update:
\begin{verbatim}
<A>
  <C/>
  <D/>
</A>
\end{verbatim}


\subsubsection*{Replace Statement}
The \verb!REPLACE! statement is used to replace nodes in an XML document in the
following manner:

\begin{verbatim}
UPDATE
replace $var [as type] in SourceExpr
with TargetExpr($var)
\end{verbatim}
Replace statement iterates over all the nodes returned by the \verb!SourceExpr!,
binding the variable \verb!$var! to each node. For each binding the result of
the \verb!TargetExpr($var)! expression is evaluated. Each node returned by the
\verb!SourceExpr! is replaced with the returned sequence of nodes. Note that
\verb!TargetExpr! is executed over the original document without taking into
account intermediate updates performed during execution of this statement.

Error is raised if one of the following conditions is met:
\begin{itemize}
\item There are atomic values in the result of the \verb!SourceExpr! or
\verb!TargetExpr! expressions;
\item There are temporary nodes in the result of the \verb!SourceExpr!
expression evaluation (a node is considered \emph{temporary}, if it is created
as the result of the XQuery constructor evaluation).
\end{itemize}

The \verb!$var! variable bound in \verb!replace! clause may have an optional
type declaration. If the type of a value bound to the variable does not match
the declared type, an error is raised.

In the following example the salary of persons named "John" is doubled.

\begin{verbatim}
UPDATE
replace $p in doc("foo.xml")/db/person[name="John"]
with
<person>
{($p/@*,
  $p/node()[not(self::salary)],
  for $s in $p/salary
  return <salary>{$s*2}</salary>)}
</person>
\end{verbatim}


\subsubsection*{Rename Statement}
The \verb!RENAME! statement is used to change the qualified name of an element
or attribute:

\begin{verbatim}
UPDATE
rename TargetExpr on QName
\end{verbatim}
Rename statement changes name property of the all nodes returned by the
\verb!TargetExpr! expression with a new QName.

Error is raised if one of the following conditions is met:
\begin{itemize}
\item There are items which are not element or attribute nodes in the result of
the \verb!TargetExpr! expression evaluation;
\item There are temporary nodes in the result of the \verb!TargetExpr!
expression evaluation (a node is considered \emph{temporary}, if it is created
as the result of the XQuery constructor evaluation).
\end{itemize}

The following expression changes the name of all the \verb!job! elements without
changing their contents:
\begin{verbatim}
UPDATE
rename doc("foo.xml")//job on profession
\end{verbatim}


%===============================================================================
%                                 Bulk Load
%===============================================================================
\subsection{Bulk Load}
\label{bulk-load}

To bulk load a stand alone document use the following statements:
\begin{verbatim}
LOAD "path_to_file" "document_name"
\end{verbatim}
The first parameter is a path to the file which contains a document to be
loaded. The second parameter is the name for this document in the database.

To load document into a collection, use the following statement:
\begin{verbatim}
LOAD "path_to_file" "document_name" "collection_name"
\end{verbatim}
The first parameter is a path to the file which contains a document to be
loaded. The second parameter is the name for this document in the database. The
third parameter is the collection name to load the document into.

For performing bulk load not from the source file but from an input stream,
use the following statements (first for loading stand alone document, second -
for loading into a collection):
\begin{verbatim}
LOAD STDIN "document_name"
\end{verbatim}
\begin{verbatim}
LOAD STDIN "document_name" "collection_name"
\end{verbatim}

Compared to the above bulk load statements, here the \verb!"file_name"! is
replaced by the keyword \verb!STDIN! to denote that the file to be loaded is
taken from the input stream. Characters in the input stream must form a
well-formed XML document, which is loaded into the database and named as
specified by \verb!"document_name"!. If \verb!collection_name! is set, the
document is loaded into the specified collection of the database.

By default, the standard input stream is used. You can redirect a different
input stream to be used as an input for bulk load. For example, an XML document
produced by some program as its output can be loaded to a Sedna database in a
stream-wise fashion. To redirect the input when working from a command line, you
can use the functionality provided by your operation system. Java and Scheme
APIs provide additional wrappers for bulk load from stream, such that the input
stream can be specified by an additional argument of a function call.

By default, Sedna removes boundary whitespace according to the boundary-space
policy defined in \cite{paper:query-language}. To control boundary whitespace
processing, use \verb!boundary-space declaration! \cite{paper:query-language} in
the prolog of the \verb!LOAD! statement. The following example illustrates a
boundary-space declaration that instructs Sedna to preserve whitespace while
loading \verb!auction.xml! document:

\begin{verbatim}
declare boundary-space preserve;
LOAD "auction.xml" "auction"
\end{verbatim}

Notice, that heavy bulk-loads might be greatly optimized by setting
\verb!SEDNA_LOG_AMOUNT! connection attribute to \verb!SEDNA_LOG_LESS! (see
Section \ref{session-option-capi} for more information).


%===============================================================================
%                         Data Definition Language
%===============================================================================
\subsection{Data Definition Language}

This section describes Sedna Data Definition Language (DDL) that is used to
create and manage the database structures that will hold data.

Most of parameters of Sedna DDL are computable and specified as XQuery
expressions. The expected type of all the parameters is \verb!xs:string!. All
parameters are evaluated and atomized. If the atomized value is not of
\verb!xs:string!, a dynamic error is raised.


%===============================================================================
%           Data Definition Language: Managing Standalone Documents
%===============================================================================
\subsubsection{Managing Standalone Documents}
\begin{verbatim}
CREATE DOCUMENT doc-name-expr
\end{verbatim}

The \verb!CREATE! \verb!DOCUMENT! statement creates a new standalone document
with the name that is the result of \verb!doc-name-expr!.

\begin{verbatim}
DROP DOCUMENT doc-name-expr
\end{verbatim}

The \verb!DROP! \verb!DOCUMENT! statement drops the standalone document with the
name that is the result of \verb!doc-name-expr!.

For example, next statement:
\begin{verbatim}}
CREATE DOCUMENT "report"
\end{verbatim}
creates a documentnamed "report", while:
\begin{verbatim}
DROP DOCUMENT "report"
\end{verbatim}

There is a system document \verb!$documents! which lists all available documents
and collections. For details on retrieving metadata see \ref{managing-metadata}
section.


%===============================================================================
%             Data Definition Language: Managing Collections
%===============================================================================
\subsubsection{Managing Collections}

Sedna provides a mechanism of organizing multiple documents into a collection.
Collection provides a uniform way of writing XQuery and XML update statements
addressed to multiple documents at once. Collections are preferable for
situations when a group of documents is to be queried/updated by means of not
referring to their individual document names, but according to some conditions
over their content.

In a Sedna database, a document can be either a standalone one (when it doesn't
belong to any collection) or belonging to some collection. Compared to
standalone documents, all documents within a given collection have a common
descriptive schema. The common descriptive schema (which can be considered as a
union of individual descriptive schemas for all documents that belong to a
collection) allows addressing XQuery and XML update queries to all members of a
collection.

Below is the specification of syntax and semantic of statements that manage
collections.

\begin{verbatim}
CREATE COLLECTION coll-name-expr
\end{verbatim}

The \verb!CREATE! \verb!COLLECTION! statement creates a new collection with the
name that is the result of \verb!coll-name-expr!.

For example, \verb!CREATE COLLECTION! \verb!"mails"! creates a collection named
"mails".

XML documents can be loaded into the collection, as previously described in
section \ref{bulk-load}.

To access a single document from collection in an XQuery or XML update query,
the \verb!document! function accepts a collection name as its second optional
argument:
\begin{verbatim}
doc($doc as xs:string,
    $col as xs:string) as document-node()
\end{verbatim}
The function returns the document with the \verb!$doc! name that belongs to the
collection named \verb!$col!.

\begin{verbatim}
fn:collection($col as xs:string?) as document-node()*
\end{verbatim}
The function \verb!collection! can be called from any place within an XQuery or
XML update query where the function call is allowed. The \verb!collection!
function returns the sequence of all documents that belong to the collection
named \verb!$col!. The relative order of documents in a sequence returned by
\verb!collection! function is currently undefined in Sedna.

Conventional XQuery predicates can be used for filtering the sequence returned
by the \verb!collection! function call, for selecting certain documents that
satisfy the desired condition.

\begin{verbatim}
CREATE DOCUMENT doc-name-expr IN COLLECTION coll-name-expr
\end{verbatim}

This statement creates a new document named \verb!doc-name-expr! in a collection
named \verb!coll-name-expr!.

For example, the following statement:
\begin{verbatim}
CREATE DOCUMENT 'mail' IN COLLECTION 'mails='
\end{verbatim}
creates a document named "mail" in the collection named "mails".

\begin{verbatim}
DROP DOCUMENT doc-name-expr IN COLLECTION coll-name-expr
\end{verbatim}

The \verb!DROP DOCUMENT IN COLLECTION! statement drops the document named
\verb!doc-name-expr! located in the collection named \verb!coll-name-expr!.

\begin{verbatim}
DROP COLLECTION coll-name-expr
\end{verbatim}

The \verb!DROP COLLECTION! statement drops the collection with the
\verb!coll-name-expr! name from the database. If the collection contains any
documents, these documents are dropped as well.

\begin{verbatim}
RENAME COLLECTION old-name-expr INTO new-name-expr
\end{verbatim}

The \verb!RENAME COLLECTION! statement renames collection with the name that is
result of the \verb!old-name-expr!. The new name is assigned which is result of
the \verb!new-name-expr!. Both result of the \verb!old-name-expr! and result of
the \verb!new-name-expr! after atomization applied must be either of type
\verb!xs:string! (or derived) or promotable to \verb!xs:string!.

There is a system document \verb!$collections! which lists all available
collections. For details on retrieving metadata see \ref{managing-metadata}
section.


%===============================================================================
%             Data Definition Language: Managing Value Indices
%===============================================================================
\subsubsection{Managing Value Indices}
\label{sec:managing-value-indices}

Sedna supports value indices to index XML element content and attribute values.
Index could be based on two different structure types: B+ tree and BST
(\emph{B}lock \emph{S}tring \emph{T}rie). Below is the description of
statements to manage indices.

\begin{verbatim}
CREATE INDEX title-expr
ON Path1 BY Path2
AS type
[USING tree-type]
\end{verbatim}

The \verb!CREATE INDEX! creates an index on nodes (specified by \verb!Path1!) by
keys (specified by \verb!Path2!).

\verb!Path1! is an XPath expression without any filter expressions that
identifies the nodes of a document or a collection that are to be indexed.
\verb!Path2! is an XPath expression without any filter expressions that
specifies the relative path to the nodes whose string-values are used as keys to
identify the nodes returned by the \verb!Path1! expression. The \verb!Path2!
expression should not start with '/' or '//'. The full path from the root of
documents (that may be in a collection) to the key nodes is \verb!Path1/Path2!.

For instance, let \verb!Path1! be \verb!doc("a")/b/c! and \verb!Path2! be
\verb!d!. Let \verb!X! be the node returned by the \verb!Path1! expression, and
\verb!Y! be one of the nodes returned by the \verb!doc("a")/b/c/d! expression.
If \verb!Y! is the descendant of \verb!X!, then the value of \verb!Y! is used as
the key for searching the node \verb!X!.

\verb!title-expr! is the title of the index created. It should be unique for
each index in the database.

\verb!type! is an atomic type which the value of the keys should be cast to. The
following types are supported: \verb!xs:string!, \verb!xs:integer!,
\verb!xs:float!, \verb!xs:double!, \verb!xs:date!, \verb!xs:time!,
\verb!xs:dateTime!, \verb!xs_yearMonthDuration!, \verb!xs_dateTimeDuration!.

\verb!tree-type! defines the structure that would be used for index storage.
This argument is optional. Index is stored using B+ tree structure by default
and it's a good choice in the general case. But there is one more implemented
structure that could show great disk-space economy in certain situations. BST is
based on prefix tree (or \emph{trie}) conception. Main distinguishing features
are:
\begin{enumerate}
\item {BST can handle strings with any length.}
\item {If you want  to index data by fields that contain strings with repeating
prefixes (e.g: URLs, URIs) BST would be a good choice for you.}
\end{enumerate}
In the case of appropriate usage BST can store indexes up to 4 times more
compressed with the same search speed in comparison with B+ tree.
The following \verb!tree-type! are supported: \verb!"btree"! for B+ tree (default),
\verb!"bstrie"! for BST.


In the following example, people are indexed by the names of their cities. To
generate the index keys, city names are cast to the \verb!xs:string! type. B+
tree is used for index storage.

\begin{verbatim}
CREATE INDEX "people"
ON doc("auction")/site//person BY address/city
AS xs:string
\end{verbatim}

The following example is exactly the same as the previous but uses BST for index
storage:

\begin{verbatim}
CREATE INDEX "people"
ON doc("auction")/site//person BY address/city
AS xs:string
USING "bstrie"
\end{verbatim}


To remove an index, use the following statement:
\begin{verbatim}
DROP INDEX title-expr
\end{verbatim}

The \verb!DROP INDEX! statement removes the index named \verb!title-expr! from
the database.

\begin{note} In the current version of Sedna, query executor does not use
indices automatically. You can enforce the executor to employ indices by using
the XQuery index-scan functions specified in section
\ref{sec:value-index-scan-fun}.
\end{note}


%===============================================================================
%             Data Definition Language: Managing Value Indices
%===============================================================================
\subsubsection{Managing Full-Text Indices}
\label{sec:managing-ft-indices}
Sedna is integrated with dtSearch \cite{link:dtsearch-engine}, a commercial text
retrieval engine, which provides full-text indices. The integration allows
combining XQuery with full-text search facilities. As dtSearch is a third party
commercial product, Sedna does not include dtSearch. If you are interested in
using Sedna with dtSearch, please contact us.

Below is the description of statements to manage dtSearch full-text indices in
Sedna.

\begin{verbatim}
CREATE FULL-TEXT INDEX title-expr
ON path
TYPE type
\end{verbatim}

The \verb!CREATE INDEX! indexes nodes (specified by \verb!path!) by a text
representation of the nodes. The text representations of the nodes are
constructed according to \verb!type! parameter value.

\verb!title-expr! is the title of the index created. It should be unique for
each full-text index in the database.

\verb!path! is an XPath expression without any filter expressions that
identifies the nodes of a document or a collection that are to be indexed. An
example of the \verb!path! expression is as follows
\verb!doc("foo")/library//article!.

\verb!type! specifies how the text representations of nodes are constructed when
the nodes are indexed. \verb!type! can have one of the following values:

\begin{itemize}
\item \verb!"xml"! -- the XML representations of the nodes are used;
\item \verb!"string-value"! -- the string-values of the nodes are used as
obtained using standard XQuery \verb!fn:string! function. The string-value of a
node is the concatenated contents of all its descendant text nodes, in document
order;
\item \verb!"delimited-value"! -- the same as \verb!"string-value"! but blank
characters are inserted between text nodes;
\item \verb!"customized-value"! \verb!((element-qname, type)! \verb!, ...!
\verb!(element-qname, type))! -- this option allows specifying types for
particular element nodes. Here \verb!element-qname! is a QName of an element,
\verb!type! can have one of the values listed above (i.e. \verb!"xml"!,
\verb!"string-value"!, \verb!"delimited-value"!). For those elements that are
not specified in the list, the \verb!"xml"! type is used by default.
\end{itemize}

In the following example, articles are indexed by their contents represented as
XML.

\begin{verbatim}
CREATE FULL-TEXT INDEX "articles"
ON doc("foo")/library//article
TYPE "xml"
\end{verbatim}

The example below illustrates the use of \verb!"customized-value"! type.
\begin{verbatim}
CREATE FULL-TEXT INDEX "messages"
ON doc("foo")//message
TYPE "customized-value"
     (("b", "string-value"),
     ("a", "delimited-value"))
\end{verbatim}

To remove a full-text index, use the following statement:
\begin{verbatim}
DROP FULL-TEXT INDEX title-expr
\end{verbatim}

The \verb!DROP! \verb!FULL-TEXT! \verb!INDEX! statement removes the full-text
index named \verb!title-expr! from the database.

\begin{note}
In the current version of Sedna, query executor does not use full-text indices
automatically. You can enforce the executor to employ indices by using the
XQuery full-text search functions specified in section \ref{sec:ft-fun}.
\end{note}


%===============================================================================
%                Data Definition Language: Managing Modules
%===============================================================================
\subsubsection{Managing Modules}
XQuery allows putting functions in library modules, so that they can be shared
and imported by any query. A library module contains a module declaration
followed by variable and/or function declarations. The module declaration
specifies its target namespace URI which is used to identify the module in the
database. For more information on modules see the XQuery specification
\cite{paper:query-language}.

Before a library module could be imported from an query, it is to be loaded into
the database. To load a module, use the following statement.

\begin{verbatim}
LOAD MODULE "path_to_file", ..., "path_to_file"
\end{verbatim}

Each \verb!path_to_file! specifies a path to the file. If only one parameter is
supplied, it refers to the file which contains the module definition. The module
definition can also be divided into several files. In this case all files must
have a module declaration with the same target namespace URI (otherwise an error
is raised).

For example, suppose that you have the following module stored in
\verb!math.xqlib!.

\begin{verbatim}
module namespace math = "http://example.org/math";

declare variable $math:pi as xs:decimal := 3.1415926;

declare function math:increment($num as xs:decimal) as xs:decimal {
    $num + 1
};

declare function math:square($num as xs:decimal) as xs:decimal {
    $num * $num
};
\end{verbatim}

You can load this module as follows.

\begin{verbatim}
LOAD MODULE "math.xqlib"
\end{verbatim}

Once an library module is loaded into the database, it can be imported into an
query using conventional XQuery module import \cite{paper:query-language}. For
example, you can import the above module as follows.

\begin{verbatim}
import module namespace math = "http://example.org/math";

math:increment(math:square($math:pi))

\end{verbatim}


To replace an already loaded module with new one, use the following statement.

\begin{verbatim}
LOAD OR REPLACE MODULE "path_to_file", ..., "path_to_file"
\end{verbatim}

To remove a library module from the database, use the following statement.

\begin{verbatim}
DROP MODULE "target_namespace_URI"
\end{verbatim}

It results in removing the library module with the given target namespace URI
from the database.

You can obtain information about modules loaded into the database by querying
the system collection named \verb!$modules! as follows
\verb!collection("$modules")!.


%===============================================================================
%                Data Definition Language: Retrieving Metadata
%===============================================================================
\subsubsection{Retrieving Metadata}
\label{managing-metadata}

You can retrieve various metadata about database objects (such as documents,
collections, indexes, etc.) by querying system documents and collections listed
below.

Names of the system documents and collections start with \verb!$! symbol. The
system documents and collections (except the ones marked with * symbol) are not
persistent but generated on the fly. You can query these documents as usual but
you cannot update them. Also these documents are not listed in the
\verb!$documents! system document.

\begin{citemize}
\item\verb!$documents! document -- list of all stand-alone documents,
collections and in-collection documents (except system meta-documents and
collection, like \verb!$documents! document itself);
\item\verb!$collections! document -- list of all collections;
\item\verb!$modules! document -- contains list of loaded modules with
theirs names;
\item\verb!$modules! (*) collection -- contains documents with precompiled
definitions of XQuery modules;
\item\verb!$indexes! document -- list of indexes with information about
them;
\item\verb!$ftindexes! document -- list of full-text indexes with
information about them (this document is available if Sedna is build with
\verb!SE_ENABLE_FTSEARCH! enabled);
\item\verb!$triggers! document -- list of triggers with information about
them (this document is available if Sedna is build with
\verb!SE_ENABLE_TRIGGERS! enabled);
\item\verb!$db_security_data! (*) document-- list of users and privileges on
database objects;
\item\verb!$schema! document -- descriptive schema of all documents and
collections with some schema-related information;
\item\verb!$errors! document -- list of all errors with descriptions;
\item\verb!$version! document -- version and build numbers;
\item\verb!$schema_<name>! document -- the descriptive schema of the
document or collection named \verb!<name>!;
\item\verb!$document_<name>! document -- statistical information about the
document named \verb!<name>!;
\item\verb!$collection_<name>! document -- statistical information about the
collection named \verb!<name>!.
\end{citemize}

The statistical information in \verb!$document_<name>! and
\verb!$collection_<name>! documents contains the following elements:

\begin{citemize}
\item\verb!total_schema_nodes! -- the number of the nodes of the descriptive
schema;
\item\verb!total_schema_text_nodes! -- the number of the attribute and text
nodes of the descriptive schema;
\item\verb!total_nodes! -- the number of the nodes of the document (or
collection);
\item\verb!schema_depth! -- the maximal depth of the document (or collection);
\item\verb!total_desc_blk! -- the number of the descriptor blocks occupied by
document (or collection);
\item\verb!total_str_blk! -- the number of the text blocks occupied by document
(or collection);
\item\verb!saturation! -- fill factor of the blocks (in percents);
\item\verb!total_innr_blk! -- the number of the descriptor blocks occupied by
document (or collection) except first and last blocks in each chain of blocks;
\item\verb!total_innr_size! -- the size of the inner blocks;
\item\verb!innr_blk_saturation! -- fill factor of the inner blocks (in
percents);
\item\verb!strings! -- the share of  the string blocks (in percents);
\item\verb!descriptors! -- the share of  the descriptor blocks (in percents);
\item\verb!nid! -- the share of the long labeling numbers' ($>11$) total size
(in percents);
\item\verb!indirection! -- the share of the indirection records' total size (in
percents);
\item\verb!total_size! -- the total size of the document (or collection), in
MBs;
\item\verb!string_size! -- the total size of the string blocks, in MBs;
\item\verb!descriptor_size! -- the total size of the descriptor blocks, in MBs;
\item\verb!nids_size! -- the total size of the long labeling numbers, in MBs;
\item\verb!free_space_in_str_blocks! -- the total size of the free space in the
string blocks;
\item\verb!indirection_size! -- the total size of the indirection records, in
MBs;
\item\verb!nids_size! -- the share of the indirection records' total size (in
percents);
\item\verb!STRINGS! -- the histogram of the xml data by its size;
\item\verb!NID! -- the histogram of the labeling numbers its length;
\end{citemize}


%===============================================================================
%                               XQuery Triggers
%===============================================================================
\subsection{XQuery Triggers}

XQuery triggers support in Sedna is provided as an XQuery extension. To create a
trigger into the Sedna database you have to issue the following \verb!CREATE!
\verb!TRIGGER! statement:

\begin{verbatim}
CREATE TRIGGER trigger-name
( BEFORE | AFTER ) (INSERT | DELETE | REPLACE)
ON path
( FOR EACH NODE | FOR EACH STATEMENT )
DO {
  Update-statement ($NEW, $OLD,$WHERE);
            . . .
  Update-statement ($NEW, $OLD,$WHERE);
  XQuery-statement ($NEW, $OLD, $WHERE);
}
\end{verbatim}

The \verb!DROP! \verb!TRIGGER! statement drops the trigger with the
name which is the result of the \verb!trigger-name-expression!:

\begin{verbatim}
DROP TRIGGER trigger-name-expression
\end{verbatim}

Triggers can be defined to execute either \emph{before} or \emph{after} any
\verb!INSERT!, \verb!DELETE! or \verb!REPLACE! operation, either once per
modified node (\emph{node-level} triggers), or once per XQuery statement
(\emph{statement-level} triggers). If a trigger event occurs, the trigger's
action is called at the appropriate time to handle the event.

\medskip
\noindent
\textbf{Create Trigger Parameters:}

\begin{itemize}
\item\verb!trigger-name! is the unique per database trigger name.

\item\verb!ON path! is XPath expression without any filter expression
(predicates) that identifies the nodes on which the trigger is set. That means
that the trigger fires when corresponding modification (insertion, deletion or
replacement) of those nodes occurs. This XPath expression is prohibited to have
predicates and parent axes.

\item\verb!FOR EACH NODE!/\verb!FOR EACH STATEMENT!: these key words mean the
trigger created is a \verb!node-level! or \verb!statement-level! trigger. With a
node-level trigger, the trigger action is invoked once for each node that is
affected by the update statement that fired the trigger. In contrast, a
statement-level trigger is invoked only once when an appropriate statement is
executed, regardless of the number of nodes affected by that statement.

\item\verb!BEFORE!/\verb!AFTER!: triggers are also classified as
\emph{before}-triggers and \emph{after}-triggers. \verb!BEFORE! keyword in
\verb!CREATE TRIGGER! statement means the trigger created is
\emph{before}-trigger; \verb!AFTER! keyword means the trigger created is
\emph{after}-trigger. Statement-level-before triggers fire before the statement
starts to do anything, while statement-level-after triggers fire at the very end
of the statement. Node-level-before triggers fire immediately before a
particular node is operated on, while node-level-after triggers fire immediately
after the node is operated on (but before any statement-level-after trigger).

\item\verb!DO!: trigger action is specified in braces \verb!{}! after the
\verb!DO! key word. Action contains zero or more update statements and an XQuery
query. It is a mandatory requirement that node-level trigger action ends with an
XQuery query, while this is optional for actions of statement-level triggers. It
is prohibited to use prolog in statements of the trigger action.

\item Transition variables \verb!$NEW!, \verb!$OLD! and \verb!$WHERE! are
defined for each node-level trigger firing and can be used in each statement of
the trigger action. These tree variables are defined as follows:
\begin{citemize}
\item For \verb!INSERT!: \verb!$NEW! is the node being inserted; \verb!$OLD! is
undefined; \verb!$WHERE! is the parent node in case in \emph{insert-into}
statement and sibling node in case of \emph{insert-preceding} and
\emph{insert-following} statements;
\item For \verb!DELETE!: \verb!$NEW! is undefined; \verb!$OLD! is the node being
deleted; \verb!$WHERE! is the parent of the deleted node;
\item For \verb!REPLACE!: \verb!$NEW! is the node being inserted during the
replacement; \verb!$OLD! is the node being replaced; \verb!$WHERE! is the parent
of the replaced node.
\end{citemize}
You cannot use transition variables in statement-level triggers.
\end{itemize}

XQuery statement in the trigger action of a node-level trigger can \emph{return
a node} to the calling executor, if they choose. A node-level-trigger fired
before an operation has the following choices:

\begin{itemize}
\item It can return \verb!empty sequence! to skip the operation for the current
node. This instructs the executor to not perform the node-level operation that
invoked the trigger (the insertion or replacement of a particular node).
\item For node-level \verb!INSERT! triggers only, the returned node becomes the
node that \emph{will be inserted}. This allows the trigger to modify the node
being inserted.
\item A node-level before trigger that does not intend to cause either of these
behaviors must be careful to return as its result the same node that was passed
in (that is, the \verb!$NEW! node for \verb!INSERT! and \verb!REPLACE! triggers.
For \verb!DELETE! triggers its returned value is ignored in all cases except
it is an empty sequence).
\end{itemize}

The trigger action return value is ignored for node-level triggers fired after
an operation, and for all statement-level triggers, and so they may as well
return empty sequence.

If more than one trigger is defined for the same event on the same document, the
triggers will be fired in alphabetical order by trigger name. In the case of
before triggers, the possibly-modified node returned by each trigger becomes the
input to the next trigger. If any before trigger returns empty sequence, the
operation is abandoned for that node and subsequent triggers are not fired.

Typically, node-level-before triggers are used for checking or modifying the
data that will be inserted or updated. For example, a before trigger might be
used to insert the current time node as a child of the inserting node, or to
check that two descendants of the inserting node are consistent.
Node-level-after triggers are most sensibly used to propagate the updates to
other documents, or make consistency checks against other documents. The reason
for this division of labor is that an after-trigger can be certain it is seeing
the final value of the node, while a before-trigger cannot; there might be other
before triggers firing after it. When designing your trigger-application note,
that node-level triggers are typically cheaper then statement-level ones.

If a trigger function executes update-statement then these commands may fire
other triggers again (cascading triggers). Currently \emph{trigger cascading
level} in Sedna is limited to 10.

\begin{note}
Currently is it prohibited in a trigger action to update the same document that
is being updated by the outer update statement that has fired this trigger.
\end{note}

\begin{figure}[h]
\begin{center}
{\footnotesize\begin{tabular}{|c||c|c|c|}
\hline
   & \emph{update}:  & \emph{update}:  & \emph{update}:  \\
   & INSERT   & DELETE   & REPLACE  \\
\hline
\hline
\emph{trigger event}:  & trigger path &   &  trigger path   \\
     INSERT            &    $>$=      &   &      $>$=       \\
                       & update path  &   &  update path    \\
\hline
\emph{trigger event}:  &  & trigger path &  trigger path \\
      DELETE           &  &     $>$=     &      $>$=     \\
                       &  & update path  &   update path \\
\hline
\emph{trigger event}: &  &   &  trigger path \\
      REPLACE         &  &   &      $>$=     \\
                      &  &   &  update path  \\
\hline

\end{tabular}}
\caption{\label{triggertab} Update and trigger path lengths needed for trigger
firing}
\end{center}
\end{figure}

Note also that hierarchy of the XML data sometimes can affect the trigger firing
in a complicated way. For example, if a node is deleted with all its descendant
subtree, then a \verb!DELETE!-trigger set on the descendants of the deleting
node is fired. In this situation \emph{length of trigger path} $>$= \emph{length
of update path}. In general, triggers fire according to the table in figure
\ref{triggertab}.


%===============================================================================
%                      XQuery Triggers: Trigger Examples
%===============================================================================
\subsubsection{Trigger Examples}

The following trigger is set on insertion of \verb!person! nodes. When some
\verb!person! node is inserted, the trigger analyzes its content and modifies it
in the following way. If the person is under 14 years old, the trigger inserts
additional child node \verb!age-group! with the text value 'infant': if the
person is older than 14 years old - the trigger inserts \verb!age-group! node
with value 'adult':

\small{
\begin{verbatim}
CREATE TRIGGER "tr1"
BEFORE INSERT
ON doc("auction")/site//person
FOR EACH NODE
DO {
  if($NEW/age < 14)
  then
    <person>{attribute id {$NEW/@id}}
            {$NEW/*}
              <age-group>infant</age-group>
    </person>
    else
    <person>{attribute id {$NEW/@id}}
            {$NEW/*}
            <age-group>adult</age-group>
    </person>;
}
\end{verbatim}}

The following trigger \emph{tr2} prohibits (throws exception) stake increase if
the person has already more than 3 open auctions:

\small{
\begin{verbatim}
CREATE TRIGGER "tr2"
BEFORE INSERT
ON doc("auction")/site/open_auctions/open_auction/bidder
FOR EACH NODE
DO {
 if(($NEW/increase > 10.5) and
  (count($WHERE/../open_auction
    [bidder/personref/@person=$NEW/personref/@person]) > 3))
 then error(xs:QName("tr2"),"The increase is prohibited")
 else ($NEW);
}
\end{verbatim}}

The following trigger \emph{tr3} cancels \verb!person! node deletion if there
are any open auctions referenced by this person:

\small{
\begin{verbatim}
CREATE TRIGGER "tr3"
BEFORE DELETE
ON doc("auction")/site//person
FOR EACH NODE
DO {
  if(exists(
    $WHERE//open_auction/bidder/personref/@person=$OLD/@id))
  then ()
  else $OLD;
}
\end{verbatim}}

The next statement-level trigger \emph{tr4} maintains statistics in the document
named \emph{stat}. When this trigger is fired, the update operation is completed
- that gives the possibility to make aggregative checks on the updated data.
After deletion of any node in the \emph{auction} document, the trigger refreshes
statistics in \emph{stat} and throws exception if there are more then 50 persons
left:

\small{
\begin{verbatim}
CREATE TRIGGER "tr4"
AFTER DELETE
ON doc("auction")//*
FOR EACH STATEMENT
DO {
  UPDATE replace $b in doc("stat")/stat with
  <stat>
    <open_auctions>
      {count(doc("auction")//open_auction)}
    </open_auctions>
    <closed_auctions>
      {count(doc("auction")//closed_auction)}
    </closed_auctions>
    <persons>
      {count(doc("auction")//person)}
    </persons>
  </stat>;

  UPDATE insert
  if(count(doc("auction")//person) < 10)
  then <warning>
         "Critical number of person left in the auction"
       </warning>
  else ()
  into doc("stat")/stat;
}
\end{verbatim}}


%===============================================================================
%                        Debug and Profile Facilities
%===============================================================================
\subsection{Debug and Profile Facilities}

Sedna provides several tracing, debug and perfomance profiling tools that can
help to monitor and analyze queries and update statements:

\begin{itemize}
\item\textbf{Trace} -- provides a query execution trace intended to be used in
debugging queries (section \ref{trace});
\item\textbf{Debug Mode} -- provides stack of physical operations when error is
raised (section \ref{debug-mode});
\item\textbf{Explain Query} -- shows complete physical execution plan of the
query or update statement (section \ref{explain});
\item\textbf{Profile Query} -- creates complete physical execution plan of the
query or update statement with profile information (execution time, number of
calls, etc) for each physical operation (section \ref{profile}).
\end{itemize}


%===============================================================================
%                    Debug and Profile Facilities: Trace
%===============================================================================
\subsubsection{Trace}
\label{trace}

Sedna supports standard XQuery function \verb!fn:trace! \cite{paper:query-fo}
providing user helper facility to trace queries. While executing XQuery query
using \verb!fn:trace! function intermediate results are shown to the user.

For example in Sedna Terminal the query with \verb!fn:trace! function will
provide the following output. Trace information is marked with \verb!##! string:

\medskip
\noindent
\textbf{Query:}
\begin{verbatim}
let $r:= trace(doc("region")/regions/*, "## ")
return $r[id_region="afr"]
\end{verbatim}

\medskip
\noindent
\textbf{Output:}

\small{
\begin{verbatim}
## <africa><id_region>afr</id_region></africa>

<africa>
  <id_region>afr</id_region>
</africa>

## <asia><id_region>asi</id_region></asia>
## <australia><id_region>aus</id_region></australia>
## <europe><id_region>eur</id_region></europe>
## <namerica><id_region>nam</id_region></namerica>
## <samerica><id_region>sam</id_region></samerica>
\end{verbatim}}

If you want to use trace facility in your application working through Sedna API
you should set your own debug handler as it is shown in \ref{exec-capi} section.


%===============================================================================
%               Debug and Profile Facilities: Debug Mode
%===============================================================================
\subsubsection{Debug Mode}
\label{debug-mode}

In addition to trace facility provided by standard XQuery \verb!fn:trace!
function (see previous section, \ref{trace} ) debug mode can be turned on in
Sedna Terminal (for details see "Sedna Terminal" section of the Sedna's
Administration Guide) or in your application using corresponding Sedna API
functions (see \ref{session-option-capi} section).

Each query in Sedna is represented and executed internally as a tree of the
physical operations. Debug mode is mechanism that allows to get stack of the
physical operations after dynamic error was raised. It serves two goals:

\begin{citemize}
\item localize error in the query's source code;
\item obtain information of the query execution process.
\end{citemize}

Let us consider the following query to illustrate execution in the debug mode:

\medskip
\noindent
\textbf{Query:}

\begin{verbatim}
(: In this query dynamic error will be raised   :)
(: due to "aaaa" is not castable to xs:integer. :)
declare function local:f($i as item()) as xs:integer
{
   $i cast as xs:integer
};

for $i in (1,2,3,"aaaa")
return local:f($i)
\end{verbatim}

\medskip
\noindent
\textbf{Output:}

\small{
\begin{verbatim}
1
2
3

<stack xmlns='http://www.modis.ispras.ru/sedna'>
  <operation name='PPCast' line='3' column='4' calls='7'/>
  <operation name='PPFunCall' line='7' column='8' calls='7'/>
  <operation name='PPReturn' line='6' column='5' calls='4'/>
  <operation name='PPQueryRoot' calls='4'/>
</stack>

SEDNA Message: ERROR FORG0001
Invalid value for cast/constructor.
Details: Cannot convert to xs:integer type
Query line: 3, column:4
\end{verbatim}}

As you can see in the output above each item of the operations stack list
consists of the following parts:

\begin{itemize}
\item operation name (\verb!PPCast! and \verb!PPFunCall! in the example);
\item calls counter - number of calls of the operation;
\item corresponding query and column numbers;
\item optional additional information (qualified name of the function in the
example).
\end{itemize}


%===============================================================================
%               Debug and Profile Facilities: Explain Query
%===============================================================================
\subsubsection{Explain Query}
\label{explain}

The explain statement has the following syntax:
\begin{verbatim}
EXPLAIN
{XQuery or Update statement to explain}
\end{verbatim}
Each query in Sedna is represented and executed internally as a tree of the
physical operations. With the help of \verb!EXPLAIN! statement you can obtain
detailed query execution plan which shows how Sedna executes this query.

\medskip
\noindent
The following query illustrates \verb!EXPLAIN! statement execution:

\medskip
\noindent
\textbf{Query:}
\begin{verbatim}
explain
declare function local:fact($i as xs:integer) as xs:integer {
    if ($i <= 1)
    then 1
    else $i * local:fact($i - 1)
};

local:fact(10)
\end{verbatim}

\medskip
\noindent
\textbf{Output:}

\small{
\begin{verbatim}
<prolog xmlns="http://www.modis.ispras.ru/sedna">
  <function id="0" function-name="local:fact" type="xs:integer">
    <arguments>
      <argument descriptor="0" type="xs:integer"/>
    </arguments>
    <operation name="PPIf" position="2:5">

      <operation name="PPLMGeneralComparison"
                 comparison="le" position="2:12">

        <operation name="PPVariable" descriptor="0"
                   variable-name="i" position="2:9"/>

        <operation name="PPConst" type="xs:integer"
                   value="1" position="2:15"/>
      </operation>
      <operation name="PPConst" type="xs:integer"
                 value="1" position="3:10"/>

      <operation name="PPCalculate" position="4:10">
        <operation name="BinaryOp" operation="*">
          <operation name="LeafAtomOp">

            <operation name="PPVariable" descriptor="0"
                       variable-name="i" position="4:10"/>
          </operation>

          <operation name="LeafAtomOp">
            <operation name="PPFunCall" id="0"
                       function-name="local:fact" position="4:15">
              <operation name="PPCalculate" position="4:26">
                <operation name="BinaryOp" operation="-">
                  <operation name="LeafAtomOp">
                    <operation name="PPVariable" descriptor="0"
                               variable-name="i" position="4:26"/>
                  </operation>
                  <operation name="LeafAtomOp">
                    <operation name="PPConst" type="xs:integer"
                               value="1" position="4:31"/>
                  </operation>
                </operation>
              </operation>
            </operation>
          </operation>
        </operation>
      </operation>

    </operation>
  </function>
</prolog>

<query xmlns="http://www.modis.ispras.ru/sedna">
  <operation name="PPQueryRoot">
    <operation name="PPFunCall" id="0"
               function-name="local:fact" position="7:1">

      <operation name="PPConst" type="xs:integer"
                 value="10" position="7:12"/>

    </operation>
  </operation>
</query>
\end{verbatim}}

Explain output consists of two parts (just like any XQuery query): prolog and
query body explanations. Prolog part includes complete information about all
declarations: namespaces, functions, global variables with complete physical
plan for each user defined function and global variable. Query body explanation
part describes physical tree of the query.

For each physical operation \verb!EXPLAIN! returns: name of the operation
(\verb!PPConst!, \verb!PPFunCall!, etc), corresponding position in the source
query (e.g. 4:31 means that operation \verb!PPConst! corresponds to the '1'
atomic at the line 4, column 26). Output may also contain additional information
depending on the operation type (for example, variable name for some
\verb!PPVariable! operations).


%===============================================================================
%               Debug and Profile Facilities: Profile Query
%===============================================================================
\subsubsection{Profile Query}
\label{profile}

The profile statement has the following syntax:
\begin{verbatim}
PROFILE
{XQuery or Update statement to profile}
\end{verbatim}
Each query in Sedna is represented and executed internally as a tree of the
physical operations. With the help of \verb!PROFILE! statement you can obtain
detailed tree of physical operation and execution time for each of them.

\medskip
\noindent
The following query illustrates \verb!PROFILE! statement execution:

\medskip
\noindent
\textbf{Query:}
\begin{verbatim}
profile fn:doc('TestSources/XMarkAuction.xml')//
            person[@id = "person0"]/name
\end{verbatim}

\medskip
\noindent
\textbf{Output:}

\small{
\begin{alltt}
<operation name="PPQueryRoot" time="13.426" calls="1">
  <operation name="PPAxisChild" step="child::element(name)"
                                time="13.426" calls="2">
    <operation name="PPReturn" time="13.426" calls="2">

      \emph{<operation name="PPAbsPath" root="document(auction)"
                                  path="descendant-or-self::node()"
                                  time="12.772" calls="85405"/>}

      <operation name="PPPred1" time="0.530" calls="85405">

        <operation name="PPAxisChild" step="child::element(person)"
                                      time="0.461" calls="86168">
          <operation name="PPVariable" descr="0"
                     time="0.380" calls="170808"/>
        </operation>

        <operation name="PPEQLGeneralComparison"
                   comparison="eq" time="0.013" calls="1528">

          <operation name="PPAxisAttribute"
                     step="attribute::attribute(id)"
                     time="0.001" calls="1527">

            <operation name="PPVariable" descr="1"
                       time="0.001" calls="1527"/>

          </operation>

          <operation name="PPConst"
                     type="xs:string" value="person0"
                     time="0.001" calls="1527"/>

        </operation>
      </operation>
    </operation>
  </operation>
</operation>
\end{alltt}}

Profiling output consists of two parts (just like any XQuery query): prolog and
query body explanations. Prolog part includes complete profile information for
global variables and user defined functions. Query body profile part describes
physical tree of the query and provides execution time and number of calls for
each physical operation.

For each physical operation \verb!PROFILE! returns: name of the operation
(\verb!PPConst!, \verb!PPFunCall!, etc), corresponding position in the source
query (e.g. 4:31 means that operation \verb!PPConst! corresponds to the '1'
atomic at the line 4, column 26), execution time of this operation and number of
calls. Output may also contain additional information depending on the operation
type (for example, variable name for some \verb!PPVariable! operations).

In above example you can see that \verb!PPAbsPath! operation takes almost all
time (12.772 seconds of 13.426 total) and was called 12772 times. Profiling in
this case shows that \verb!//! may be very hard to execute and it is much better
to use "single" XPath steps everywhere it is possible:

\medskip
\noindent
\textbf{Query:}
\begin{verbatim}
profile fn:doc('TestSources/XMarkAuction.xml')/
          site/people/person[@id = "person0"]/name
\end{verbatim}

\medskip
\noindent
\textbf{Output:}

\small{
\begin{alltt}
<operation name="PPQueryRoot" time="0.018" calls="1">

  <operation name="PPAxisChild" step="child::element(name)"
                                time="0.018" calls="2">

    <operation name="PPReturn" time="0.018" calls="2">
      <produces>
        <variable descriptor="0"/>
      </produces>

      \emph{<operation name="PPAbsPath"
                 root="document(auction)"
                 path="child::element(site)/child::element(people)"
                 time="0.001" calls="2"/>}

      <operation name="PPPred1" time="0.017" calls="2">
        <produces>
          <variable descriptor="1"/>
        </produces>

        <operation name="PPAxisChild" step="child::element(person)"
                                      time="0.001" calls="765">

          <operation name="PPVariable" descr="0"
                     time="0.000" calls="2"/>
        </operation>

        <operation name="PPEQLGeneralComparison"
                   comparison="eq" time="0.013" calls="1528">

          <operation name="PPAxisAttribute"
                     step="attribute::attribute(id)"
                     time="0.005" calls="1527">

            <operation name="PPVariable" descr="1"
                       time="0.003" calls="1527"/>

          </operation>
          <operation name="PPConst"
                     type="xs:string" value="person0"
                     time="0.000" calls="1527"/>
        </operation>
      </operation>
    </operation>
  </operation>
</operation>
\end{alltt}}


\newpage

%===============================================================================
%                  Sedna Programmer's Guide: Bibliography
%===============================================================================
\begin{thebibliography}{9}
\bibitem{doc:admin}
``Sedna Administration Guide'',
\url{http://modis.ispras.ru/sedna/adminguide/AdminGuide.html}

\bibitem{paper:data-model}
``XQuery 1.0 and XPath 2.0 Data Model'', W3C Recommendation,
\url{http://www.w3.org/TR/xpath-datamodel/}

\bibitem{paper:query-language}
``XQuery 1.0: An XML Query Language'', W3C Recommendation,
\url{http://www.w3.org/TR/xquery/}

\bibitem{paper:query-fo}
``XQuery 1.0 and XPath 2.0 Functions and Operators'', W3C Recommendation,
\url{http://www.w3.org/TR/xpath-functions/}

\bibitem{paper:query-serialization}
``XSLT 2.0 and XQuery 1.0 Serialization'', W3C Recommendation,
\url{http://www.w3.org/TR/xslt-xquery-serialization/}

\bibitem{paper:query-update} Patrick Lehti.
``Design and Implementation of a Data Manipulation Processor for a XML Query
Language'',
\url{http://www.lehti.de/beruf/diplomarbeit.pdf}

\bibitem{lib:pcre-lib}
``PCRE - Perl Compatible Regular Expressions'',
\url{http://www.pcre.org/}

\bibitem{paper:sedna-overview}
Maxim Grinev, Andrey Fomichev, Sergey Kuznetsov, Kostantin Antipin, Alexander
Boldakov, Dmitry Lizorkin, Leonid Novak, Maria Rekouts, Peter Pleshachkov.
``Sedna: A Native XML DBMS'',
\url{http://www.modis.ispras.ru/publications.htm}

\bibitem{paper:sedna-api} Rekouts Maria.
``Application Programming Interface for XML DBMS: design and implementation
proposal'',
\url{http://www.modis.ispras.ru/publications.htm}

\bibitem{paper:scheme-ql}
Noel Welsh, Francisco Solsona, Ian Glover.
``SchemeUnit and SchemeQL: Two little languages'',
Scheme Workshop 2002,
\url{http://schematics.sourceforge.net/schemeunit-schemeql.ps}

\bibitem{paper:sxml}
Oleg Kiselyov.
``SXML Specification, Revision 3.0'',
\url{http://www.okmij.org/ftp/Scheme/SXML.html}

\bibitem{paper:srfi-12}
William Clinger, R.\ Kent Dybvig, Matthew Flatt, and Marc Feeley.
``SRFI-12: Exception Handling'',
\url{http://srfi.schemers.org/srfi-12/srfi-12.html}

\bibitem{paper:chicken}
Felix L.\ Winkelmann.
``Chicken -- A practical and portable Scheme system'',
\url{http://www.call-with-current-continuation.org}

\bibitem{paper:sxpath}
Kirill Lisovsky, Dmitry Lizorkin.
``XML Path Language (XPath) and its functional implementation SXPath'',
Russian Digital Libraries Journal , 2003, Volume 6, Issue 4,
\url{http://www.elbib.ru/index.phtml?page=elbib/eng/journal/2003/part4/LL}

\bibitem{link:dtsearch-engine}
dtSearch Engine home page,
\url{http://www.dtsearch.com/PLF\_engine\_2.html}

\bibitem{doc:dtsearch}
dtSearch Web Help
\url{http://support.dtsearch.com/webhelp/dtsearch}

\end{thebibliography}

\end{document}

