
% File:  ProgGuide.tex
% Copyright (C) 2008 The Institute for System Programming of the Russian Academy of Sciences (ISP RAS)

\documentclass[a4paper,12pt]{article}
\makeatletter
\makeatother
%\usepackage[russian]{babel}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{theorem}
\usepackage{alltt}
\newtheorem{definition}{Definition}
{\theorembodyfont{\rmfamily} \newtheorem{proof}{Proof}}
\newtheorem{theo}{Theorem}
\newtheorem{note}{Note}

%\usepackage{tex4ht}

%to avoid processing \TocAt by latex
\newcommand{\TocAt}[6]{}
\newcommand{\comments}[1]{}

% Allows inserting tables
\usepackage{multirow}


\title{Sedna Programmer's Guide}
\date{}

%\comments{
\usepackage{ifthen}    % package for conditionals in TeX
% Switch for PdfLaTeX or LaTeX
\ifx\pdfoutput\undefined %%%% LaTeX %%%
  \usepackage[dvips]{epsfig}
\else %%% PdfLaTeX %%%
  \usepackage[pdftex]{graphicx}      %%% graphics for pdftex
  \usepackage[colorlinks=true, linkcolor=blue, 
              citecolor=blue, urlcolor=blue,
              pdftex,                %%% hyper-references for pdflatex
              bookmarks=true,        %%% generate bookmarks ...
              bookmarksnumbered=true,%%% ... with numbers
  ]{hyperref}
  \pdfadjustspacing=1    %%% force LaTeX-like character spacing
\fi %%% End of condition %%%

\hypersetup{
pdfauthor   = {Sedna Team},
pdftitle    = {Sedna Programmer's Guide}
}
%}

\begin{document}
\sloppy
\maketitle

\TocAt*{section,subsection,subsubsection}
\TocAt*{subsection,subsubsection}

\tableofcontents

\newpage

\section{Client Application Programming Interfaces}
The Sedna client application programming interfaces (APIs) provides programmatic access to Sedna from client applications developed in host programming languages. This section describes the client APIs distributed with Sedna.

\subsection{Java API}
The Java API provides programmatic access to XML data from the Java programming language. Using the Java API, applications written in the Java can access one or more databases of the Sedna DBMS and manipulate database data using the database language described in Section \ref{sec:DBLang}.

Application working with the Sedna DBMS through the Java API operates with the following notions of the Java API: session, transaction, statement, result.

\subsubsection{Sessions}
To start working with Sedna application has to open a session via establishing an authenticated connection with the server. The Java API defines the \verb!SednaConnection! interface to represent a session.

To open a session application uses static method \verb!getConnection! of the \verb!DatabaseManager! class.

\small{
\begin{verbatim}
 public static SednaConnection getConnection(java.lang.String url,
                                             java.lang.String DBName,
                                             java.lang.String user,
                                             java.lang.String password)
                                                    throws DriverException
\end{verbatim}
}
Parameters:

 \verb!url! - the name of the computer where the Sedna DBMS is running. This parameter may contain a port number. If the port number is not specified, the default port number (5050) is used.

 \verb!DBName! - the name of the database to connect.

 \verb!user! - user name.

 \verb!password! - user password.

If the connection is established and authentication succeeds the method returns an object that implements the \verb!SednaConnection! interface. Otherwise, \verb!DriverException! is thrown.

Application can close session using the \verb!close! method of the \verb!SednaConnection! interface.

\begin{verbatim}
 public void close() throws DriverException
\end{verbatim}

If the server does not manage to close connection properly the \verb!close! method throws \verb!DriverException!.

The \verb!isClosed! method retrieves whether this connection has been closed or not. A connection is closed if the method \verb!close! has been called on it or if certain fatal errors have occurred.

\begin{verbatim}
 public boolean isClosed()
\end{verbatim}

Setting connection into debug mode allows getting debug information when XQuery query fails due to some reason (see \ref{session-debug-mode} for details). To set the connection into debug mode use \verb!setDebugMode! method of \verb!SednaConnection! interface:

\begin{verbatim}
 public void setDebugMode(boolean debug)
\end{verbatim}

Parameters:

 \verb!debug! - set to \verb!true! to turn debug mode on; set to \verb!false! to turn debug mode off. Debug mode is off by default.

Sedna supports fn:trace function for debugging purpose also (see \ref{trace} for details). By default trace output is included into XQuery query result. You can turn trace output on/off using \verb!setTraceOutput! method of the \verb!SednaConnection! interface:

\begin{verbatim}
 public void setTraceOutput(boolean doTrace)
\end{verbatim}

Parameters:

 \verb!doTrace! - set to \verb!true! to turn trace output on; set to \verb!false! to turn trace output off. Trace output is on by default.






\subsubsection{Transactions}
Application can execute queries and updates against specified database only in the scope of a transaction. That is, once a session has been opened, application can begin a transaction, execute statements and commit (or rollback) this transaction.

In the session transactions are processed sequentially. That is, application must commit a begun transaction before beginning a new one.

To specify transaction boundaries application uses methods of the \verb!SednaConnection! interface:
\verb!begin!, \verb!commit!.

The \verb!begin! method begins a new transaction.

\begin{verbatim}
 public void begin() throws DriverException
\end{verbatim}

If the transaction has not begun successfully the \verb!begin! method throws \verb!DriverException!.

The \verb!commit! method commits a transaction.

\begin{verbatim}
 public void commit() throws DriverException
\end{verbatim}

If the transaction has not been committed successfully the \verb!commit! method throws \verb!DriverException!.

To rollback transaction the \verb!rollback! method is used.

\begin{verbatim}
 public void rollback() throws DriverException
\end{verbatim}

If the transaction has not been rollback successfully the \verb!rollback! method throws \verb!DriverException!.


The Java API does not provide auto-commit mode for transactions. That is, every transaction must be explicitly started (by means of \verb!begin!) and commited (by means of \verb!commit!). If session is closed (by means of \verb!close!) before a transaction committed, server does rollback for that transaction, and \verb!close! throws \verb!DriverException!.



\subsubsection{Statements}
The \verb!SednaStatement! interface provides methods for loading documents into the database, executing statements of the database language defined in Section \ref{sec:DBLang} and retrieving results that statements produce.
\verb!SednaStatement! object is created using the \verb!createStatement! method of the \verb!SednaConnection! interface:

\begin{verbatim}
 public SednaStatement createStatement() throws DriverException
\end{verbatim}

\verb!SednaStatement! object may only be created on an open connection. Otherwise, the  \verb!createStatement! method throws \verb!DriverException!.

To load the document into the database use:

\begin{verbatim}
 public void loadDocument(InputStream in, String doc_name)
                        throws DriverException, IOException
\end{verbatim}

The \verb!in! parameter is an input stream to get the document from. The \verb!doc_name! parameter is the name for this document in the database.

To load the document into the specified collection of the database use:

\begin{verbatim}
 public void loadDocument(InputStream in, String doc_name, String col_name)
                        throws DriverException, IOException
\end{verbatim}

The \verb!in! parameter is an input stream to get the document from. The \verb!doc_name! parameter is the name for this document in the database. The \verb!col_name! parameter is the name of the collection to load the document into.

To execute a statement the \verb!execute! methods of the \verb!SednaStatement! are used.

%As described in Section \ref{sec:DBLang} Sedna supports three types of statements: XQuery queries, updates and bulk load.
%For XQuery queries  the \verb!execute! methods retrieve the result of the XQuery query evaluation in the serialized form.

\begin{verbatim}
public boolean execute(java.lang.String queryText)
                                     throws DriverException
\end{verbatim}

The \verb!queryText! parameter contains the text of the statement.

\begin{verbatim}
public boolean execute(java.io.InputSteram in) throws DriverException
\end{verbatim}

The \verb!in! parameter is some input stream to read an XQuery statement from.

Some statements (such as XQuery statements or the retrieve metadata command) produce the result. In case of such statements, the \verb!execute! methods return true and the result can be obtained as described in Section \ref{sec:results}. In case of statements that do not produce the result (such as updates or bulk load), the \verb!execute! methods return false.

The results of XQuery queries to the Sedna DBMS can be represented either in XML or SXML~\cite{paper:sxml}. To specify the type of the result use:

\begin{verbatim}
public boolean execute(InputStream in, ResultType resultType)
                                        throws DriverException, IOException;
\end{verbatim}
\begin{verbatim}
public boolean execute(String queryText, ResultType resultType)
                                        throws DriverException, IOException;
\end{verbatim}

The \verb!resultType! parameter is either \verb!ResultType.XML! or \verb!ResultType.SXML!.


\subsubsection{Results}
\label{sec:results}
%If the query was not an update and the execution of that query succeeds, application can obtain a result of this query.

The \verb!SednaSerializedResult! interface represents the result of the statement evaluation. Application can obtain the result using the \verb!getSerializedResult! method of the \verb!SednaStatement! interface.

\begin{verbatim}
public SednaSerializedResult getSerializedResult()
\end{verbatim}

The result of the non-XQuery statement evaluation is retrieved as a sequence with only one item, where the item is a string. For example, in case of the retrieve descriptive schema command the result is a sequence with an item that is a descriptive schema represented as a string. The result of the XQuery statement evaluation is retrieved as a sequence of items, where every item is represented as a string.

Application can use the \verb!next! methods of the \verb!SednaSerializedResult! interface to iterate over the result sequence:

\begin{verbatim}
public String next() throws DriverException
\end{verbatim}

The method returns an item of the result sequence as a string. If the sequence has ended it returns null. It throws \verb!DriverException! in the case of error.

\begin{verbatim}
public int next(java.io.Writer writer) throws DriverException
\end{verbatim}

The method writes an item of the result sequence to some output stream using \verb!writer!. It returns 0 if an item was retrieved and written successful, and 1 if the result sequence has ended. It throws \verb!DriverException! in the case of error.

Please, notice, that in the current version of the Sedna DBMS application has to execute statements and use the results of their execution sequentially. To explain this note, suppose application execute a statement, obtains a result of that statement execution and iterates over this result. If, after that, application executes next statement, it cannot iterate over the result of the previous statement any more.

\subsubsection{Exceptions}

The \verb!DriverException! class provides information about errors that occur while application works with the Sedna DBMS through the Java API. \verb!DriverException! is also thrown when application loses its connection with the server.


\subsubsection{Code example}
In this section we provide fragments of an example program that uses the Java API to work with Sedna DBMS.

\small{
\begin{verbatim}
import ru.ispras.sedna.driver.*;

import java.io.*;
import java.net.*;
import java.util.*;

       ...
       ...

	   System.out.println("Client started\n");


  // Set up arguments for the call to the getConnection method.
       String url = "localhost";
       String dbname = "testdb";
       String user = "SYSTEM";
       String password = "MANAGER";
       String item;
       int count;

       SednaConnection con = null;
// Get a connection
       try{
         con = DatabaseManager.getConnection(url, dbname, user, password);


// begin transaction
         con.begin();

        // creates statements
         SednaStatement st1 = con.createStatement();
         SednaStatement st2 = con.createStatement();

        // execute a statement. the statement is a bluk load.
         System.out.println("Loading data");
         boolean call_res =
           st1.execute("LOAD \"..\data\region.xml\" \"region\"");
         if(!call_res) // if call_res is false the statement was an update
           {
            System.out.println("Bulk load succeeded");
            System.out.println("===============================\n");

           }

        // execute query.
         System.out.println("Executing query");
         call_res =
          st2.execute("document(\"region\")/*/*");
         if(call_res) // if call_res is true the statement
                       // was not an update and we can use
                       // SerializedResult object
          {
          	System.out.println("Result:");
            SednaSerializedResult pr1 = st2.getSerializedResult();
            item = null;
            item = pr1.next();
            count = 1;
            while(item!=null)
             {
                 System.out.println(count+" item: "+item);
                 item = pr1.next();
                 System.out.println("===============================\n");
                 count++;
             }
          }

         // execute update.
         System.out.println("Executing update");
         call_res =
          st2.execute("UPDATE delete document(\"region\")//africa");
         System.out.println("===============================\n");

        // execute query.
         System.out.println("Executing query");
         call_res = st2.execute("document(\"region\")/*/*");
         if(call_res)  // if call_res is true the statement was not
                       // an update and we can use PlaneResult object
          {
             System.out.println("Result:");
             SednaSerializedResult pr3 = st2.getSerializedResult();
             item = null;
             item = pr3.next();
             count = 1;
             while(item!=null)
              {
                  System.out.println(count+" item: "+item);
                  item = pr3.next();
                  System.out.println("===============================\n");
                  count++;
              }

 // commit the transaction
        con.commit();
     }

 // close the connection
   con.close();
   }
     catch(DriverException e)
       {
           System.out.println(e.toString());
       }
   ...
\end{verbatim}
}


The source code of this example program can be found in
\begin{verbatim}
[win:] INSTALL_DIR\examples\api\java\Client.java
\end{verbatim}
\begin{verbatim}
[nix:] INSTALL_DIR/examples/api/java/Client.java
\end{verbatim}
where \verb!INSTALL_DIR! refers to the directory where Sedna is installed.
%Before run the example make sure that the Sedna DBMS is running with the listener started. For more detail see the Sedna Administration Guide.

Before running the example make sure that the Sedna DBMS is installed and do the following steps:
\begin{enumerate}
\item Start Sedna by runing the following command:
\begin{verbatim}
se_gov
\end{verbatim}
If Sedna is started successfully it prints "GOVERNOR has been started in
the background mode".
\item Create a new database \verb!testdb! by running the following command:
\begin{verbatim}
se_cdb testdb
\end{verbatim}
If the database is created successfully it prints "The database 'testdb'
has been created successfully".
\item Start the testdb database by running the following command:
\begin{verbatim}
se_sm testdb
\end{verbatim}
If the database is started successfully it prints "SM has been started in
the background mode".
\end{enumerate}

You can compile and run the example by following the steps listed below:
\begin{enumerate}
\item In the file \verb!Client.java!, the \verb!url! parameter denotes the
 name of the computer where the server is running. If Sedna DBMS is not running
 on the same computer edit the file \verb!Client.java! to set the value of the \verb!url!
 parameter.
 This looks as something like the following:
 \begin{verbatim}String url = "computer-name";\end{verbatim}

if Sedna DBMS is running on the same computer you do not need to edit this parameter.
\item To compile the example, run the script
 \begin{verbatim}[win:] Clientbuild.bat\end{verbatim}
 \begin{verbatim}[nix:] Clientbuild.sh\end{verbatim}
 located in the same folder as \verb!Client.java!.

\item  To run the compiled example, use the script
 \begin{verbatim}[win:] Client.bat\end{verbatim}
 \begin{verbatim}[nix:] Client.sh\end{verbatim}
 located in the same folder as \verb!Client.java!.

\end{enumerate}

%==========================================================================
%
%                                  C API
%
%==========================================================================
\subsection{C API}
\label{c-api}
libsedna is the C application programmer's interface to Sedna XML DBMS. libsedna is a set of library functions that allow client programs to access one or more databases of Sedna XML DBMS
and manipulate database data using database language (XQuery and XUpdate) described in Section 2.

libsedna library is supplied with two header files: \verb!"libsedna.h"!, \verb!"sp_defs.h"!.
Client programs that use libsedna must include the header file libsedna.h, must link with the libsedna library and provide the compiler with the path to the
directory where \verb!"libsedna.h"!, \verb!sp_defs.h! files are stored.

For convenience three versions of libsedna are provided under Windows operating system:

\begin{enumerate}
\item\verb!libsednamt.lib! - static multi-threaded version built with /MT option. Use it if you compile your project with /MT[d] option.
\item\verb!libsednamd.lib! - static multi-threaded version built with /MD option. Use it if you compile your project with /MD[d] option.
\item\verb!sednamt.dll! - dynamic version. \verb!sednamt.lib! is import library.
\end{enumerate}


\subsubsection{Connecting to a Database}
Before working with Sedna an application has to declare variable of the \verb!SednaConnection! type and initialize it in the following manner:

\begin{verbatim}struct SednaConnection conn = SEDNA_CONNECTION_INITIALIZER;\end{verbatim}

\begin{note}
The initialization with \verb!SEDNA_CONNECTION_INITIALIZER! is mandatory for Sedna version 0.5 and earlier.
\end{note}
To start working with Sedna an application has to open a session via establishing an authenticated connection with the server using \verb!SEconnect!:
\begin{verbatim}
int SEconnect(SednaConnection* conn,
              const char* url,
              const char* db_name,
              const char* login,
              const char* password)
\end{verbatim}
This function opens a session to the database, using the following parameters:

\verb!conn! - is a pointer to an instance of SednaConnection type, that is associated with a session. The instance of SednaConnection type is initialized by the SEconnect if the session is open successfully.

\verb!url! - the name of the computer where the Sedna DBMS is running. This
parameter may contain a port number. If the port number is not specified, the
default port number (5050) is used.

\verb!db_name! -  the name of the database to connect.

\verb!login! - user name.

\verb!password! - user password.

\verb!SEconnect! returns:

positive values:

\verb!SEDNA_SESSION_OPEN! - connection to the database is established, authentication is passed successfully, and session is opened.

negative values:

\verb!SEDNA_AUTHENTICATION_FAILED! - authentication was not passed, session is not open.

\verb!SEDNA_OPEN_SESSION_FAILED! - failed to open session.

\verb!SEDNA_ERROR! - some error is occurred, session is not open.


To access multiple databases at one time or to better process its complex logic an application can have several sessions open at one time.

When an application finishes its work with the database, it must close the session. \verb!SEclose! finishes the session and closes the connection to the server. \verb!SEclose! also frees resourses that were equipped by the call to \verb!SEconnect! function, that is for every successful call to \verb!SEconnect! there must be a call to \verb!SEclose! in the client program. You must call \verb!SEclose! both when application finishes its work with the database, and when application cannot work with the database anymore due to some error.

\begin{verbatim}int SEclose(SednaConnection* conn)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type, associated with a session to be closed.

\verb!SEclose! returns:

positive value:

\verb!SEDNA_SESSION_CLOSED! - session is closed succeffully.

negative values:

\verb!SEDNA_CLOSE_SESSION_FAILED! - session was closed with errors.

\verb!SEDNA_ERROR! - some error occurred.

\subsubsection{Setting session options}
\label{session-option-capi}

An application can set attributes that govern aspects of a session using \verb!SEsetConnectionAttr!:

\begin{verbatim}
int SEsetConnectionAttr(struct SednaConnection *conn,
                                    enum SEattr attr,
                               const void* attrValue,
                                 int attrValueLength)
\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type, associated with a session to be closed.

\verb!attr! - an attribute to set (one of the predifined Sedna connection attributes listed below).

\verb!attrValue! - a pointer to the value to be associated with the attribute.

\verb!attrValueLength! - a length of the value in bytes.

\verb!SEsetConnectionAttr! returns:

positive value:

\verb!SEDNA_SET_ATTRIBUTE_SUCCEEDED! - the attribute was set successfully.

negative value:

\verb!SEDNA_ERROR! - some error occurred.

\begin{figure}
\begin{center}
{\footnotesize\begin{tabular}{|r|r|r|}
\hline
$Attribute$&$Attribute Value$&$Attribute Value Length$\\
\hline
\verb!SEDNA_ATTR_AUTOCOMMIT! & \verb!SEDNA_AUTOCOMMIT_ON!,	 & sizeof(int)\\
							 & \verb!SEDNA_AUTOCOMMIT_OFF! 	 & \\
\hline
\verb!SEDNA_ATTR_SESSION_DIRECTORY! & \emph{path to directory}	 & \emph{length of path}\\
\hline
\verb!SEDNA_ATTR_DEBUG! & \verb!SEDNA_DEBUG_ON!,	 & sizeof(int)\\
                        & \verb!SEDNA_DEBUG_OFF!      & \\
\hline
\verb!SEDNA_ATTR_CONCURRENCY_TYPE! & \verb!SEDNA_READONLY_TRANSACTION!,	 & sizeof(int)\\
                        & \verb!SEDNA_UPDATE_TRANSACTION!      & \\
\hline
\verb!SEDNA_ATTR_QUERY_EXEC_TIMEOUT! & \emph{time in seconds}	 & sizeof(int)\\
\hline
\verb!SEDNA_ATTR_MAX_RESULT_SIZE! & \emph{size in bytes}	 & sizeof(int)\\
\hline
\verb!SEDNA_LOG_AMMOUNT! & \verb!SEDNA_LOG_LESS!,   &sizeof(int) \\
                         & \verb!SEDNA_LOG_FULL!    & \\
\hline
\end{tabular}}
\end{center}
\end{figure}

The \verb!SEDNA_ATTR_SESSION_DIRECTORY! connection attribute defines the \verb!session directory!. If this attribute is set, paths in the \verb!LOAD! statement \ref{bulk-load} are evaluated relative to the session directory.

The \verb!SEDNA_ATTR_DEBUG! connection attribute turns on/off query debug mode. Query debug mode is off by default. Note, that \verb!SEDNA_ATTR_DEBUG! connection attribute must be set only after SEconnect has been called on the \verb!conn!.

The \verb!SEDNA_ATTR_CONCURRENCY_TYPE! connection attribute changes the mode of the next transactions. Transaction can be set to run as READ-ONLY (\verb!SEDNA_READONLY_TRANSACTION!) or UPDATE-transaction (\verb!SEDNA_UPDATE_TRANSACTION!).
READ-ONLY transactions have one major benefit: they never wait for other transactions (they do not have to acquire
any document/collection locks). However they might access slightly obsolete state of the database (for example, they probably
would not see the most recent committed updates). You should use READ-ONLY transactions in a highly concurrent environment.
Notice that the current transaction, if any, will be forcefully committed.

The \verb!SEDNA_ATTR_QUERY_EXEC_TIMEOUT! connection attribute allows to set the limit on query execution time. If set, for each next query in this session, query execution will be stopped if it lasts longer than timeout set. In this case transaction in bounds of which the query run is rollback. By default there is no any timeout for query execution, that is a query can be executed as long as needed.

The \verb!SEDNA_ATTR_MAX_RESULT_SIZE! connection attribute allows to set the limit on query result size. If this attribute is set, the server will cut the result data if its size exceeds the specified limit. By default, result data that is passed from server in reponse to user query can be of unlimited size.

The \verb!SEDNA_LOG_AMMOUNT! connection attribute changes the mode of logical logging of the next transactions.
Transaction can be set to run in full log mode (\verb!SEDNA_LOG_FULL!) or reduced log mode (\verb!SEDNA_LOG_LESS!). The latter
means transaction will be writing much less log info during bulk loads. However this comes with penalty of longer commits.
You should not use this option for transactions without bulk loads since it would not have any effect.
Notice that the current transaction, if any, will be forcefully committed. The default is \verb!SEDNA_LOG_FULL!.

An application can get connection attributes using \verb!SEgetConnectionAttr!:

\begin{verbatim}
int SEgetConnectionAttr(struct SednaConnection *conn,
                                    enum SEattr attr,
                                     void* attrValue,
                                int* attrValueLength);
\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type, associated with a session to be closed.

\verb!attr! - an attribute to retrieve.

\verb!attrValue! - a pointer to memory in which to return the current value of the attribute specified by \verb!attr!.

\verb!attrValueLength! - a length of the retrieved value in bytes.

\verb!SEgetConnectionAttr! returns:

positive value:

\verb!SEDNA_GET_ATTRIBUTE_SUCCEEDED! - the attribute was retrieved successfully.

negative value:

\verb!SEDNA_ERROR! - some error occurred.

To reset all connection attributes to their default values use:

\begin{verbatim}
int SEresetAllConnectionAttr(struct SednaConnection *conn);
\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type, associated with a session to be closed.

\verb!SEresetAllConnectionAttr! returns:

positive value:

\verb!SEDNA_RESET_ATTRIBUTES_SUCCEEDED! - attributes has been reset successfully.

negative value:

\verb!SEDNA_ERROR! - some error occurred.




%---------------------------------------------------------------------------

\subsubsection{Transactions}
An application can execute queries and updates against the specified database only in the scope of a transaction. That is, once a session has been opened, an application can begin a transaction, execute statements and commit this transaction. In a session transactions are processed sequentially. That is, application must commit an ongoing transaction before beginning a new one.

There are two ways to manage transactions in Sedna sessions: \emph{autocommit mode} and \emph{manual-commit mode}:
\begin{itemize}
\item Autocommit mode. Each individual statement is committed when it completes successfully. When running in autocommit mode no other transaction management functions are needed. By default, Sedna sessions are run in autocommit mode.
\item Manual-commit mode. Transaction boundaries are specified explicitly by means of \verb!SEbegin!, \verb!SEcommit! and \verb!SErollback! functions. All statements between the call to \verb!SEbegin! and \verb!SEcommit!/\verb!SErollback! are included in the same transaction.
\end{itemize}

An applcation can switch between the two modes using \verb!SEsetConnectionAttr! and \verb!SEgetConnectionAttr! functions for \verb!SEDNA_ATTR_AUTOCOMMIT! attribute

To specify transaction boundaries application uses \verb!SEbegin!, \verb!SEcommit! \verb!SErollback! functions:

\begin{verbatim}int SEbegin(SednaConnection* conn)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

SEbegin returns:

positive value:

\verb!SEDNA_BEGIN_TRANSACTION_SUCCEEDED! - transaction is begun.

negative value:

\verb!SEDNA_BEGIN_TRANSACTION_FAILED! - failed to begin a transaction.

\verb!SEDNA_ERROR! - some error occurred.

\begin{verbatim}int SEcommit(SednaConnection* conn)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

\verb!SEcommit! returns:

positive value:

\verb!SEDNA_COMMIT_TRANSACTION_SUCCEEDED! - transaction is committed.

negative value:

\verb!SEDNA_COMMIT_TRANSACTION_FAILED! - failed to commit transaction.

\verb!SEDNA_ERROR! - some error occurred.

\begin{verbatim}int SErollback(SednaCommection* conn)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

\verb!SErollback! returns:

positive value:

\verb!SEDNA_ROLLBACK_TRANSACTION_SUCCEEDED! - rollback transaction succeeded.

negative value:

\verb!SEDNA_ROLLBACK_TRANSACTION_FAILED! - failed to rollback transaction.

\verb!SEDNA_ERROR! - some error occurred.



%---------------------------------------------------------------------------

\subsubsection{Getting connection and transaction status}

An application can know the connection status by calling to \verb!SEconnectionStatus! function:

\begin{verbatim}int SEconnectionStatus(SednaConnection* conn)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

returns:

positive values:

\verb!SEDNA_CONNECTION_OK! - specified connection is open and functions ok.

\verb!SEDNA_CONNECTION_CLOSED! - specified connection is closed. This could be either after the call to \verb!SEclose! function, or before the call to \verb!SEconnect! function.

negative values:

\verb!SEDNA_CONNECTION_FAILED! - specified connection has failed. (Note: in this case you should call \verb!SEclose! function as it releases resources.)

An application can know the transaction status by calling to \verb!SEtransactionStatus! function:

\begin{verbatim}int SEtransactionStatus(SednaConnection* conn)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

returns:

positive values:

\verb!SEDNA_TRANSACTION_ACTIVE! - specified connection runs transaction.

\verb!SEDNA_NO_TRANSACTION! - specified connection does not run transaction. This could be for example when previous transaction has been committed and a new one has not been begun yet.

\verb!!
%---------------------------------------------------------------------------


\subsubsection{Executing Queries and Updates and Retrieving Result Data}
\label{exec-capi}

There are two functions to execute a statement (query or update): \verb!SEexecute! function and \verb!SEexecuteLong! function.

\begin{verbatim}int SEexecute(SednaConnection* conn, const char* query)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

\verb!query! - a null-terminated string with an XQuery query or XUpdate update statement.

returns:

positive values:

\verb!SEDNA_QUERY_SUCCEEDED! - specified query succeeded and result data can be retrieved.

\verb!SEDNA_UPDATE_SUCCEEDED! - specified update succeeded.

\verb!SEDNA_BULK_LOAD_SUCCEEDED! - specified update (bulk load- see Section 2) succeeded.


negative values:

\verb!SEDNA_QUERY_FAILED! - specified query failed.

\verb!SEDNA_UPDATE_FAILED! - specified update failed.

\verb!SEDNA_BULK_LOAD_FAILED! - bulk load failed.

\verb!SEDNA_ERROR! - some error occurred.



If the statement is really long, and you prefer to pass it to the Sedna directly from a file use \verb!SEexecuteLong! function.

\begin{verbatim}int SEexecuteLong(SednaConnection* conn, const char* query_file_path)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

\verb!query_file! - a path to the file with a query to execute.

returns:

positive values:

\verb!SEDNA_QUERY_SUCCEEDED! - specified query succeeded and result data can be retrieved.

\verb!SEDNA_UPDATE_SUCCEEDED! - specified update succeeded.

\verb!SEDNA_BULK_LOAD_SUCCEEDED! - specified update (bulk load- see Section 2) succeeded.


negative values:

\verb!SEDNA_QUERY_FAILED! - specified query failed.

\verb!SEDNA_UPDATE_FAILED! - specified update failed.

\verb!SEDNA_BULK_LOAD_FAILED! - bulk load failed.

\verb!SEDNA_ERROR! - some error occurred.


If \verb!SEexecute! function or \verb!SEexecuteLong! function returns \verb!SEDNA_QUERY_SUCCEEDED!, the result data can be retrieved. The result of XQuery query evaluation is a sequence of items, where every item is represented as
a string. Use the SEnext function to iterate over the sequence and SEgetData function to retrieve current item of the sequence.

\begin{verbatim}int SEnext(SednaConnection* conn)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

returns:

positive values:

\verb!SEDNA_NEXT_ITEM_SUCCEEDED! - moving to a next item succeeded, and the item can be retrieved.

negative values:

\verb!SEDNA_NEXT_ITEM_FAILED! - failed to get next item.

\verb!SEDNA_RESULT_END! - the result sequence is ended, no result data to retrieve.

\verb!SEDNA_NO_ITEM! - there was no succeeded query that produced the result data, no result data to retrieve.

\verb!SEDNA_ERROR! - some error occurred.

\begin{verbatim}int SEgetData(SednaConnection* conn, char* buf, int bytes_to_read)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

\verb!buf! - pointer to the buffer that receives the data got from the server.

\verb!bytes_to_read! - number of bytes to be read from the server into the buffer.


returns:

positive values:

number of bytes actually read from the server and put into the buffer.

zero - no data was read from the server and put into the buffer because of the item end. (use SEnext to move to the next item of the result)

negative values:

\verb!SEDNA_GET_DATA_FAILED! - failed to get data.

\verb!SEDNA_ERROR! - some error occurred.

Since version 1.5 Sedna supports reporting tracing information (fn:trace XQuery function). To handle tracing information while retrieving result data use debug handler \verb!debug_handler_t! and \verb!SEsetDebugHandler! function:

\begin{verbatim}void SEsetDebugHandler(struct SednaConnection *conn,
                                       debug_handler_t _debug_handler_);\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

\verb!_debug_handler_! - a pointer to your own defined function of the following form:

\verb!void (*debug_handler_t)(int subtype, const char *msg)! where \verb!subtype! is a type of debug information (currently only \verb!SEDNA_QUERY_TRACE_INFO! is supported), \verb!msg! is a buffer with debug information.

For example the following debug handler put the debug information to stdout.

\begin{verbatim}
void my_debug_handler(enum SEdebugType subtype, const char *msg)
{
   	printf("TRACE: ");
    printf("subtype(%d), msg: %s\n", subtype, msg);
}

...

SEsetDebugHandler(&conn, my_debug_handler);
\end{verbatim}

If the debug handler is not defined by the application, trace information is ignored.
%---------------------------------------------------------------------------

\subsubsection{Loading Data}

XML data can be loaded into a database using \verb!"LOAD"! statement of the Data Manipulation Language (see \ref{bulk-load}). Besides, libsedna library provides \verb!SEloadData! and \verb!SEendLoadData! functions to load well-formed XML documents divided into parts of any convenient size.

\verb!SEloadData! functions loads a chunk of XML document:

\begin{verbatim}
int SEloadData(SednaConnection* conn,
                     const char* buf,
                   int bytes_to_load,
                const char* doc_name,
                const char* col_name)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

\verb!buf! - a buffer with chunk of XML document.

\verb!bytes_to_load! - number of bytes to load.

\verb!doc_name! - name of the document in database the data loads to.

\verb!col_name! - name of the collection in the case if document is loaded into the collection, NULL if document is loaded as a standalone.

returns:

positive values:

\verb!SEDNA_DATA_CHUNK_LOADED! - chunk of XML document was loaded.

negative values:

\verb!SEDNA_ERROR! - some error occurred. Data were not loaded.

When the whole document is loaded using \verb!SEloadData!, application must use \verb!SEendLoadData! to notify server that  transfer of XML document is finished:

\begin{verbatim}int SEendLoadData(SednaConnection* conn)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

returns:

positive values:

\verb!SEDNA_BULK_LOAD_SUCCEEDED! - XML document was successfully loaded into the database.

negative values:

\verb!SEDNA_BULK_LOAD_FAILED! - Failed to load XML document into the database.

\verb!SEDNA_ERROR! - some error occurred.





%---------------------------------------------------------------------------


\subsubsection{Error Handling}

If the function returns negative value, application can get the error message and code.


To get last error message use:

\verb!SEgetLastErrorMsg! function:

\begin{verbatim}char* SEgetLastErrorMsg(SednaConnection* conn)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

The function returns the information about the last error occurred in this session.

To get last error code use:

\verb!SEgetLastErrorCode! function:

\begin{verbatim}int SEgetLastErrorCode(struct SednaConnection *conn)\end{verbatim}

parameters:

\verb!conn! - a pointer to an instance of the SednaConnection type.

The function returns the code of a last error occurred in this session.





%---------------------------------------------------------------------------

\subsubsection{Example Code}

\small{
\begin{verbatim}
#include "libsedna.h"
#include <stdio.h>

int main()
{
    struct SednaConnection conn = SEDNA_CONNECTION_INITIALIZER;
    int bytes_read, res, value;
    char buf[1024];

    const char* url = "localhost";
    const char* db_name = "testdb";
    const char* login = "SYSTEM";
    const char* password = "MANAGER";

    printf("Client started.\n");

    value = SEDNA_AUTOCOMMIT_OFF;
    res = SEsetConnectionAttr(&conn, SEDNA_ATTR_AUTOCOMMIT, (void*)&value, sizeof(int));

    //connecting to database "testdb" with login "SYSTEM", password "MANAGER"
    res = SEconnect(&conn, url, db_name, login, password);
    if(res != SEDNA_SESSION_OPEN)
    {
        printf("Session starting failed: \n%s\n", SEgetLastErrorMsg(&conn));
        return -1;
    }

    //begin transaction
    res = SEbegin(&conn);
    if(res != SEDNA_BEGIN_TRANSACTION_SUCCEEDED)
    {
        printf("Begin transaction failed: \n%s\n", SEgetLastErrorMsg(&conn));
        //closing session
        SEclose(&conn);
        return -1;
    }

    // load data from file "region.xml" into the document "region"
    res = SEexecute(&conn, "LOAD \"region.xml\" \"region\"");
    if(res != SEDNA_BULK_LOAD_SUCCEEDED)
    {
        printf("Bulk load failed: \n%s\n", SEgetLastErrorMsg(&conn));
        // closing session
        SEclose(&conn);
        return -1;
    }

    // execute XQuery query
    res = SEexecute(&conn, "document(\"region\")/*/*");
    if(res != SEDNA_QUERY_SUCCEEDED)
    {
        printf("Query failed: \n%s\n", SEgetLastErrorMsg(&conn));
        //closing session
        SEclose(&conn);
        return -1;
    }

    // iterate over the result sequence and retrieve the result data
    while((res = SEnext(&conn)) != SEDNA_RESULT_END)
    {
        if (res == SEDNA_ERROR)
        {
            printf("Failed to get next result item from server: \n%s\n",
                    SEgetLastErrorMsg(&conn));
            //closing session
            SEclose(&conn);
            return -1;
        }

        printf("\nresult item:\n");
        do
        {
            bytes_read = SEgetData(&conn, buf, 1024 - 1);
            if(bytes_read == SEDNA_ERROR)
            {
                printf("Failed to get result data from server: \n%s\n",
                        SEgetLastErrorMsg(&conn));
                //closing session
                SEclose(&conn);
                return -1;
            }
           	buf[bytes_read] = '\0';
         	printf("%s", buf);

        }while(bytes_read > 0);
    	printf("\n");
    }

    // Drop document "region"
    res = SEexecute(&conn, "DROP DOCUMENT \"region\"");
    if(res != SEDNA_UPDATE_SUCCEEDED)
    {
        printf("Drop document failed: \n%s\n", SEgetLastErrorMsg(&conn));
        // closing session
        SEclose(&conn);
        return -1;
    }

    //commiting transaction
    res = SEcommit(&conn);
    if(res != SEDNA_COMMIT_TRANSACTION_SUCCEEDED)
    {
        printf("Commit transaction failed: \n%s\n",
                SEgetLastErrorMsg(&conn));
        //closing session
        SEclose(&conn);
        return -1;
    }

    //closing session
    res = SEclose(&conn);
    if(res != SEDNA_SESSION_CLOSED)
    {
        printf("An error occured while trying to close session: \n%s\n",
                SEgetLastErrorMsg(&conn));
        return -1;
    }

    return 0;
}
\end{verbatim}
}

The source code of this example program can be found in
\begin{verbatim}
[win:] INSTALL_DIR\examples\api\c\Client.c
\end{verbatim}
\begin{verbatim}
[nix:] INSTALL_DIR/examples/api/c/Client.c
\end{verbatim}

\verb!INSTALL_DIR! refers to the directory where Sedna is installed.

Before running the example make sure that the Sedna DBMS is installed and do the following steps:
\begin{enumerate}
\item Start Sedna by runing the following command:
\begin{verbatim}
se_gov
\end{verbatim}
If Sedna is started successfully it prints "GOVERNOR has been started in
the background mode".
\item Create a new database \verb!testdb! by running the following command:
\begin{verbatim}
se_cdb testdb
\end{verbatim}
If the database is created successfully it prints "The database 'testdb'
has been created successfully".
\item Start the testdb database by running the following command:
\begin{verbatim}
se_sm testdb
\end{verbatim}
If the database is started successfully it prints "SM has been started in
the background mode".
\end{enumerate}

You can compile and run the example by following the steps listed below:
\begin{enumerate}
\item In the file \verb!Client.c!, the \verb!url! parameter specifies the
 name of the computer where the server is running. If Sedna DBMS is not running
 on the same computer edit the file \verb!Client.c! to set the value of the \verb!url!
 parameter.
 This looks as something like the following:
 \begin{verbatim}const char* url = "computer-name";\end{verbatim}

if Sedna DBMS is running on the same computer you do not need to edit this parameter.

\item To compile the example use
\begin{verbatim}
[win:] Clientbuild.bat
\end{verbatim}
\begin{verbatim}
[nix:] Clientbuild.sh
\end{verbatim}
located in the same folder as \verb!Client.c!.

\item To run the compiled example use
\begin{verbatim}
[win:] Client.exe
\end{verbatim}
\begin{verbatim}
[nix:] Client
\end{verbatim}
located in the same folder as \verb!Client.c!.
\end{enumerate}





%==========================================================================
%
%                                  Scheme API
%
%===========================================================================
\subsection{Scheme API}

Scheme API allows querying and managing XML data from an application written
in Scheme.
Scheme API follows the spirit of SchemeQL~\cite{paper:scheme-ql}, an
implementation of SQL 1992 for Scheme.
The results of XQuery queries to the Sedna DBMS via the Scheme API can be
represented either in XML or SXML~\cite{paper:sxml}.

\subsubsection{Sessions}

For working with the Sedna DBMS from Scheme, you should first establish a
connection between the Scheme API driver and the Sedna DBMS.
Here are two functions to manage connections:

\begin{verbatim}> (sedna:connect-to-database host db-name user password)
  : String String String String -> connection-object\end{verbatim}

Establishes a connection between the client application and the Sedna DBMS.
Returns a 'connection' object which incapsulate information about the
connection.
The arguments are strings that denote connection parameters:
\begin{itemize}
\item \texttt{host} is the host where the Sedna DBMS is running.
 If it is on the same machine as your Scheme application, you can use
 \texttt{"localhost"} for the value of this parameter.
\item \texttt{db-name} is the name of the database you want to work with.
 You are to establish a separate connection for each database you would like to
 work with.
\item \texttt{user} is your user name for the session.
 You can use \texttt{"SYSTEM"} for the value of this paramter.
\item \texttt{password} is your password for the session.
 You can use the \texttt{"MANAGER"} value of this parameter.
\end{itemize}

To disconnect from the database, you can use the following function:

\begin{verbatim}> (sedna:disconnect-from-database connection)
  : connection-object -> void\end{verbatim}

Closes the connection represented by the \texttt{connection} object.
If server fails to close the connection, the function closes the connection
forcibly from the client side and raises the exception, as discussed 
in subsubsection \ref{scheme-errors}.


\subsubsection{Transactions}

After the connection with a database is established and the session is begun,
you can run zero or more transactions in this session.
Transactions are to be run sequentially, with no more than a single transaction
at a time, so you should commit your running transaction before starting a
new one.

To begin a new transaction, the following function is provided:
%To begin a new transaction, you can use the function:

\begin{verbatim}> (sedna:begin-transaction connection)
  : connection-object -> void\end{verbatim}

It accepts the \texttt{connection} object (earlier created by
\texttt{sedna:connect-to-database} function) and starts a new transaction.
If the transaction could not be created, the exception is raised, as discussed
in subsubsection \ref{scheme-errors}.

To end your running transaction, you are provided with the following function:

\begin{verbatim}> (sedna:end-transaction connection action)
  : connection-object, symbol -> void\end{verbatim}

If \texttt{action} is \texttt{'COMMIT} the transaction in the given connection
will be commited, if \texttt{'ROLLBACK} is given, the transaction will be
rolled back.

%\begin{note}In the current version of the Sedna DBMS, transaction rollback is not
% supported.
% Calling \texttt{sedna:end-transaction} with a \texttt{'ROLLBACK} action would
% currently result to an exception.
%\end{note}


\subsubsection{Executing Queries}

Within a transaction, you can execute zero or more queries to the database.

\begin{verbatim}> (sedna:execute-query connection query)
  : connection-object, string -> result\end{verbatim}

The first argument is the \texttt{connection} object, earlier created by
\texttt{sedna:connect-to-database} function.
The \texttt{query} is represented as a string and can express one of the 3
kinds of queries:
\begin{itemize}
\item XQuery query -- for querying data from the database, without modifying it;
\item Update command -- for making modifications to the database you work
 with;
\item Bulk load command -- for loading a new XML document from the local file to the
 database.
\end{itemize}

If an error occurs at the server side during query execution (e.g.\ the
requested document not found), the function raises an exception that contains
the message about the error occurred.

In the successful case of query execution, \texttt{sedna:execute-query} returns
\texttt{\#t} for the last 2 kinds of queries, to denote a successful update
made to the database.
The XQuery \texttt{query} results to a sequence of items, which are evaluated
lazily and are represented as a pair:
\begin{verbatim}xquery-result ::= (cons current-item promise)\end{verbatim}
This way of result representation is very close to the notion of SchemeQL
{\em cursor}~\cite{paper:scheme-ql} (with the only difference in that the Scheme API driver returns XQuery items instead of table rows returned by
SchemeQL).
The first member of the pair is the \texttt{current-item} represented in SXML,
and the second member of the pair holds a promise (which can be forced) to
evaluate and return the next item in the result sequence.

To iterate over the result sequence, you can use the function:
\begin{verbatim}> (sedna:next xquery-result)
  : xquery-result -> xquery-result or '()\end{verbatim}
which forces the evaluation of the following items in the result sequence,
until the end of the sequence is reached.

Such a design allows you to process a query result in a lazy stream-wise
fashion and provides you with an ability to process large query results, which
would not otherwise fit in the main memory.

However, for query results that are not very large, you may find it convenient
to evaluate them all at once and represent the result sequence as a Scheme
list.
Scheme API provides a function that converts the \texttt{xquery-result}
into the list that contains all items of the result sequence:
\begin{verbatim}> (sedna:result->list xquery-result)
  : xquery-result -> (listof item)\end{verbatim}

To obtain the result sequence in the form of the list, you can execute your
queries as a superposition of the above considered functions:
\begin{verbatim}(sedna:result->list
  (sedna:execute-query connection query))\end{verbatim}
It should be noted that the XQuery query result in that case exactly
corresponds to the term of a {\em node-set} in the XPath implementation in
Scheme SXPath~\cite{paper:sxpath}.

If you want to obtain your query results in XML instead of SXML, you can use
the function
\begin{verbatim}> (sedna:execute-query-xml connection query)
  : connection-object, string -> result\end{verbatim}
It is the counterpart of earlier discussed \texttt{sedna:execute-query} and
has the same signature, but represents query results in XML.
The function returns a sequence of items, in the form of \texttt{xquery-result}
discussed above, but the \texttt{current-item} is now a string containing the
representation for the current item in the form of XML.


\subsubsection{Bulk load from stream}

The following wrapper function provides a natural way to load an input stream
containing an XML document into your database:
\begin{verbatim}> (sedna:bulk-load-from-xml-stream
                          connection port document-name . collection-name)
  : connection-object, input-port, string [, collection-name] -> boolean\end{verbatim}

As for \texttt{sedna:execute-query}, the first argument here is the
\texttt{connection} object, earlier created by
\texttt{sedna:connect-to-database} function.
Argument \texttt{port} is a Scheme input port and is supposed to contain
a well-formed XML document.
Argument \texttt{document-name} specifies the name that will be given to the
XML document within a database.
If the $4$-th argument \texttt{collection-name} is supplied, the XML document
is loaded into the collection which name is specified by the
\texttt{collection-name} argument.
If the $4$-th argument of the function call is not supplied, the XML document
is loaded into the database as a standalone document.

By allowing you to specify the input port you would like to use, this function
provides a higher-level shortcut for \texttt{sedna:execute-query} when bulk
load from stream is concerned.
For more details on bulk load, see section \ref{bulk-load}.

\subsubsection{Higher-level function for a transaction}

This higher-level function provides a convenient way for executing a
transaction consisting of several queries, within a single function call:

\begin{verbatim}> (sedna:transaction connection . queries)
  : connection-object, string* -> result\end{verbatim}

This function starts a new transaction on the \texttt{connection} objects and
executes all the \texttt{queries} given in order.
If no exception occurs, the function commits the transaction and returns the
result of the last query.
If any exception occurred during query execution, the function sends rollback
to the Sedna DBMS and passes along the exception to the application.


\subsubsection{Error handling}
\label{scheme-errors}

Error handling in the Scheme API driver is based on the exception mechanism
suggested in the (currently withdrawn) SRFI-12~\cite{paper:srfi-12}.
The SRFI-12 exception mechanism is natively supported in the Chicken Scheme
compiler~\cite{paper:chicken}.
In the Scheme API driver, we also provide the SRFI-12 implementation for PLT
and Gambit.


\subsubsection{Code example}

This section presents an example that illustrates the application of
the Scheme API driver.

\begin{verbatim}; Load the necessary Scheme API driver files
(load "collect-sedna-plt.scm")

; Create a connection
(define conn
  (sedna:connect-to-database "localhost" "testdb" "SYSTEM" "MANAGER"))

; Begin a transaction
(sedna:begin-transaction conn)

; Bulk load
(call/cc  ; Thanks to Felix Winkelmann for recommending us to use call/cc here
 (lambda (k)
   (with-exception-handler  ; Exception handler
    (lambda (x)
      (display "File already loaded to the database")
      (newline)
      (k #f))
    (lambda ()
      (sedna:execute-query conn "LOAD 'region.xml' 'regions'")))))

; Execute a statement and represent it as an SXML nodeset
(pp
 (sedna:result->list
  (sedna:execute-query conn "document('region')/*/*")))

; Update statement
(pp
 (sedna:execute-query conn "UPDATE delete document('region')//africa"))

; Querying all regions once again
(pp
 (sedna:result->list
  (sedna:execute-query conn "document('region')/*/*")))

; Commit transaction
(sedna:end-transaction conn 'COMMIT)

; Close the connection
(sedna:disconnect-from-database conn)\end{verbatim}

You can find the example and the Scheme API driver code in:
\begin{verbatim}
[win:] INSTALL_DIR\examples\api\scheme
[nix:] INSTALL_DIR/examples/api/scheme
\end{verbatim}
where \verb!INSTALL_DIR! refers to the directory where Sedna is installed.

Before running the example make sure that the Sedna DBMS is installed and do the following steps:
\begin{enumerate}
\item Start Sedna by runing the following command in a command line:
\begin{verbatim}
se_gov
\end{verbatim}
If Sedna is started successfully it prints "GOVERNOR has been started in
the background mode".
\item Create a new database \verb!testdb! by running the following command:
\begin{verbatim}
se_cdb testdb
\end{verbatim}
If the database is created successfully it prints "The database 'testdb'
has been created successfully".
\item Start the testdb database by running the following command:
\begin{verbatim}
se_sm testdb
\end{verbatim}
If the database is started successfully it prints "SM has been started in
the background mode".
\end{enumerate}

If the Sedna DBMS is running on the same computer as your Scheme application,
you don't need to change anything in the example code.
If the Sedna DBMS is running on a remote machine, you should use the name of
this machine when connecting to the database with
\texttt{sedna:connect-to-database} function.

For running the example supplied, you should copy all files from the folder
\begin{verbatim}
[win:] INSTALL_DIR\examples\api\scheme
[nix:] INSTALL_DIR/examples/api/scheme
\end{verbatim}
into the folder where the Scheme API driver code is located
\begin{verbatim}
[win:] INSTALL_DIR\driver\scheme
[nix:] INSTALL_DIR/driver/scheme
\end{verbatim}
where \verb!INSTALL_DIR! refers to the directory where Sedna is installed.

You can use PLT DrScheme GUI to open and run \texttt{"client.scm"} in the
graphical mode.
You can also run the example from your command line, by typing
\begin{verbatim}mzscheme -gr client.scm\end{verbatim}

For running the example with a different Scheme implementation (Chicken or
Gambit), uncomment the corresponding line at the beginning of the example code
in \texttt{"client.scm"} and follow the instructions of the chosen Scheme
implementation in running the program.

%===========================================================================
%
%                                  Database Language
%
%===========================================================================
\section{Database Language}
\label{sec:DBLang}
%\subsection{Data Manipulation Language}

\subsection{XQuery Support}
\label{sec:xquery-support}
The Sedna query language is XQuery \cite{paper:query-language} developed by W3C.
Sedna conforms to January 2007 specification of XQuery except the following features:
\begin{itemize}
\item copy-namespaces declaration
\item fn:normalize-unicode function
\item external variables
\end{itemize}
Sedna also has full support for two optional XQuery features:
\begin{itemize}
\item full axis
\item modules
\end{itemize}

Sedna passes "XML Query Test Suite (XQTS)" and has official "almost passed" status. The detailed report can be found at \verb!http://www.w3.org/XML/Query/test-suite/XQTSReport.html!

\subsection{XQuery Options and Extensions}
\label{sec:xquery-extensions}

\subsubsection{Controlling Serialization}
\label{indents}
Serialization is the process of converting XML nodes evaluated by XQuery into a stream of characters. In Sedna serialization is carried out when the result of a query is returned to the user. You can control the serialization by setting the \emph{serialization parameters} specified in \cite{paper:query-serialization}. Currently, Sedna supports the following serialization parameters:

\begin{tabular}{|l|l|l|}
\hline
Parameter name & Values & Description \\
\hline
\hline
indent & "yes" or "no" (default yes) & Output indented \\
\hline
\end{tabular}

To set a serialization parameter, use the \verb!output! option in a query prolog. The \verb!output! option is in the Sedna namespace (
http://www.modis.ispras.ru/sedna) which is the predefined namespace in Sedna so you can omit its declaration. The value of the \verb!output! option must have the following structure "parameter-name=value; parameter-name=value". Consider the following examples.

\begin{verbatim}
declare namespace se = "http://www.modis.ispras.ru/sedna";
declare option se:output "indent=yes";
\end{verbatim}

As mentioned above, you may omit the Sedna namespace declaration:
\begin{verbatim}
declare option se:output "indent=yes";
\end{verbatim}

%==========================================================================
%                                      Value Index-scan functions
%==========================================================================
\subsubsection{Value Index-scan Functions}
\label{sec:value-index-scan-fun}
In the current version of Sedna, query executor does not use indices
automatically. Use the following functions to enforce executor to employ
indices.

\begin{verbatim}
index-scan ($title as xs:string, $value as xdt:anyAtomicType,
           $mode as xs:string ) as node()*
\end{verbatim}

The \verb!index-scan! function scans the index with the \verb!$title!
name and returns the sequence of nodes which keys are equal (less than,
greater than, greater or equal, less or equal) to the search value
\verb!$value!. An Sedna error is raised if the search value can not be cast to
the atomic type of the index. The \verb!$mode! parameter of the
\verb!xs:string! type is used to set the type of the scan. The value of the
parameter must be equal to one of the following: 'EQ' (equal), 'LT'(less than),
'GT' (greater than), 'GE' (greater or equal), 'LE' (less or equal).

\begin{verbatim}
index-scan-between ($title as xs:string, $value1 as xdt:anyAtomicType,
         $value2 as xdt:anyAtomicType, $range as xs:string )
                               as node()*
\end{verbatim}

The \verb!index-scan-between! scans the index with the \verb!$title! name and
returns the sequence of nodes which keys belong to the interval (segment, left
half-interval, right half-interval) between the first \verb!$value1! and second
\verb!$value2! search values. An Sedna error is raised if the search values can
not be cast to the atomic type of the index. This function provides the
\verb!$range! parameter of the \verb!xs:string! type to set the type of the
scan. The value of the string must be equal to one of the following: 
'INT' (interval), 'SEG' (segment), 'HINTR' (right half-interval), 
'HINTL' (left half-interval).

For example, to select the names of people who live in the London city employing
the "people" index defined in section \ref{sec:managing-value-indices}, 
use the following expression:

\begin{verbatim}
index-scan("people", "London", "EQ")/name
\end{verbatim}


%==========================================================================
%                                      Full-text Search Functions
%==========================================================================

\subsubsection{Full-text Search Functions}
\label{sec:ft-fun}
Please read section \ref{sec:managing-ft-indices} before reading this section.

In the current version of Sedna, query executor does not use full-text indecies automatically. Use the following functions
to enforce executor to employ indices.

\begin{verbatim}
ftindex-scan($title as xs:string, $query as xs:string,
             $options as xs:string) as node()*
\end{verbatim}

The \verb!ftindex-scan! function scans the full-text index with the \verb!$title! name and returns the sequence of items which satisfy the \verb!$query!. As full-text index is based on dtSearch \cite{link:dtsearch-engine}, use the dtSearch request language \cite{doc:dtsearch} to specify the query.
DtSearch options dtsSearchAnyWords or dtsSearchAllWords may be specified in \verb!$options!.

For example, you can employ the "articles" index defined in section \ref{sec:managing-ft-indices} to select the titles of articles that contain word "apple" but not "pear":
\begin{verbatim}
ftindex-scan("articles", "apple and not pear")/title
\end{verbatim}

\begin{verbatim}
ftscan($seq as node()*, $query as xs:string, $type as xs:string,
$customization_rules as xs:string) as node()*
\end{verbatim}

The \verb!ftscan! function returns those items of the input sequence \verb!$seq! which satisfy the query \verb!$query!. The function does not use indices and can be applied to any sequence of nodes, even those that are not indexed. The query \verb!$query! is evaluated over the text representation constructed according to the \verb!$type! and \verb!$customization_rules! paramters. The values of the parameters are the same as those used when a full-text index is created (see section \ref{sec:managing-ft-indices} for details).

For example, you can select the titles of articles that contain word "apple" but not "pear" \emph{without} using indices and using special customization rules as follows:
\begin{verbatim}
ftscan(doc("foo")/library//article, "apple and not pear",
"customized-value", (("b","string-value"),("a","delimited-value")))/title
\end{verbatim}




%==========================================================================
%                                  SQL
%==========================================================================
\subsubsection{SQL Connection}
SQL Connection allows access to relational databases from XQuery using SQL.
The resulting ralations are represented on-the-fly as sequenses of XML-elements representing rows. These elements have sub-elements corresponding with the columns returned by the SQL query. and thus can be
easy processed in XQuery. All functions dealing with access to SQL data are located in the namespace
``\verb!http://modis.ispras.ru/Sedna/SQL!'' which is refered as \verb!sql!
in the following function declarations and examples.

\subsubsection*{Connections}
In order to execute SQL queries on a RDBMS, you should first establish a connection
to it. There are two functions for managing connections:

\begin{verbatim}
function sql:connect($db-url as xs:string) as xs:integer
function sql:connect($db-url as xs:string, $user as xs:string)
       as xs:integer
function sql:connect($db-url as xs:string, $user as xs:string,
      $password as xs:string) as xs:integer
function sql:connect($db-url as xs:string, $user as xs:string,
      $password as xs:string, $options as element()*) as xs:integer
\end{verbatim}

These functions attempt to establish a database connection to the given URL using a user name and password if specified.
They return a connection handle which could be then passed to \verb!sql:execute!, \verb!sql:prepare!, \verb!sql:close!,
\verb!sql:rollback!, and \verb!sql:commit!

If no connection can be opened, an Sedna error is raised.

All arguments of  the \verb!sql:connect! functions except for \verb!$db-url! are optional:
\begin{itemize}
\item \verb!$db-url! is the URL of the database to which a connect is established.
URL is of the following form:
\begin{verbatim}
odbc:<driver name>:[//<server>[/<database>][;]][<driver options>]
\end{verbatim}
``;'' after \verb!<database>! or \verb!<server>! is required if there are some driver options following it.
Driver options must be in the following form: \verb!<option>=<value>{;<option>=<value>}!. List of available options
depens on the ODBC driver used. One of the common options is ``Port'' which is used to specify the port on which
the database server is configured to listen.

Example: \verb!odbc:MySQL ODBC 3.51 Driver://localhost/somedb;Port=1234!
\item \verb!$user! is your user name for the session.
\item \verb!$password! is your password for the session.
\item \verb!$options! is an optional sequence of connection options.
Connection options are elements of the form
\begin{verbatim}
<sql:option name="<option-name>" value="<option-value>"/>
\end{verbatim}
The only connection option available for the moment is ``\verb!manual-commit!''
which enables manual commit mode if its value is ``\verb!on!''
\end{itemize}

To disconnect from the database, you can use the following function:
\begin{verbatim}function sql:close($connecton as xs:integer) as element()?\end{verbatim}

It closes database connection associated with connection handle \verb!$connection!.
An Sedna error is raised if operation cannot be completed.

\subsubsection*{Executing Queries}
When a database connection is established you can start executing queries. Two types of
query execution are supported: \emph{direct query execution} and \emph{prepared query execution}.

\subsubsection*{Direct Queries}
Simple SQL queries are executed as the following XQuery example shows:
\small{
\begin{verbatim}
declare namespace sql="http://modis.ispras.ru/Sedna/SQL";
let $connection :=
   sql:connect("odbc:MySQL ODBC 3.51 Driver://localhost/somedb", "user",
      "pass")
return
   sql:execute($connection, "SELECT * FROM people WHERE first = 'Peter'");
\end{verbatim}
}

The result is as follows:
\small{
\begin{verbatim}
<tuple first="Peter" last="Jackson" city="Wellington"/>
\end{verbatim}
}
There are two functions for direct query execution:
\begin{verbatim}
function sql:execute($connection as xs:integer, $statement as xs:string)
   as element()*
function sql:execute($connection as xs:integer, $statement as xs:string,
      $query-options as element()*) as element()*
\end{verbatim}
These functions execute a SQL query and return a sequence of elements representing the query result. SQL query can be as
both a query statement and an update statement. In case of query statement, the result sequence contains an element named 'row' for each row of the query result. Each element contains as many children attributes as there are non-NULL fields in the corresponding result-row.
Each attribute has the name of a row field. Fields with NULL values are not included. In case of update statement, empty sequence is returned.

An Sedna error is raised on an erroneous statement.

The \verb!sql:execute! have the following arguments:
\begin{itemize}
\item \verb!$connection! is a connection handle, returned by \verb!sql:connect!;
\item \verb!$statement! is a string containing SQL statement to be executed;
\item \verb!$query-options! is a sequence of optional query parameters.
\end{itemize}

Update queries can be executed using the \verb!sql:exec-update! function:
\begin{verbatim}
function sql:exec-update($connection as xs:integer,
          $statement as xs:string) as xs:integer
function sql:exec-update($connection as xs:integer,
      $statement as xs:string,
      $query-options as element()*) as xs:integer
\end{verbatim}
these functions are similar to \verb!sql:execute!, but return the number
of rows affected by an update query (instead of an empty sequence returned by
\verb!sql:execute! for update-queries). Function arguments are same as for \verb!sql:execute!.

The behaviour of this function is undefined for non-update queries.



\subsubsection*{Prepared Statements}
Sometimes it is more convenient or more efficient to use prepared SQL statements
instead of direct query execution. In most cases, when a SQL statement is
prepared it will be sent to the DBMS right away, where it will be compiled.
This means that the DBMS does not have to compile a prepared statement each time
it is executed.
Prepared statements can take parameters. This allows using the same statement
and supply it with different values each time you execute it, as in the
following XQuery example:
\small{
\begin{verbatim}
declare namespace sql="http://modis.ispras.ru/Sedna/SQL";
let $connection :=
   sql:connect("odbc:MySQL ODBC 3.51 Driver://localhost/somedb", "user",
     "pass")
let $statement :=
   sql:prepare($connection, "INSERT INTO people(first, last)
         VALUES (?, ?)")
return (
   sql:execute($statement, "John", "Smith"),
   sql:execute($statement, "Matthew", "Barney")
)
\end{verbatim}
}
this XQuery code inserts two rows into table \verb!people! and returns an empty
sequence.

To use prepared statements, first you need to create a prepared statement handle
using the \verb!sql:prepare! function:
\begin{verbatim}
function sql:prepare($connection as xs:integer, $statement as xs:string)
      as xs:integer
function sql:prepare($connection as xs:integer, $statement as xs:string,
      $query-options as element()*) as xs:integer
\end{verbatim}
these function prepare a SQL statement for later execution and returns a
prepated statement handle which can be used in
the \verb!sql:execute! and \verb!sql:exec-update! functions.

The \verb!sql:prepare! functions have the following arguments:
\begin{itemize}
\item \verb!$connection! is a connection handle, created by \verb!sql:connect!;
\item \verb!$statement! is a string containing a SQL statement that may
contain one or more '?' - IN parameter placeholders;
\item \verb!$query-options! is a sequence of optional query parameters.
\end{itemize}
An Sedna error is raised on an erroneous statement.

There are two prepared statement execution functions, similar to direct query
execution:

\begin{verbatim}
function sql:execute($prepared-statement as xs:integer,
      $param1 as item()?, ...) as element()*
\end{verbatim}
this function is similar to \verb!sql:execute! for direct queries and
returns a sequence of elements representing query result.
\begin{itemize}
\item \verb!$prepared-statement! is a prepared statement handle created by
\verb!$sql:prepare!;
\item \verb!$param1, ...! are parameters for parametrized
statements. The number of parameters specified must exactly match the number
of parameters of the prepared statement. NULL values are represended as empty
sequences ``\verb!()!''.
\end{itemize}

\begin{verbatim}
function sql:exec-update($prepared-statement as xs:integer,
      $param1 as item()?, $param2...) as xs:integer
\end{verbatim}

This function is similar to \verb!sql:execute!, but returns the number
of rows affected by an update query (instead of an empty sequence returned by
\verb!sql:execute! for update-qeries). Function arguments are the same as for \verb!sql:execute!.

The behaivor of this function is undefined for non-update queries.

\subsubsection*{Transactions}

The default commit mode of connection is auto-commit, meaning that all updates
will be commited automatically. If this is not desired behaviour, you can
pass manual-commit option to \verb!sql:connect! when you create a connection
handle.

In manual commit mode you can specify when updates will be committed or rolled
back:

\small{
\begin{verbatim}
declare namespace sql="http://modis.ispras.ru/Sedna/SQL";
let $connection :=
  sql:connect("odbc:MySQL ODBC 3.51 Driver://localhost/somedb", "user",
         "pass",<sql:option name="manual-commit" value="1"/>)
return
  for $person in doc("somedoc.xml")/person
  return (
    sql:execute($connection, "<do something with person>"),
    if (allok($connection, $person)) then
      (
        sql:execute($connection, "<do something else with person>"),
        sql:commit($connection)
      )
    else
      sql:rollback($connection)
  )
\end{verbatim}
}

There are two functions for specifying transaction boundaries -
\verb!sql:commit! and \verb!sql:rollback! (transactions are started
automatically by queries, these functions only close them):
\begin{verbatim}
function sql:commit($connecton as xs:integer) as element()?
\end{verbatim}

\verb!sql:commit! commits all changes made during the last transaction in the database
connection specified by connection handle \verb!$connection!
and closes transaction.

An Sedna error is raised if operation cannot be completed.


\begin{verbatim}
function sql:rollback($connecton as xs:integer) as element()?
\end{verbatim}
rolls back all changes made during the last transaction in the database
connection specified by connection the handle \verb!$connection!
and closes transaction.

An Sedna error is raised if operation cannot be completed.


%\subsubsection*{Code Examples}
%The example source code can be found in
%\begin{verbatim}
%[win:] INSTALL_DIR\examples\...\sql\*.xquery
%\end{verbatim}
%\begin{verbatim}
%[linux:] INSTALL_DIR/examples/.../sql/*.xquery
%\end{verbatim}
%
%Before running the example make sure that the Sedna DBMS is installed and do
%the following steps:
%\begin{enumerate}
%\item Start Sedna by runing the following command:
%\begin{verbatim}
%se_gov
%\end{verbatim}
%If Sedna is started successfully it prints "GOVERNOR has been started in
%the background mode".
%\item Start listener by running the following command:
%\begin{verbatim}
%listener
%\end{verbatim}
%If the listener is started successfully it prints "Listener has been started in
%the background mode".
%\item Create a new database \verb!testdb! by running the following command:
%\begin{verbatim}
%se_cdb testdb
%\end{verbatim}
%If the database is created successfully it prints "The database 'testdb'
%has been created successfully".
%\item Start the testdb database by running the following command:
%\begin{verbatim}
%se_sm testdb
%\end{verbatim}
%If the database is started successfully it prints "SM has been started in
%the background mode".
%\end{enumerate}

%==========================================================================
%                             External functions
%==========================================================================

\subsubsection{External Functions}
\emph{External function} is a notion defined in the XQuery specification \cite{paper:query-language} as follows:
"External functions are functions that are implemented outside the query environment".
Support for external functions allows you to extend XQuery by implementing
functions in other languages.

Sedna provides a server programming API to write external
functions in the C/C++ language.
External functions in Sedna are limited to dealing with sequences of atomic values.
External functions are compiled and linked in the form of shared
libraries (i.e. \verb!.dll! files in Windows or \verb!.so! files in Linux/FreeBSD/Mac OS)
and loaded by the server on demand.
Although the Sedna XQuery executor evaluates queries in a lazy manner, all external function calls are evaluated in an eager manner.

\subsubsection*{Using External Functions}
To use an external function you need to declare this function in prologue
with \verb!external! keyword instead of function body. Then it may be used
normally:
\begin{verbatim}
declare function se:f($a as xs:integer) as $xs:integer external;
f(10)
\end{verbatim}

\subsubsection*{Creating External Functions}
External functions must be written in C/C++. To implement a new XQuery
function \verb!func! you should write the following C (or C++) functions:
\verb!func!, \verb!func_init! and \verb!func_deinit!.
When executor decides that it needs to use an external function, first it
initializes this function by calling \verb!func_init!, after that it will
call \verb!func! to compute results as many times as needed. When some
external function is not needed anymore, executor calls \verb!func_deinit!
(which probaly will free any memory allocated by \verb!func_init!).
Each one of the three functions receives an \verb!SEDNA_EF_INIT!\footnote{All
needed types and constants are defined in the sedna\_ef.h file,
located in the include directory of the Sedna distribution.
See Section ``Sedna Directory Structure'' in \cite{doc:admin} to learn where the include directory is located.}
structure as a parameter. This structure has several fields that are
initialized by executor before any \verb!func_init! or \verb!func_deinit! calls:
\begin{verbatim}
typedef struct sedna_ef_init
{
    void *(*sedna_malloc)(size_t);
    void (*sedna_free)(void *);
    SEDNA_SEQUENCE_ITEM *item_buf;
} SEDNA_EF_INIT;
\end{verbatim}
The fields of this structure may be used in your implementation:
\begin{itemize}
	\item \verb!sedna_malloc! is a pointer to a malloc function which must be used to
	allocate memory for
	function results, this memory will be automatically freed by the query executor.
	It may also be used to allocate memory for internal use, such memory must be
	freed manually using the \verb!sedna_free! function.
	\item \verb!sedna_free! is a pointer to free function that releases memory
	allocated using \verb!sedna_malloc! function.
	\item \verb!item_buf! is a pointer to a preallocated \verb!SEDNA_SEQUENCE_ITEM!
	which may be used to store results
	(this allows to avoid using \verb!sedna_malloc! function when result is
	a single atomic non-string value)
\end{itemize}

\verb!func!, \verb!func_init! and \verb!func_deinit! must have specific signatures:
\begin{itemize}
\item \verb!func()! (required)

computes external function results.
This function has the following signature:
\begin{verbatim}
SEDNA_SEQUENCE_ITEM *func(SEDNA_EF_INIT *init,
                          SEDNA_EF_ARGS *args,
                          char * error_msg_buf);
\end{verbatim}
\begin{itemize}
	\item \verb!init! is a pointer to the \verb!SEDNA_EF_INIT! structure which
		was passed to \verb!func_init! function (if written)
	\item \verb!args! is a pointer to the \verb!SEDNA_EF_ARGS! structure which
		contains all function arguments
	\item \verb!error_msg_buf! is a pointer to the string buffer used for specifying error
		message if function invocation fails. Maximum message length is
		\verb!SEDNA_ERROR_MSG_BUF_SIZE! bytes, including the null character \verb!'\0'!.
\end{itemize}

\item \verb!func_init()! (optional)

The initialization function.
It can be used to allocate any memory required by the main function.
This function has the following signature:
\begin{verbatim}
void func_init(SEDNA_EF_INIT *init, char * error_msg_buf);
\end{verbatim}
\begin{itemize}
	\item \verb!init! is a pointer to the \verb!SEDNA_EF_INIT! structure
		(the pointer to this structure will be passed then to \verb!func! and
		\verb!func_deinit! functions)
	\item \verb!error_msg_buf! is a pointer to the string buffer used for specifying error
		message if function invocation fails. Maximum message length is
		\verb!SEDNA_ERROR_MSG_BUF_SIZE!, including the null character \verb!'\0'!.
\end{itemize}

\item \verb!func_deinit()! (optional)

The deinitialization function.
It should deallocate any memory allocated by the initialization function.
This function has the following signature:
\begin{verbatim}
void func_init(SEDNA_EF_INIT *init, char * error_msg_buf);
\end{verbatim}
\begin{itemize}
	\item \verb!init! is a pointer to the \verb!SEDNA_EF_INIT! structure which
		was passed to \verb!func_init! function (if written)
	\item \verb!error_msg_buf! is a pointer to the string buffer used for specifying error
		message if function invocation fails. Maximum message length is
		\verb!SEDNA_ERROR_MSG_BUF_SIZE!, including the null character \verb!'\0'!.
\end{itemize}

\end{itemize}

When \verb!func!, \verb!func_init! or \verb!func_deinit! is executed
\verb!error_msg_buf! contains an empty string. If function is executed
succesfully, it should not change this value. In case of error
a non-empty string (error description) must be placed in \verb!error_msg_buf!
(if you place an empty string in \verb!error_msg_buf! executor assumes
that function execution was successful)

Each shared library must also export an null-terminated array with the names
of the XQuery functions defined by this library:

\verb!char const *ef_names[] = { "func", NULL};!

The file \verb!sedna_ef.h! defines several types for representing
function arguments and results:
\begin{itemize}
	\item \verb!SEDNA_ATOMIC_TYPE!

		represents an atomic type:
		\begin{verbatim}
typedef enum sedna_atomic_type {
     SEDNATYPE_integer,
     SEDNATYPE_float,
     SEDNATYPE_double,
     SEDNATYPE_string
} SEDNA_ATOMIC_TYPE;
		\end{verbatim}

	\item \verb!SEDNA_ATOMIC_VALUE!

		represents an atomic value:
\begin{verbatim}
typedef int     SEDNA_integer;
typedef float   SEDNA_float;
typedef double  SEDNA_double;
typedef char   *SEDNA_string;
typedef struct sedna_atomic_value
{
    SEDNA_ATOMIC_TYPE type;
    union	{
        SEDNA_integer	val_integer;
        SEDNA_float	  val_float;
        SEDNA_double  val_double;
        SEDNA_string  val_string;
    };
} SEDNA_ATOMIC_VALUE;
\end{verbatim}

		Memory for values that are pointers (i.e. \verb!SEDNA_string!) MUST be
		allocated using the malloc function passed in the \verb!SEDNA_EF_INIT! structure.


	\item \verb!SEDNA_SEQUENCE_ITEM!
	  represents a node in a linked list of atomic values:

	  \begin{verbatim}
typedef struct sedna_sequence_item
{
    SEDNA_ATOMIC_VALUE	data;
    struct sedna_sequence_item	*next;
} SEDNA_SEQUENCE_ITEM;
		\end{verbatim}

		Linked lists are used to represent sequences of atomic values.
		An empty sequence is presented by a NULL pointer.
		If \verb!func! needs to return a sequence of values, memory for nodes
		MUST be allocated using the malloc function passed in \verb!SEDNA_EF_INIT!
		structure.

	\item \verb!SEDNA_EF_ARGS!
	  represents an array of arguments passed to a function:
	  \begin{verbatim}
typedef struct sedna_ef_args
{
    int length;
    SEDNA_SEQUENCE_ITEM **args;
} SEDNA_EF_ARGS;
\end{verbatim}
\end{itemize}

\subsubsection*{Location of External Function Libraries}
Compiled libraries must be placed in the directory \verb!lib! that is (1) in the same directory
where the directory \verb!data! with database data is located or (2) in the directory \verb!<db_name>_files! where database data are stored\footnote{See Section ``Sedna Directory Structure'' in \cite{doc:admin} to learn where database data are located}. Libraries that are database-independent should be placed in (1). Libraries that are database-specific should be placed in (2). Overloaded functions are not allowed. If two libraries located in (1) and (2) contain functions with the same name, a function from the library in (2) is called. If libraries in the same directory (1 or 2) contain functions with the same name, it is not specified which one is called.

There is a sample external function code available in the folder:
\begin{verbatim}
[win:] INSTALL_DIR\examples\api\external-functions\c\
\end{verbatim}
\begin{verbatim}
[nix:] INSTALL_DIR/examples/api/external-functions/c/
\end{verbatim}
where \verb!INSTALL_DIR! refers to the directory where Sedna is installed.


\subsection{Update Language}
\label{upd-lang}
The update language is based on the XQuery update proposal by Patrick Lehti \cite{paper:query-update} with the number of improvements.

\begin{note}The result of each update statement, shouldn't break the well-formedness and validness of XML entitites, stored in the database.
Otherwise, an error is raised.
\end{note}

\emph{INSERT}

The insert statement inserts content at positions identified by the \verb!into!, \verb!preceding! and \verb!following! clauses.

\begin{verbatim}
UPDATE
insert Expr1 (into|preceding|following) Expr2
\end{verbatim}

\verb!Expr1! identifies the ordered sequence of the nodes to be inserted. The \verb!into!, \verb!preceding! or \verb!following! clause identifies the position. For each node in the result sequence of \verb!Expr2!, the result sequence of \verb!Expr1! is inserted to the position identified by the \verb!into!, \verb!preceding! or \verb!following! clauses.
If the \verb!into! clause is specified, the sequence is appended to the random position of the child sequence for each node in the result of \verb!Expr2!. If the \verb!preceding! clause is specified, the sequence is appended before each node in the result of \verb!Expr2!. If the \verb!following! clause is specified, the sequence is appended after each node in the result of \verb!Expr2!.

If one of the following conditions is met an error occurs:
\begin{itemize}
\item There are non-element nodes in the result of \verb!Expr2! in case of the \verb!into! clause
\item There are temporary nodes in  \verb!Expr2! (a node is considered \emph{temporary}, if it is created as the result of the XQuery constructor evaluation.)
\end{itemize}

\begin{verbatim}
UPDATE
insert <warning>High Blood Pressure!</warning>
preceeding doc("hospital")//blood_pressure[systolic>180]
\end{verbatim}

\emph{DELETE}

The \verb!DELETE! statement serves to remove persistent nodes from the database. It contains a subexpression, that returns the nodes to be deleted.

\begin{verbatim}
UPDATE
delete Expr
\end{verbatim}
\verb!Expr! identifies the  nodes to be removed from the datatbase. Note, that nodes are removed from the database with all their descandants.

If one of the following conditions is met an error occurs:
\begin{itemize}
\item There are nodes in the result sequence of \verb!Expr! that are not stored in external memory
\end{itemize}

\begin{verbatim}
UPDATE
delete doc("hospital")//blood_pressure[systolic>180]
\end{verbatim}

\emph{DELETE\_UNDEEP}
\begin{verbatim}
UPDATE
delete_undeep Expr
\end{verbatim}

The \verb!DELETE_undeep! statement removes nodes identified by \verb!Expr!, but in contrast to the \verb!DELETE! statement it leaves the descendants of the nodes in the database.

Consider the following example:
\begin{verbatim}
A document named "a.xml" before update:
<A>
<B>
<C/>
<D/>
</B>
</A>

UPDATE
delete_undeep doc("a.xml")//B

The document after update:
<A>
<C/>
<D/>
</A>
\end{verbatim}

\emph{REPLACE}

The \verb!REPLACE! statement is used to replace nodes in an XML document in the following manner. Each node returned by \verb!Expr1! is replaced with the sequence of the nodes returned by \verb!Expr2! where \verb!$var! is bound to the node. Note that \verb!Expr2! is executed over the original document without taking into account intermediate updates performed during execution of this statement.

If one of the following conditions is met, an error occurs:
\begin{itemize}
\item There are atomic values in the result of \verb!Expr1!
\item There are temporary nodes in  \verb!Expr1! (a node is considered \emph{temporary}, if it is created as the result of the XQuery constructor evaluation.)
\end{itemize}

The \verb!$var! variable bound in \verb!replace! clause may have an optional type declaration. If the type of a value bound to the variable does not match the declared type, an error is raised.

\begin{verbatim}
UPDATE
replace $var [as type] in Expr1
with Expr2($var)
\end{verbatim}

In the following example the salary of persons named "John" is doubled.

\begin{verbatim}
UPDATE
replace $p in doc("foo.xml")/db/person[name="John"]
with
<person>
{($p/@*,
  $p/node()[not(self::salary)],
  for $s in $p/salary
  return <salary>{$s*2}</salary>)}
</person>
\end{verbatim}



\emph{RENAME}

The \verb!RENAME! statement is used to change the qualified name of an element or attribute.

\begin{verbatim}
UPDATE
rename Expr on QName
\end{verbatim}

The following expression changes the name of \verb!<job/>! elements without changing their contents:
\begin{verbatim}
UPDATE
rename doc("foo.xml")//job[.="bit banger"] on profession
\end{verbatim}

\subsection{Bulk Load}
\label{bulk-load}
To do bulk load use the following statements:
\begin{verbatim}
LOAD "path_to_file" "document_name"
\end{verbatim}

The first parameter is a path to the file which contains a document to be loaded. The second parameter is the name for this document in the database.

\begin{verbatim}
LOAD "path_to_file" "document_name" "collection_name"
\end{verbatim}

The first parameter is a path to the file which contains a document to be loaded. The second parameter is the name for this document in the database. The third parameter is the collection name to load the document into.

For performing bulk load not from the source file but from an input stream,
use the following statements:
\begin{verbatim}LOAD STDIN "document_name"\end{verbatim}

\begin{verbatim}LOAD STDIN "document_name" "collection_name"\end{verbatim}

Compared to the above bulk load statements, here the
\verb!"file_name"! is replaced by the keyword \verb!STDIN! to denote that
the file to be loaded is taken from the input stream. Characters in the input stream must form a well-formed XML document, which is loaded into the database and named as specified by
\verb!"document_name"!. If \verb!collection_name! is set, the document is loaded into the specified collection of the database.

By default, the standard input stream is used. You can redirect a different input stream to be used as an input for bulk load. For example, an XML document produced by some program as its output can be loaded to a Sedna database in a stream-wise fashion. To redirect the input when working from a command line, you can use the functionality provided by your operation system.
Java and Scheme APIs provide additional wrappers for bulk load from stream, such that the input stream can be specified by an additional argument of a function call.

By default, Sedna removes boundary whitespaces according to the boundary-space policy defined in \cite{paper:query-language}. To control boundary whitespaces processing, use \emph{boundary-space declaration} \cite{paper:query-language} in the prolog of the \verb!LOAD! statement.  The following example illustrates a boundary-space declaration that instructs Sedna to preserve whitespaces:
\begin{verbatim}
declare boundary-space preserve;
\end{verbatim}



\subsection{Data Definition Language}

This section describes Sedna Data Definition Language (DDL) that is used to create the database structures that will hold one�s data.

Most of parameters of Sedna DDL are computable and specified as XQuery expressions.
The expected type of all the parameters is \verb!xs:string!. All parameters are evaluated and atomized.
If the atomized value is not of \verb!xs:string!, a dynamic error is raised.

Note that the following statements are case sensitive and must be put in upper case (e.g. \verb!CREATE! is valid but \verb!create! is not).

\subsubsection{Managing Standalone Documents}
\begin{verbatim}
CREATE DOCUMENT doc-name-expr
\end{verbatim}

The \verb!CREATE! \verb!DOCUMENT! statement creates a new standalone document
with the name that is the result of \verb!doc-name-expr!.

\begin{verbatim}
DROP DOCUMENT doc-name-expr
\end{verbatim}

The \verb!DROP! \verb!DOCUMENT! statement drops the standalone document with the
name that is the result of \verb!doc-name-expr!.

For example, \verb!CREATE! \verb!DOCUMENT! \verb!"report"! creates a document named "report" and \verb!DROP! \verb!DOCUMENT! \verb!"report"! drops it.

\hbox{}

There is a system document \verb!$documents! which lists all available documents and collections. For details on retrieving metadata see \ref{managing-metadata} section.


\subsubsection{Managing Collections}

Sedna provides a mechanism of organizing multiple documents into a collection.
Collection provides a uniform way of writing XQuery and XML update statements
addressed to multiple documents at once.
Collections are preferable for situations when a group of documents is to be
queried/updated by means of not referring to their individual document names,
but according to some conditions over their content.

In a Sedna database, a document can be either a standalone one (when it
doesn't belong to any collection) or belonging to some collection.
Compared to standalone documents, all documents within a given collection have
a common descriptive schema.
The common descriptive schema (which can be considered as a union of
individual descriptive schemas for all documents that belong to a collection)
allows addressing XQuery and XML update queries to all members of a collection.

Below is the specification of syntax and semantic of statements that manage
collections.

\begin{verbatim}CREATE COLLECTION coll-name-expr\end{verbatim}

The \verb!CREATE COLLECTION! statement creates a new collection with the
name that is the result of \verb!coll-name-expr!.

For example, \verb!CREATE COLLECTION! \verb!"mails"! creates a collection named "mails".

XML documents can be loaded into the collection, as previously described in
section \ref{bulk-load}.

To access a single document from collection in an XQuery or XML update query,
the \verb!document! function accepts a collection name as its second optional
argument:

\begin{verbatim}document(doc-name-expr, coll-name-expr)\end{verbatim}

The function returns the document with
the \verb!doc-name-expr! name that belongs to the collection named \verb!coll-name-expr!.

\begin{verbatim}collection(coll-name-expr)\end{verbatim}

The function \verb!collection! can be called from any place within an XQuery or
XML update query where the function call is allowed.
The \verb!collection! function returns the sequence of all documents that
belong to the collection named \verb!coll-name-expr!.
The relative order of documents in a sequence returned by \verb!collection!
function is currently undefined in Sedna.

Conventional XQuery predicates can be used for filtering the sequence returned
by the \verb!collection! function call, for selecting certain documents that
satisfy the desired condition.

\begin{verbatim}
CREATE DOCUMENT doc-name-expr IN COLLECTION coll-name-expr
\end{verbatim}

This statement creates a new document named \verb!doc-name-expr! in a collection named \verb!coll-name-expr!.

For example, \verb!CREATE DOCUMENT! \verb!"mail1"! \verb!IN COLLECTION! \verb!"mails"! creates a document named "mail1" in the collection named "mails".

\begin{verbatim}DROP DOCUMENT doc-name-expr IN COLLECTION coll-name-expr\end{verbatim}

The \verb!DROP DOCUMENT IN COLLECTION! statement drops the document named
\verb!doc-name-expr! located in the collection named \verb!coll-name-expr!.

\begin{verbatim}DROP COLLECTION coll-name-expr\end{verbatim}

The \verb!DROP COLLECTION! statement drops the collection with the
\verb!coll-name-expr! name from the database.
If the collection contains any documents, these documents are dropped as well.

\begin{verbatim}
RENAME COLLECTION old-name-expr INTO new-name-expr
\end{verbatim}

The \verb!RENAME COLLECTION! statement renames collection with the name that is result of the \verb!old-name-expr!.
The new name is assigned which is result of the \verb!new-name-expr!.
Both result of the \verb!old-name-expr! and result of the \verb!new-name-expr! after atomization applied must be either
of type \verb!xs:string! (or derived) or promotable to \verb!xs:string!.

\hbox{}

There is a system document \verb!$collections! which lists all available collections. For details on retrieving metadata see \ref{managing-metadata} section.

\subsubsection{Managing Value Indices}
\label{sec:managing-value-indices}
Sedna supports value indices based on B-tree to index XML element content 
and attribute values. Below is the description of statements to manage indices.

\begin{verbatim}
CREATE INDEX title-expr
ON Path1 BY Path2
AS type
\end{verbatim}

The \verb!CREATE INDEX! creates an index on nodes (specified by \verb!Path1!)
by keys (specified by \verb!Path2!).

\verb!Path1! is an XPath expression without any filter expressions that
identifies the nodes of a document or a collection that are to be indexed.
\verb!Path2! is an XPath expression without any filter expressions that
specifies the relative path to the nodes whose string-values are used as keys
to identify the nodes returned by the \verb!Path1! expression. The \verb!Path2!
expression should not start with '/' or '//'. The full path from the root of
documents (that may be in a collection) to the key nodes is \verb!Path1/Path2!.

For instance, let \verb!Path1! be \verb!doc("a")/b/c! and \verb!Path2! be
\verb!d!. Let \verb!X! be the node returned by the \verb!Path1! expression, and
\verb!Y! be one of the nodes returned by the \verb!doc("a")/b/c/d! expression.
If \verb!Y! is the descendant of \verb!X!, then the value of \verb!Y! is used as
the key for searching the node \verb!X!.

\verb!title-expr! is the title of the index created.
It should be unique for each index in the database.

\verb!type! is an atomic type which the value of the keys should be cast to.
The following types are supported: \verb!xs:string!, \verb!xs:integer!,
\verb!xs:float!, \verb!xs:double!, \verb!xs:date!, \verb!xs:time!,
\verb!xs:dateTime!, \verb!xs_yearMonthDuration!, \verb!xs_dateTimeDuration!.

In the following example, people are indexed by the names of their cities. 
To generate the index keys, city names are cast to the \verb!xs:string! type.

\begin{verbatim}
CREATE INDEX "people"
ON doc("auction")/site//person BY address/city
AS xs:string
\end{verbatim}

To remove an index, use the following statement:
\begin{verbatim}
DROP INDEX title-expr
\end{verbatim}

The DROP INDEX statement removes the index named \verb!title-expr! from
the database.

\begin{note}In the current version of Sedna, query executor does not use
indices automatically. You can enforce the executor to employ indices by
using the XQuery index-scan functions specified in section
\ref{sec:value-index-scan-fun}.
\end{note}


\subsubsection{Managing Full-Text Indices}
\label{sec:managing-ft-indices}
Sedna is integrated with dtSearch \cite{link:dtsearch-engine}, a commercial text retrieval engine, which provides full-text indices. The integration allows combining XQuery with full-text search facilities. As dtSearch is a third party commercial product, Sedna does not include dtSearch. If you are interested in using Sedna with dtSearch, please contact us.

Below is the description of statements to manage dtSearch full-text indices in Sedna.

\begin{verbatim}
CREATE FULL-TEXT INDEX title-expr
ON path
TYPE type
\end{verbatim}

The \verb!CREATE INDEX! indexes nodes (specified by \verb!path!) by a text representation of the nodes. The text representations of the nodes are constructed according to \verb!type!.

\verb!title-expr! is the title of the index created. It should be unique for each index in the database.

\verb!path! is an XPath expression without any filter expressions that identifies the nodes of a document or a collection that are to be indexed. An example of the \verb!path! expression is as follows \verb!doc("foo")/library//article!.

\verb!type! specifies how the text representations of nodes are constructed when the nodes are indexed. \verb!type! can have one of the following values:
\begin{itemize}
\item \verb!"xml"! - The XML representations of the nodes are used.
\item \verb!"string-value"! - The string-values of the nodes are used as obtained using standard XQuery \verb!fn:string! function. The string-value of a node is the concatenated contents of all its descendant text nodes, in document order.
\item \verb!"delimited-value"! - The same as \verb!"string-value"! but blank characters are inserted between  text nodes.
\item \verb!"customized-value"! \verb!((element-qname, type), ... (element-qname, type))! - This option allows specifying  types for particular element nodes. Here \verb!element-qname! is a QName of an element, \verb!type! can have one of the values listed above (i.e. \verb!"xml"!, \verb!"string-value"!, \verb!"delimited-value"!). For those elements that are not specified in the list, the \verb!"xml"! type is used by default.
\end{itemize}

In the following example, articles are indexed by their contents represented as XML.

\begin{verbatim}
CREATE FULL-TEXT INDEX "articles"
ON doc("foo")/library//article
TYPE "xml"
\end{verbatim}

The example below illustrates the use of \verb!"customized-value"! type.
\begin{verbatim}
CREATE FULL-TEXT INDEX "messages"
ON document("foo")//message
TYPE "customized-value" (("b", "string-value"), ("a", "delimited-value"))
\end{verbatim}

To remove an full-text index, use the following statement:
\begin{verbatim}
DROP FULL-TEXT INDEX title-expr
\end{verbatim}

The DROP INDEX statement removes the index named \verb!title-expr! from the database.

\begin{note}In the current version of Sedna, query executor does not use full-text indices automatically. You can enforce the executor to employ indices by
using the XQuery full-text search functions specified in section \ref{sec:ft-fun}.
\end{note}

\subsubsection{Managing Modules}
XQuery allows putting functions in library modules, so that they can be shared and imported by any query.
A library module contains a module declaration followed by variable and/or function declarations. The module declaration specifies its target namespace URI which is used to identify the module in the database. For more information on modules see the XQuery specification \cite{paper:query-language}.

Before a library module could be imported from an query, it is to be loaded into the database. To load a module, use the following statement.

\begin{verbatim}
LOAD MODULE "path_to_file", ..., "path_to_file"
\end{verbatim}

Each \verb!path_to_file! specifies a path to the file. If only one parameter is supplied, it refers to the file which contains the module definition. The module definition can also be divided into several files. In this case all files must have a module declaration with the same target namespace URI (otherwise an error is raised).

For example, suppose that you have the following module stored in \verb!math.xqlib!.

\begin{verbatim}
module namespace math = "http://example.org/math";

declare variable $math:pi as xs:decimal := 3.1415926;

declare function math:increment($num as xs:decimal) as xs:decimal {
    $num + 1
};

declare function math:square($num as xs:decimal) as xs:decimal {
    $num * $num
};
\end{verbatim}

You can load this module as follows.

\begin{verbatim}
LOAD MODULE "math.xqlib"
\end{verbatim}

Once an library module is loaded into the database, it can be imported into an query using conventional XQuery module import \cite{paper:query-language}. For example, you can import the above module as follows.

\begin{verbatim}
import module namespace math = "http://example.org/math";

math:increment(math:square($math:pi))

\end{verbatim}


To replace an already loaded module with new one, use the following statement.

\begin{verbatim}
LOAD OR REPLACE MODULE "path_to_file", ..., "path_to_file"
\end{verbatim}

To remove a library module from the database, use the following statement.

\begin{verbatim}
DROP MODULE "target_namespace_URI"
\end{verbatim}

It results in removing the library module with the given target namespace URI from the database.

You can obtain information about modules loaded into the database by querying the system document named \verb!$modules! as follows \verb!doc("$modules")!.


\subsubsection{Retrieving Metadata, System Parameters and Environment Information}
\label{managing-metadata}
You can retrieve various metadata about database objects (such as documents, collections, indexes, etc.) by querying system documents and collections listed below. 
To retrieve system parameters or environment information (like current user name) you can use \verb!se:get-property! function.

\subsubsection*{System Documents and Collections}

Names of the system documents and collections start with \verb!$! symbol. The documents marked with (*) are not persistent but generated on the fly. You can query these documents as usual but you cannot update them.
Also these documents are not listed in \verb!$documents!.

\begin{itemize}
\item (*) document \verb!$documents! - list of all stand-alone documents, collections and in-collection documents except those documents of this enumeration that are marked with (*).
\item (*) document \verb!$collections! - list of all collections
\item (*) document \verb!$modules! - list of the names of all XQuery modules
\item collection \verb!$modules! - contains documents with precompiled definitions of XQuery modules
\item (*) document \verb!$indexes! - list of indexes with information about them
\item (*) document \verb!$ftindexes! - list of full-text indexes with information about them (if compiled with \verb!SE_ENABLE_FTSEARCH!)
\item document \verb!$db_security_data! - list of users and privileges on database objects
\item (*) document \verb!$schema! - descriptive schema of all documents and collections with some schema-related  information
\item (*) document \verb!$errors! - list of all user errors
\item (*) document \verb!$version! - version and build numbers
\item (*) document \verb!$schema_<name>! - the descriptive schema of the document or collection named \verb!<name>!
\item (*) document \verb!$document_<name>! - statistical information about the document named \verb!<name>!
\item (*) document \verb!$collection_<name>! - statistical information about the collection named \verb!<name>!
\end{itemize}


The statistical information in \verb!$document_<name>! and \verb!$collection_<name>! contains the following elements:

\begin{itemize}
\item \verb!total_schema_nodes! - the number of the nodes of the descriptive schema
\item \verb!total_schema_text_nodes! - the number of the attribute and text nodes of the descriptive schema
\item \verb!total_nodes! - the number of the nodes of the document (or collection)
\item \verb!schema_depth! - the maximal depth of the document (or collection)
\item \verb!total_desc_blk! - the number of  the descriptor blocks occupied by document (or collection)
\item \verb!total_str_blk! - the number of  the text blocks occupied by document (or collection)
\item \verb!saturation! - fill factor of the blocks (in percents)
\item \verb!total_innr_blk! - the number of  the descriptor blocks occupied by document (or collection) except first and last blocks in each chain of blocks
\item \verb!total_innr_size! - the size of the inner blocks
\item \verb!innr_blk_saturation! - fill factor of the inner blocks (in percents)
\item \verb!strings! - the share of  the string blocks (in percents)
\item \verb!descriptors! - the share of  the descriptor blocks (in percents)
\item \verb!nid! - the share of  the long labeling numbers' ($>11$) total size (in percents)
\item \verb!indirection! - the share of  the indirection records' total size (in percents)
\item \verb!total_size! - the total size of the document (or collection), in MGBs
\item \verb!string_size! - the total size of the string blocks , in MGBs
\item \verb!descriptor_size! - the total size of the descriptor blocks , in MGBs
\item \verb!nids_size! - the total size of the long labeling numbers , in MGBs
\item \verb!free_space_in_str_blocks! - the total size of the free space in the string blocks
\item \verb!indirection_size! - the total size of the indirection records , in MGBs
\item \verb!nids_size! - the share of  the indirection records' total size (in percents)
\item \verb!STRINGS! - the histogram of the xml data by its size
\item \verb!NID! - the histogram of the labeling numbers its length
\end{itemize}

\subsubsection*{Using se:get-property function}
The \verb!se:get-property! function provides a method for applications to determine the current values of a system parameters, configurable limits, environment information.
The name argument specifies the system variable to be queried. The function is defined within predefined Sedna namespace (\verb!se! prefix) as follows:

\begin{verbatim}
se:get-property($name as xs:string) as item()
\end{verbatim}

The available \verb!names! are as follows:

\begin{itemize}
\item \verb!$user! - retrieves string which contains current user name
\end{itemize}

%==================================================================================
%																				 ==
%								XQuery Triggers 								 ==
%																				 ==
%==================================================================================
\subsection{XQuery Triggers}

XQuery triggers support in Sedna is provided as an XQuery extension. To create a trigger into the Sedna database you have to issue the following \verb!CREATE TRIGGER! statement:

\begin{verbatim}
CREATE TRIGGER trigger-name
( BEFORE | AFTER ) (INSERT | DELETE | REPLACE)
ON path
( FOR EACH NODE | FOR EACH STATEMENT )
DO
{
  Update-statement ($NEW, $OLD,$WHERE);
            . . .
  Update-statement ($NEW, $OLD,$WHERE);
  XQuery-statement ($NEW, $OLD, $WHERE);
}
\end{verbatim}

The \verb!DROP! \verb!TRIGGER! statement drops the trigger with the
name which is the result of the \verb!trigger-name-expression!.

\begin{verbatim}
DROP TRIGGER trigger-name-expression
\end{verbatim}

Triggers can be defined to execute either \emph{before} or \emph{after} any \verb!INSERT!, \verb!DELETE! or \verb!REPLACE! operation, either once per modified node (\emph{node-level} triggers), or once per XQuery statement (\emph{statement-level} triggers). If a trigger event occurs, the trigger's action is called at the appropriate time to handle the event.

\begin{itemize}
\item \verb!trigger-name! is the unique trigger name.

\item \verb!ON path! is XPath expression without any filter expression (predicates) that identifies the nodes on which the trigger is set. That means that the trigger fires when corresponding modification (insertion, deletion or replacement) of those nodes occurs. This XPath expression is prohibited to have predicates and parent axes.

\item \verb!FOR EACH NODE!/\verb!FOR EACH STATEMENT!: these key words mean the trigger created is a \verb!node-level! or \verb!statement-level! trigger. With a node-level trigger, the trigger action is invoked once for each node that is affected by the update statement that fired the trigger. In contrast, a statement-level trigger is invoked only once when an appropriate statement is executed, regardless of the number of nodes affected by that statement.

\item \verb!BEFORE!/\verb!AFTER!: triggers are also classified as \emph{before}-triggers and \emph{after}-triggers. \verb!BEFORE! keyword in \verb!CREATE TRIGGER! statement means the trigger created is \emph{before}-trigger; \verb!AFTER! keyword means the trigger created is \emph{after}-trigger. Statement-level-before triggers fire before the statement starts to do anything, while statement-level-after triggers fire at the very end of the statement. Node-level-before triggers fire immediately before a particular node is operated on, while node-level-after triggers fire immediately after the node is operated on (but before any statement-level-after trigger).

\item \verb!DO!: trigger action is specified in braces \verb!{}! after the \verb!DO! key word. Action contains zero or more update statements and an XQuery query. It is a mandatory requirement that node-level trigger action  ends with an XQuery query, while this is optional for actions of statement-level triggers. It is prohibited to use prolog in statements of the trigger action.

\item Transition variables \verb!$NEW!, \verb!$OLD! and \verb!$WHERE! are defined for each node-level trigger firing and can be used in each statement of the trigger action. These tree variables are defines as follows:
\begin{itemize}
\item For \verb!INSERT!: \verb!$NEW! is the node being inserted; \verb!$OLD! is undefined; \verb!$WHERE! is the parent node in case in \emph{insert-into} statement and sibling node in case of \emph{insert-preceding} and \emph{insert-following} statements;
\item For \verb!DELETE!: \verb!$NEW! is undefined; \verb!$OLD! is the node being deleted; \verb!$WHERE! is the parent of the deleted node;
\item For \verb!REPLACE!: \verb!$NEW! is the node being inserted during the replacement; \verb!$OLD! is the node being replaced; \verb!$WHERE! is the parent of the replaced node.
\end{itemize}
You cannot use transition variables in statement-level triggers.
\end{itemize}

XQuery query in the trigger action of a node-level trigger can \emph{return a node} to the calling executor, if they choose. A node-level-trigger fired before an operation has the following choices:

\begin{itemize}
\item It can return \verb!empty sequence! (\verb!( )!) to skip the operation for the current node. This instructs the executor to not perform the node-level operation that invoked the trigger (the insertion or replacement of a particular node).

%\item For node-level \verb!INSERT! and \verb!REPLACE! triggers only, the returned node becomes the node that \emph{will be inserted} or \emph{will replace} the node being updated. This allows the %trigger to modify the node being inserted or updated.

\item For node-level \verb!INSERT! triggers only, the returned node becomes the node that \emph{will be inserted}. This allows the trigger to modify the node being inserted.

\item A node-level before trigger that does not intend to cause either of these behaviors must be careful to return as its result the same node that was passed in (that is, the \verb!$NEW! node for \verb!INSERT! and \verb!REPLACE! triggers. For \verb!DELETE! triggers � its returned value is ignored in all cases except it is an empty sequence).
\end{itemize}

The trigger action return value is ignored for node-level triggers fired after an operation, and for all statement-level triggers, and so they may as well return empty sequence.

If more than one trigger is defined for the same event on the same document, the triggers will be fired in alphabetical order by trigger name. In the case of before triggers, the possibly-modified node returned by each trigger becomes the input to the next trigger. If any before trigger returns empty sequence, the operation is abandoned for that node and subsequent triggers are not fired.


Typically, node-level-before triggers are used for checking or modifying the data that will be inserted or updated. For example, a before trigger might be used to insert the current time node as a child of the inserting node, or to check that two descendants of the inserting node are consistent. Node-level-after triggers are most sensibly used to propagate the updates to other documents, or make consistency checks against other documents. The reason for this division of labor is that an after-trigger can be certain it is seeing the final value of the node, while a before-trigger cannot; there might be other before triggers firing after it. When designing your trigger-application note, that node-level triggers are typically cheaper then statement-level ones.

If a trigger function executes update-statement then these commands may fire other triggers again (cascading triggers). Currently \emph{trigger cascading level} in Sedna is limited to 10.

\begin{figure}[h]
\begin{center}
{\footnotesize\begin{tabular}{|c||c|c|c|}

\hline
   & \emph{update}:  & \emph{update}:  & \emph{update}:  \\
   & INSERT   & DELETE   & REPLACE  \\
\hline
\hline
\emph{trigger event}:  & length of trigger path &   &  length of trigger path   \\
     INSERT            &          $>$=          &   &          $>$=             \\
                       & length of update path  &   &  length of update path    \\


\hline

\emph{trigger event}:  &  & length of trigger path &  length of trigger path \\
      DELETE           &  &         $>$=           &          $>$=          \\
                       &  & length of update path  &  length of update path \\


\hline

\emph{trigger event}: &  &   &  length of trigger path \\
      REPLACE         &  &   &         $>$=            \\
                      &  &   &  length of update path  \\
\hline

\end{tabular}}
\caption{\label{triggertab} Update and trigger path lengths needed for trigger firing}
\end{center}
\end{figure}

\begin{note}
Currently is it prohibited in a trigger action to update the same document that is being updated by the outer update statement that has fired this trigger.
\end{note}


Note also that hierarchy of the XML data sometimes can affect the trigger firing in a complicated way. For example, if a node is deleted with all its descendant subtree, then a \verb!DELETE!-trigger set on the descendants of the deleting node is fired. In this situation \emph{length of trigger path} $>$= \emph{length of update path}.  In general, triggers fire according to the table in figure \ref{triggertab}.




\subsubsection{Trigger examples}

The following trigger is set on insertion of \verb!person! nodes. When some \verb!person! node is inserted, the trigger analyzes its content and modifies it in the following way. If the person is under 14 years old, the trigger inserts additional child node \verb!age-group! with the text value 'infant': if the person is older than 14 years old - the trigger inserts \verb!age-group! node with value 'adult'.

{\footnotesize\begin{verbatim}
CREATE TRIGGER "tr1"
BEFORE INSERT
ON doc("auction")/site//person
FOR EACH NODE
DO
{
	if($NEW/age < 14)
	then
	  <person>{attribute id {$NEW/@id}}
	          {$NEW/*}
	          <age-group>infant</age-group>
	  </person>
	else
	  <person>{attribute id {$NEW/@id}}
	          {$NEW/*}
	          <age-group>adult</age-group>
	  </person>;
}
\end{verbatim}}

The following trigger \emph{tr2} prohibits (throws exception) stake increase if the person has already more than 3 open auctions.
\begin{verbatim}
CREATE TRIGGER "tr2"
BEFORE INSERT
ON doc("auction")/site/open_auctions/open_auction/bidder
FOR EACH NODE
DO
{
 if(($NEW/increase > 10.5) and
  (count($WHERE/../open_auction[bidder/personref/@person=$NEW/personref/@person])
   > 3))
 then error(xs:QName("tr2"),"The increase is prohibited")
 else ($NEW);
}
\end{verbatim}

The following trigger \emph{tr3} cancels \verb!person! node deletion if there are any open auctions referenced by this person:

\begin{verbatim}
CREATE TRIGGER "tr3"
BEFORE DELETE
ON doc("auction")/site//person
FOR EACH NODE
DO
{
	if(exists($WHERE//open_auction/bidder/personref/@person=$OLD/@id))
	then ( )
	else $OLD;
}
\end{verbatim}

The next statement-level trigger \emph{tr4} maintains statistics in document \emph{stat}. When this trigger is fired, the update operation is completed � that gives the possibility to make aggregative checks on the updated data. After deletion of any node in \emph{auction} document, the trigger refreshes statistics in \emph{stat} and throws exception if there are more then 50 persons left.

\begin{verbatim}
CREATE TRIGGER "tr4"
AFTER DELETE
ON doc("auction")//*
FOR EACH STATEMENT
DO
{
	UPDATE replace $b in doc("stat")/stat with
	 <stat>
	  <open_auctions>{count(doc("auction")//open_auction)}</open_auctions>
	  <closed_auctions>{count(doc("auction")//closed_auction)}</closed_auctions>
	  <persons>{count(doc("auction")//person)}</persons>
	 </stat>;

	UPDATE insert
	        if(count(doc("auction")//person) < 10)
	        then <warning>"Critical number of person left in the auction"</warning>
	        else ( )
	       into doc("stat")/stat;

}
\end{verbatim}

%==================================================================================
%																				 ==
%								Debug Facilities								 ==
%																				 ==
%==================================================================================

\subsection{Debug and Profile Facilities}
\subsubsection{Trace}
\label{trace}
Sedna supports standard XQuery function \verb!fn:trace! \cite{paper:query-fo} providing user helper facility to trace queries. While executing XQuery query using fn:trace function intermediate results are shown to the user.

For example in Sedna Terminal the query with \verb!fn:trace! function will provide the following output. Trace information is marked with \verb!##! string:

\begin{verbatim}
x> let $r:= trace(doc("region")/regions/*, "## ")
   return $r[id_region="afr"]&
result:
## <africa>
##  <id_region>afr</id_region>
## </africa>
<africa>
 <id_region>afr</id_region>
</africa>
##
## <asia>
##  <id_region>asi</id_region>
## </asia>
##
## <australia>
##  <id_region>aus</id_region>
## </australia>
##
## <europe>
##  <id_region>eur</id_region>
## </europe>
##
## <namerica>
##  <id_region>nam</id_region>
## </namerica>
##
## <samerica>
##  <id_region>sam</id_region>
## </samerica>
\end{verbatim}

If you want to use trace facility in your application working through Sedna API you should set your own debug handler as it is shown in \ref{exec-capi} section.

\subsubsection{Session Debug Mode}
\label{session-debug-mode}
In addition to trace facility provided by standard XQuery fn:trace function (see section above) you can use session debug mode. You can turn on session
debug mode in Sedna Terminal (for details see "Sedna Terminal" section of the Sedna's Administration Guide) or in your application using corresponding 
Sedna API functions (see \ref{session-option-capi} section).

Each query in Sedna is represented and executed internally as a tree of the physical operations. Debug mode is mechanism that allows to get stack of the 
physical operations after dynamic error was raised. It serves two goals:

\begin{itemize}
\item localize error in the query's source code;
\item obtain information of the query execution process.
\end{itemize}

Let us consider the following query to illustrate execution in the debug mode:
\newline
\newline
\textbf{Query:}

\begin{verbatim}
(: In this query dynamic error will be raised   :)
(: due to "aaaa" is not castable to xs:integer. :)
declare function local:f()
{
    "aaaa" cast as xs:integer
};
local:f()
\end{verbatim}
\textbf{Output:}

\begin{verbatim}
PPCast : 1
PPFunCall : 1 : http://www.w3.org/2005/xquery-local-functions:f
SEDNA Message: ERROR FORG0001
        Invalid value for cast/constructor.
Details: Cannot convert to xs:integer type
\end{verbatim}

As you can see in the output above each item of the operations stack list consists of the following parts:

\begin{itemize}
\item operation name (PPCast and PPFunCall in the example);
\item calls counter - number of calls of the operation;
\item optional additional information (qualified name of the function in the example).
\end{itemize}

\subsubsection{Explain Query}
The explain statement has the following syntax:
\begin{verbatim}
EXPLAIN
{XQuery or Update statement to explain}
\end{verbatim}
Each query in Sedna is represented and executed internally as a tree of the physical operations. With the help of \verb!EXPLAIN! statement you
can obtain detailed query execution plan which shows how Sedna executes this query. 
\newline
\newline
The following query illustrates \verb!EXPLAIN! statement execution:
\newline
\newline
\textbf{Query:}
\begin{verbatim}
explain
declare function local:fact($i as xs:integer) as xs:integer {
    if ($i <= 1)
    then 1
    else $i * local:fact($i - 1)
};

local:fact(10)
\end{verbatim}
\textbf{Output:}

\begin{verbatim}
<plolog xmlns="http://www.modis.ispras.ru/sedna">
  <function id="0" function-name="local:fact" type="xs:integer">
    <arguments>
      <argument descriptor="0" type="xs:integer"/>
    </arguments>
    <operation name="PPIf" position="2:5">

      <operation name="PPLMGeneralComparison" 
                 comparison="le" position="2:12">

        <operation name="PPVariable" descriptor="0" 
                   variable-name="i" position="2:9"/>

        <operation name="PPConst" type="xs:integer" 
                   value="1" position="2:15"/>
      </operation>
      <operation name="PPConst" type="xs:integer" 
                 value="1" position="3:10"/>

      <operation name="PPCalculate" position="4:10">
        <operation name="BinaryOp" operation="*">
          <operation name="LeafAtomOp">

            <operation name="PPVariable" descriptor="0" 
                       variable-name="i" position="4:10"/>
          </operation>

          <operation name="LeafAtomOp">
            <operation name="PPFunCall" id="0" 
                       function-name="local:fact" position="4:15">
              <operation name="PPCalculate" position="4:26">
                <operation name="BinaryOp" operation="-">
                  <operation name="LeafAtomOp">
                    <operation name="PPVariable" descriptor="0" 
                               variable-name="i" position="4:26"/>
                  </operation>
                  <operation name="LeafAtomOp">
                    <operation name="PPConst" type="xs:integer" 
                               value="1" position="4:31"/>
                  </operation>
                </operation>
              </operation>
            </operation>
          </operation>
        </operation>
      </operation>
    
    </operation>
  </function>
</plolog>

<query xmlns="http://www.modis.ispras.ru/sedna">
  <operation name="PPQueryRoot">
    <operation name="PPFunCall" id="0" 
               function-name="local:fact" position="7:1">

      <operation name="PPConst" type="xs:integer" 
                 value="10" position="7:12"/>

    </operation>
  </operation>
</query>
\end{verbatim}

Explain output consists of two parts (just like any XQuery query): prolog and query body explanations. Prolog part includes complete 
information about all declarations: namespaces, functions, global variables with complete physical plan for each user defined function and global variable. 
Query body explanation part describes physical tree of the query.

For each physical operation \verb!EXPLAIN! returns: name of the operation (\verb!PPConst!, \verb!PPFunCall!, etc), corresponding position in the source query
(e.g. 4:31 means that operation \verb!PPConst! corresponds to the '1' atomic at the line 4, column 26). Output may also contain additional information 
depending on the operation type (for example, variable name for some \verb!PPVariable! operations).


\begin{thebibliography}{9}
\bibitem{doc:admin} ``Sedna Administration Guide''
\bibitem{paper:data-model} ``XQuery 1.0 and XPath 2.0 Data Model'', W3C Recommendation
\bibitem{paper:query-language} ``XQuery 1.0: An XML Query Language'', W3C Recommendation
\bibitem{paper:query-fo} ``XQuery 1.0 and XPath 2.0 Functions and Operators'', W3C Recommendation
\bibitem{paper:query-serialization} ``XSLT 2.0 and XQuery 1.0 Serialization'', W3C Recommendation
\bibitem{paper:query-update} Patrick Lehti. ``Design and Implementation of a Data Manipulation Processor for a XML Query Language'', http://www.ipsi.fraunhofer.de/~lehti/
\bibitem{lib:pcre-lib} http://www.pcre.org/
\bibitem{paper:sedna-overview}
Maxim Grinev, Andrey Fomichev, Sergey Kuznetsov, Kostantin Antipin, Alexander Boldakov, Dmitry Lizorkin, Leonid Novak, Maria Rekouts, Peter Pleshachkov. ``Sedna: A Native XML DBMS'', http://www.modis.ispras.ru/publications.htm

\bibitem{paper:sedna-api} Rekouts Maria. ``Application Programming Interface for XML DBMS: design and implementation proposal'', http://www.modis.ispras.ru/publications.htm

\bibitem{paper:scheme-ql}
Noel Welsh, Francisco Solsona, Ian Glover.
``SchemeUnit and SchemeQL: Two little languages'',
Scheme Workshop 2002,
http://schematics.sourceforge.net/schemeunit-schemeql.ps

\bibitem{paper:sxml}
Oleg Kiselyov.
``SXML Specification, Revision 3.0'',
http://www.okmij.org/ftp/Scheme/SXML.html

\bibitem{paper:srfi-12}
William Clinger, R.\ Kent Dybvig, Matthew Flatt, and Marc Feeley.
``SRFI-12: Exception Handling'',
http://srfi.schemers.org/srfi-12/srfi-12.html

\bibitem{paper:chicken}
Felix L.\ Winkelmann.
``Chicken -- A practical and portable Scheme system'',
http://www.call-with-current-continuation.org/chicken.pdf

\bibitem{paper:sxpath}
Kirill Lisovsky, Dmitry Lizorkin.
``XML Path Language (XPath) and its functional implementation SXPath'',
Russian Digital Libraries Journal , 2003, Volume 6, Issue 4,
http://www.elbib.ru/index.phtml?page=elbib/eng/journal/2003/part4/LL

\bibitem{link:dtsearch-engine}
dtSearch Engine home page,
http://www.dtsearch.com/PLF\_engine\_2.html

\bibitem{doc:dtsearch}
dtSearch Web Help
http://support.dtsearch.com/webhelp/dtsearch


\end{thebibliography}

\end{document}
